<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Cycler Display</title>
    <style>
        :root {
            --text-color: #ffffff;
            --font-size: 48px;
            --font-family: 'Segoe UI', system-ui, sans-serif;
            --font-weight: 700;
            --text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            --transition-duration: 500ms;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            font-family: var(--font-family);
        }

        .container {
            text-align: center;
            width: 100%;
            padding: 20px;
        }

        .text-display {
            font-size: var(--font-size);
            font-weight: var(--font-weight);
            color: var(--text-color);
            text-shadow: var(--text-shadow);
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.2;
            
            /* Animation base */
            opacity: 1;
            transform: translateY(0) scale(1);
            transition: opacity var(--transition-duration) ease,
                        transform var(--transition-duration) ease;
        }

        /* Fade animation */
        .text-display.fade-out {
            opacity: 0;
        }

        .text-display.fade-in {
            opacity: 1;
        }

        /* Slide animations */
        .text-display.slide-out-left {
            opacity: 0;
            transform: translateX(-100px);
        }

        .text-display.slide-out-right {
            opacity: 0;
            transform: translateX(100px);
        }

        .text-display.slide-out-up {
            opacity: 0;
            transform: translateY(-50px);
        }

        .text-display.slide-out-down {
            opacity: 0;
            transform: translateY(50px);
        }

        /* Scale animations */
        .text-display.scale-out {
            opacity: 0;
            transform: scale(0.5);
        }

        .text-display.scale-in {
            opacity: 1;
            transform: scale(1);
        }

        /* Pop animation */
        .text-display.pop-in {
            animation: popIn var(--transition-duration) cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.3); }
            50% { transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }

        /* Typewriter cursor */
        .text-display.typewriter::after {
            content: '|';
            animation: blink 0.7s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Glitch effect */
        .text-display.glitch {
            animation: glitch 0.1s infinite;
        }

        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        /* Status indicator (hidden by default) */
        .status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            font-size: 12px;
            color: rgba(255,255,255,0.3);
            display: none;
        }

        body.debug .status {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="text-display" id="textDisplay">Ready</div>
    </div>
    <div class="status" id="status">Waiting for connection...</div>

<script>
// ============ Configuration ============
const urlParams = new URLSearchParams(window.location.search);
const CONFIG_ID = urlParams.get('id') || 'default';
const DEBUG = urlParams.get('debug') === 'true';

// Style overrides from URL
const customStyles = {
    color: urlParams.get('color'),
    size: urlParams.get('size'),
    font: urlParams.get('font'),
    weight: urlParams.get('weight'),
    shadow: urlParams.get('shadow'),
    align: urlParams.get('align')
};

// Apply custom styles
if (customStyles.color) document.documentElement.style.setProperty('--text-color', customStyles.color);
if (customStyles.size) document.documentElement.style.setProperty('--font-size', customStyles.size);
if (customStyles.font) document.documentElement.style.setProperty('--font-family', customStyles.font);
if (customStyles.weight) document.documentElement.style.setProperty('--font-weight', customStyles.weight);
if (customStyles.shadow) document.documentElement.style.setProperty('--text-shadow', customStyles.shadow);
if (customStyles.align) document.querySelector('.container').style.textAlign = customStyles.align;

if (DEBUG) document.body.classList.add('debug');

// ============ Character Sets ============
const CHARS_STANDARD = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
const CHARS_ENCHANT = 'á”‘á’·á“µ[EMOJI]á’·[EMOJI]âŠ£[EMOJI]â•Žâ‹®ê–Œê–Žá’²ãƒªð™¹á‘‘âˆ·á“­â„¸[EMOJI][EMOJI]âˆ´â¨…';
const CHARS_GLITCH = 'â–ˆâ–“â–’â–‘â•”â•—â•šâ•â•‘â•â”Œâ”â””â”˜â”‚â”€â”¼â–€â–„â–Œâ–â– â–¡â–ªâ–«â—â—‹';

// ============ State ============
const display = document.getElementById('textDisplay');
const status = document.getElementById('status');
let animationFrame = null;
let currentText = '';

// ============ Animation Functions ============

function getRandomChar(charset) {
    const chars = [...charset];
    return chars[Math.floor(Math.random() * chars.length)] || '?';
}

// Obfuscate: Minecraft enchantment table scramble then reveal
function animateObfuscate(targetText, duration, onComplete) {
    const startTime = performance.now();
    const chars = [...targetText];
    
    function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const revealed = Math.floor(progress * chars.length);
        
        const result = chars.map((char, i) => {
            if (i < revealed) return char;
            if (char === ' ') return ' ';
            return getRandomChar(CHARS_ENCHANT);
        }).join('');
        
        display.textContent = result;
        
        if (progress < 1) {
            animationFrame = requestAnimationFrame(animate);
        } else {
            display.textContent = targetText;
            onComplete?.();
        }
    }
    
    animationFrame = requestAnimationFrame(animate);
}

// Typewriter: type out character by character
function animateTypewriter(targetText, duration, onComplete) {
    const startTime = performance.now();
    const chars = [...targetText];
    display.classList.add('typewriter');
    
    function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const show = Math.floor(progress * chars.length);
        
        display.textContent = chars.slice(0, show).join('');
        
        if (progress < 1) {
            animationFrame = requestAnimationFrame(animate);
        } else {
            display.textContent = targetText;
            display.classList.remove('typewriter');
            onComplete?.();
        }
    }
    
    animationFrame = requestAnimationFrame(animate);
}

// Glitch: random glitch characters that settle
function animateGlitch(targetText, duration, onComplete) {
    const startTime = performance.now();
    const chars = [...targetText];
    display.classList.add('glitch');
    
    function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const glitchChance = 1.0 - progress;
        
        const result = chars.map((char) => {
            if (char === ' ') return ' ';
            if (Math.random() < glitchChance * 0.7) {
                return getRandomChar(CHARS_GLITCH);
            }
            return char;
        }).join('');
        
        display.textContent = result;
        
        if (progress < 1) {
            animationFrame = requestAnimationFrame(animate);
        } else {
            display.textContent = targetText;
            display.classList.remove('glitch');
            onComplete?.();
        }
    }
    
    animationFrame = requestAnimationFrame(animate);
}

// Scramble: all random then snap to final
function animateScramble(targetText, duration, onComplete) {
    const startTime = performance.now();
    const chars = [...targetText];
    
    function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        if (progress >= 0.95) {
            display.textContent = targetText;
            onComplete?.();
            return;
        }
        
        const result = chars.map((char) => {
            if (char === ' ') return ' ';
            return getRandomChar(CHARS_ENCHANT);
        }).join('');
        
        display.textContent = result;
        animationFrame = requestAnimationFrame(animate);
    }
    
    animationFrame = requestAnimationFrame(animate);
}

// Wave: characters appear in a wave pattern
function animateWave(targetText, duration, onComplete) {
    const startTime = performance.now();
    const chars = [...targetText];
    const waveWidth = 3;
    
    function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const center = progress * (chars.length + waveWidth);
        
        const result = chars.map((char, i) => {
            const dist = Math.abs(i - center);
            if (dist < waveWidth && char !== ' ') {
                return getRandomChar(CHARS_ENCHANT);
            }
            if (i < center - waveWidth) {
                return char;
            }
            return ' ';
        }).join('');
        
        display.textContent = result;
        
        if (progress < 1) {
            animationFrame = requestAnimationFrame(animate);
        } else {
            display.textContent = targetText;
            onComplete?.();
        }
    }
    
    animationFrame = requestAnimationFrame(animate);
}

// Fade transition with CSS
function animateFade(targetText, duration, onComplete) {
    document.documentElement.style.setProperty('--transition-duration', `${duration / 2}ms`);
    display.classList.add('fade-out');
    
    setTimeout(() => {
        display.textContent = targetText;
        display.classList.remove('fade-out');
        display.classList.add('fade-in');
        
        setTimeout(() => {
            display.classList.remove('fade-in');
            onComplete?.();
        }, duration / 2);
    }, duration / 2);
}

// Slide transition with CSS
function animateSlide(targetText, duration, direction, onComplete) {
    document.documentElement.style.setProperty('--transition-duration', `${duration / 2}ms`);
    display.classList.add(`slide-out-${direction}`);
    
    setTimeout(() => {
        display.textContent = targetText;
        display.classList.remove(`slide-out-${direction}`);
        
        setTimeout(() => {
            onComplete?.();
        }, duration / 2);
    }, duration / 2);
}

// Pop animation
function animatePop(targetText, duration, onComplete) {
    document.documentElement.style.setProperty('--transition-duration', `${duration}ms`);
    display.classList.add('scale-out');
    
    setTimeout(() => {
        display.textContent = targetText;
        display.classList.remove('scale-out');
        display.classList.add('pop-in');
        
        setTimeout(() => {
            display.classList.remove('pop-in');
            onComplete?.();
        }, duration);
    }, 100);
}

// ============ Main Animation Controller ============

function showText(text, transition = 'none', duration = 500) {
    // Cancel any running animation
    if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
    }
    
    // Remove any lingering classes
    display.classList.remove('fade-out', 'fade-in', 'slide-out-left', 'slide-out-right', 
                              'slide-out-up', 'slide-out-down', 'scale-out', 'pop-in', 
                              'typewriter', 'glitch');
    
    currentText = text;
    
    switch (transition) {
        case 'obfuscate':
            animateObfuscate(text, duration, null);
            break;
        case 'typewriter':
            animateTypewriter(text, duration, null);
            break;
        case 'glitch':
            animateGlitch(text, duration, null);
            break;
        case 'scramble':
            animateScramble(text, duration, null);
            break;
        case 'wave':
            animateWave(text, duration, null);
            break;
        case 'fade':
            animateFade(text, duration, null);
            break;
        case 'slide_left':
            animateSlide(text, duration, 'left', null);
            break;
        case 'slide_right':
            animateSlide(text, duration, 'right', null);
            break;
        case 'slide_up':
            animateSlide(text, duration, 'up', null);
            break;
        case 'slide_down':
            animateSlide(text, duration, 'down', null);
            break;
        case 'pop':
            animatePop(text, duration, null);
            break;
        case 'none':
        default:
            display.textContent = text;
            break;
    }
}

// ============ Communication ============

// BroadcastChannel for same-origin communication
let channel = null;
try {
    channel = new BroadcastChannel('text_cycler_' + CONFIG_ID);
    channel.onmessage = (e) => handleMessage(e.data);
    updateStatus('BroadcastChannel connected');
} catch (err) {
    updateStatus('BroadcastChannel not supported, using localStorage');
}

// LocalStorage fallback for cross-origin or older browsers
window.addEventListener('storage', (e) => {
    if (e.key === 'text_cycler_msg_' + CONFIG_ID && e.newValue) {
        try {
            handleMessage(JSON.parse(e.newValue));
        } catch (err) {}
    }
});

// Polling for remote control panel (when BroadcastChannel/localStorage don't work)
// Remote control panel writes to OBS persistent data via WebSocket
// OBS dock forwards to localStorage, browser source polls localStorage
let lastPolledTimestamp = 0;
const POLL_INTERVAL = 100; // Poll every 100ms for responsive updates
setInterval(() => {
    try {
        const msgKey = 'text_cycler_msg_' + CONFIG_ID;
        const msgData = localStorage.getItem(msgKey);
        if (msgData) {
            const parsed = JSON.parse(msgData);
            // Check if this is a new message (has timestamp and it's newer)
            if (parsed.timestamp && parsed.timestamp > lastPolledTimestamp) {
                lastPolledTimestamp = parsed.timestamp;
                handleMessage(parsed.message || parsed);
            } else if (!parsed.timestamp) {
                // Legacy format without timestamp - only process if we haven't seen it
                const legacyKey = 'text_cycler_processed_' + CONFIG_ID + '_' + JSON.stringify(parsed);
                if (!sessionStorage.getItem(legacyKey)) {
                    sessionStorage.setItem(legacyKey, '1');
                    handleMessage(parsed);
                }
            }
        }
    } catch (err) {
        // Silently ignore parse errors
    }
}, POLL_INTERVAL);

function handleMessage(msg) {
    updateStatus(`Received: ${msg.type}`);
    
    switch (msg.type) {
        case 'show':
            showText(msg.text, msg.transition, msg.duration);
            break;
        case 'clear':
            display.textContent = '';
            break;
        case 'style':
            applyStyles(msg.styles);
            break;
        case 'ping':
            sendResponse({ type: 'pong', configId: CONFIG_ID });
            break;
    }
}

function sendResponse(data) {
    if (channel) {
        channel.postMessage(data);
    }
    localStorage.setItem('text_cycler_response_' + CONFIG_ID, JSON.stringify(data));
}

function applyStyles(styles) {
    const root = document.documentElement;
    const container = document.querySelector('.container');
    const displayEl = document.getElementById('textDisplay');
    
    // Color
    if (styles.color) root.style.setProperty('--text-color', styles.color);
    
    // Font
    if (styles.fontFamily || styles.font) root.style.setProperty('--font-family', styles.fontFamily || styles.font);
    if (styles.fontSize || styles.size) root.style.setProperty('--font-size', styles.fontSize || styles.size);
    if (styles.fontWeight || styles.weight) root.style.setProperty('--font-weight', styles.fontWeight || styles.weight);
    if (styles.fontStyle) displayEl.style.fontStyle = styles.fontStyle;
    
    // Text layout
    if (styles.align) container.style.textAlign = styles.align;
    if (styles.letterSpacing && styles.letterSpacing !== 'normal') {
        displayEl.style.letterSpacing = styles.letterSpacing;
    } else {
        displayEl.style.letterSpacing = '';
    }
    if (styles.lineHeight) displayEl.style.lineHeight = styles.lineHeight;
    if (styles.textTransform && styles.textTransform !== 'none') {
        displayEl.style.textTransform = styles.textTransform;
    } else {
        displayEl.style.textTransform = '';
    }
    
    // Effects
    if (styles.shadow) root.style.setProperty('--text-shadow', styles.shadow);
    
    // Stroke/Outline
    if (styles.strokeWidth && styles.strokeWidth !== '0' && styles.strokeWidth !== '0px') {
        const strokeColor = styles.strokeColor || '#000000';
        displayEl.style.webkitTextStroke = `${styles.strokeWidth} ${strokeColor}`;
        displayEl.style.textStroke = `${styles.strokeWidth} ${strokeColor}`;
    } else {
        displayEl.style.webkitTextStroke = '';
        displayEl.style.textStroke = '';
    }
}

function updateStatus(msg) {
    status.textContent = `[${CONFIG_ID}] ${msg}`;
    if (DEBUG) console.log(`[TextCyclerDisplay:${CONFIG_ID}]`, msg);
}

// ============ Initialization ============

// Check for initial state in localStorage
try {
    const savedState = localStorage.getItem('text_cycler_state_' + CONFIG_ID);
    if (savedState) {
        const state = JSON.parse(savedState);
        if (state.text) {
            display.textContent = state.text;
            currentText = state.text;
        }
        if (state.styles) {
            applyStyles(state.styles);
        }
    }
} catch (err) {}

updateStatus('Display ready');

// Announce presence
sendResponse({ type: 'ready', configId: CONFIG_ID });
</script>
</body>
</html>

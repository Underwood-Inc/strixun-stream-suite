<!-- Security Documentation Section -->
<div class="card security-docs">
    <div class="collapsible-header" role="button" tabindex="0" aria-expanded="true" aria-controls="securityContent" onclick="toggleSecurityDocs()" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();toggleSecurityDocs()}">
        <h2>‚ö†Ô∏è Security & Integration Guide</h2>
        <span class="toggle-icon" id="toggleIcon" aria-hidden="true">‚ñº</span>
    </div>
    <div class="collapsible-content expanded" id="securityContent" role="region" aria-label="Security and integration documentation">
        <p style="margin: 1rem 0; color: var(--text-muted); font-size: 0.875rem;">
            <strong>IMPORTANT:</strong> Read this before integrating into your production application.
        </p>
        
        <!-- API Key Purpose -->
        <h3 id="sec-api-key">üîë What This API Key Does vs. Doesn't Do</h3>
        <table class="security-table">
            <thead>
                <tr>
                    <th>Purpose</th>
                    <th>API Key</th>
                    <th>JWT Token</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Identifies Tenant/Customer</td>
                    <td><span class="badge badge-success">‚úì Yes</span></td>
                    <td><span class="badge badge-warning">Inherits</span></td>
                </tr>
                <tr>
                    <td>Per-key origin restrictions (optional)</td>
                    <td><span class="badge badge-success">‚úì Yes</span></td>
                    <td>‚Äî</td>
                </tr>
                <tr>
                    <td>Applies rate limits</td>
                    <td><span class="badge badge-success">‚úì Yes</span></td>
                    <td>‚Äî</td>
                </tr>
                <tr>
                    <td>Authenticates the USER</td>
                    <td><span class="badge badge-danger">‚úó No</span></td>
                    <td><span class="badge badge-success">‚úì Yes</span></td>
                </tr>
                <tr>
                    <td>Grants data access</td>
                    <td><span class="badge badge-danger">‚úó No</span></td>
                    <td><span class="badge badge-success">‚úì Yes</span></td>
                </tr>
                <tr>
                    <td>Should be kept secret</td>
                    <td><span class="badge badge-warning">Depends*</span></td>
                    <td><span class="badge badge-success">‚úì Always</span></td>
                </tr>
            </tbody>
        </table>
        <p style="font-size: 0.75rem; color: var(--text-muted);">
            * Backend = keep secret. Frontend = visible (optionally restrict via per-key origins).
        </p>
        
        <!-- Security Model -->
        <div style="background: var(--bg-light); border: 2px solid var(--accent); border-radius: 8px; padding: 1rem; margin: 1.5rem 0;">
            <h3 id="sec-security-model" style="margin: 0 0 0.75rem 0; color: var(--accent);">üîê Security Model - How It Actually Works</h3>
            
            <p style="font-size: 0.9rem; margin-bottom: 1rem; font-weight: bold;">
                The API key itself IS the security. No valid key = no access. Period.
            </p>
            
            <table class="security-table" style="margin-bottom: 1rem;">
                <thead>
                    <tr>
                        <th>Scenario</th>
                        <th>What Happens</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>No API key provided</strong></td>
                        <td><span class="badge badge-danger">401 Unauthorized</span> ‚Äî Nothing happens</td>
                    </tr>
                    <tr>
                        <td><strong>Invalid/revoked API key</strong></td>
                        <td><span class="badge badge-danger">401 Unauthorized</span> ‚Äî Nothing happens</td>
                    </tr>
                    <tr>
                        <td><strong>Valid key, NO origins configured</strong></td>
                        <td><span class="badge badge-success">‚úì Works</span> ‚Äî Key authenticates, any origin allowed</td>
                    </tr>
                    <tr>
                        <td><strong>Valid key, origins configured</strong></td>
                        <td><span class="badge badge-success">‚úì Works</span> ‚Äî Only from those specific origins</td>
                    </tr>
                </tbody>
            </table>
            
            <div style="background: var(--bg); padding: 0.75rem; border-radius: 4px; font-size: 0.85rem;">
                <p style="margin: 0 0 0.5rem 0;"><strong>Think of it like a password:</strong></p>
                <ul style="margin: 0; padding-left: 1.25rem;">
                    <li><strong>Backend keys:</strong> Stored in env vars, never exposed. Works from "any origin" because it's only used from YOUR server.</li>
                    <li><strong>Frontend keys:</strong> Visible in browser JS. Configure origins to prevent someone from copying it and using it elsewhere.</li>
                </ul>
                <p style="margin: 0.75rem 0 0 0; color: var(--warning);">
                    <strong>‚ö†Ô∏è "Any origin" doesn't mean "anyone can access"</strong> ‚Äî it means "anyone WITH THE VALID KEY can access from any origin."
                </p>
            </div>
        </div>

        <!-- ========================================================= -->
        <!-- OIDC Architecture (foundational ‚Äî applies to ALL methods)  -->
        <!-- ========================================================= -->
        <h3 id="sec-oidc-arch">üåê OIDC Architecture (All Integrations Use This)</h3>
        <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 1rem;">
            Every token issued by this service ‚Äî regardless of whether you use a backend proxy or a direct
            frontend call ‚Äî is an <strong>RS256-signed OIDC-compliant JWT</strong>. There is no alternative
            signing mechanism. The flow below shows the complete lifecycle.
        </p>

        <div class="mermaid-container">
            <div class="diagram-title">Full Authentication + Token Lifecycle</div>
            <div class="mermaid">
sequenceDiagram
    participant B as Browser/App
    participant A as Auth Service
    participant S as Resource Server

    B->>A: POST /auth/verify-otp
    Note over B,A: email + OTP code
    A-->>B: access_token + id_token + refresh_token
    Note over A: Sets auth_token cookie (15 min)
    Note over A: Sets refresh_token cookie (7 day max)

    B->>S: Request with auth_token cookie
    S->>A: GET /.well-known/jwks.json
    Note over S: Cached for 10 minutes
    S->>S: Verify RS256 signature
    S->>S: Extract sub (customerId)
    S-->>B: Protected resource returned

    Note over B: Access token expires (15 min)
    B->>A: POST /auth/refresh
    Note over B,A: refresh_token cookie
    A->>A: Rotate refresh token
    A-->>B: New access + refresh tokens
    Note over A: Max 7 days from original login
            </div>
        </div>

        <!-- ===== OIDC Infrastructure Endpoints ===== -->
        <h3 id="sec-oidc-endpoints" style="margin-top: 1.5rem;">üèóÔ∏è OIDC Infrastructure ‚Äî What Each Endpoint Does &amp; Why</h3>
        <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 1rem;">
            OIDC (OpenID Connect) is an industry-standard identity protocol built on top of OAuth 2.0.
            It defines a set of well-known endpoints that let any application ‚Äî yours or third-party ‚Äî
            verify identities without sharing passwords or secrets. Below is every endpoint this service
            exposes, explained in plain language.
        </p>

        <!-- Discovery -->
        <div class="method-box recommended" style="margin-bottom: 1rem;">
            <h4 id="ep-discovery">üìñ Discovery ‚Äî <code>GET /.well-known/openid-configuration</code></h4>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>What it is:</strong> A single JSON document that acts as a "phone book" for the entire
                authentication system. Any application that wants to integrate with this auth service can
                fetch this one URL and learn <em>everything</em> it needs ‚Äî where to send login requests,
                where to find public keys, what signing algorithms are used, what token types are supported, etc.
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>Why it matters:</strong> Without Discovery, every developer would need to manually
                hard-code endpoint URLs. With it, your app can auto-configure itself by reading this one document.
                Many OAuth/OIDC libraries (like <code>openid-client</code> in Node.js or Spring Security in Java)
                will accept <em>just</em> the Discovery URL and handle everything else automatically.
            </p>
            <p style="font-size: 0.8rem; color: var(--text-secondary);">
                <strong>Try it:</strong> Visit <code>{{BASE_URL}}/.well-known/openid-configuration</code> in
                your browser ‚Äî you'll see a JSON response listing every supported endpoint and capability.
            </p>
        </div>

        <!-- JWKS -->
        <div class="method-box recommended" style="margin-bottom: 1rem;">
            <h4 id="ep-jwks">üîë JSON Web Key Set (JWKS) ‚Äî <code>GET /.well-known/jwks.json</code></h4>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>What it is:</strong> A list of the <em>public</em> cryptographic keys that this service
                uses to sign every token it issues. Think of it like a public notary stamp ‚Äî anyone can look at
                the stamp (public key) to verify a document is authentic, but only the notary (our server) holds
                the private key that creates the stamp.
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>Why it matters:</strong> When your backend server receives a token (JWT) from a user,
                it needs to verify that the token was genuinely issued by this auth service and hasn't been
                tampered with. It does this by fetching the public keys from JWKS, matching the key ID
                (<code>kid</code>) in the token header, and verifying the RS256 digital signature.
                This process is completely offline after the initial key fetch (keys are cached for 10 minutes).
            </p>
            <p style="font-size: 0.8rem; color: var(--text-secondary);">
                <strong>Usage:</strong> Most JWT libraries handle this automatically ‚Äî you point them at
                the JWKS URL and they fetch, cache, and rotate keys for you. You never need to manually
                download or manage these keys.
            </p>
        </div>

        <!-- Request OTP Endpoint -->
        <div class="method-box recommended" style="margin-bottom: 1rem;">
            <h4 id="ep-request-otp">üìß Request OTP ‚Äî <code>POST /auth/request-otp</code></h4>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>What it is:</strong> The first step of the login flow. You send the user's email address
                to this endpoint, and the auth service sends a 9-digit one-time password to that email. The OTP
                is valid for <strong>10 minutes</strong>.
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>Required headers:</strong> <code>Content-Type: application/json</code> and
                <code>X-OTP-API-Key: &lt;your_api_key&gt;</code>.
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>Request body:</strong> <code>{ "email": "user@example.com" }</code>
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted);">
                <strong>Success response (200):</strong>
                <code>{ "success": true, "message": "OTP sent to email", "expiresIn": 600, "remaining": 4 }</code>
                ‚Äî <code>expiresIn</code> is the OTP validity in seconds (600 = 10 minutes),
                <code>remaining</code> is how many more OTP requests are allowed before rate limiting kicks in.
                One OTP request per 30 minutes is allowed without counting when that email had a successful login or refresh recently (recovery pass).
            </p>
        </div>

        <!-- Token Endpoint -->
        <div class="method-box recommended" style="margin-bottom: 1rem;">
            <h4 id="ep-verify-otp">üé´ Token Endpoint (Verify OTP) ‚Äî <code>POST /auth/verify-otp</code></h4>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>What it is:</strong> The second step of the login flow. After the user receives their
                9-digit OTP code via email, your app submits it here. If the code is correct, the service
                issues a full set of tokens: an <strong>access token</strong> (proves who the user is for 15 minutes),
                an <strong>ID token</strong> (contains identity claims like customer ID), and a
                <strong>refresh token</strong> (allows getting new tokens without re-entering an OTP).
                It also sets <code>auth_token</code> and <code>refresh_token</code> as HttpOnly cookies.
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>Required headers:</strong> <code>Content-Type: application/json</code> and
                <code>X-OTP-API-Key: &lt;your_api_key&gt;</code>.
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>Request body:</strong> <code>{ "email": "user@example.com", "otp": "123456789" }</code>
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted);">
                <strong>Why it matters:</strong> This replaces traditional username/password login. Instead of
                storing and managing passwords, the user proves their identity by accessing their email ‚Äî
                a much simpler and often more secure flow.
            </p>
        </div>

        <!-- Refresh -->
        <div class="method-box recommended" style="margin-bottom: 1rem;">
            <h4 id="ep-refresh">üîÑ Token Refresh ‚Äî <code>POST /auth/refresh</code></h4>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>What it is:</strong> When an access token expires (every 15 minutes), this endpoint
                lets the app silently get a new one without forcing the user to re-enter an OTP code. The
                app sends its refresh token (stored as an HttpOnly cookie), and receives a fresh access token
                plus a <strong>new</strong> refresh token (the old one is immediately invalidated ‚Äî this is
                called <em>token rotation</em> and prevents stolen refresh tokens from being reused).
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>How the user experiences it:</strong> There is <strong>no background polling or
                heartbeat</strong>. Refresh only happens when the user performs an action after their
                15-minute access token has expired. If the user walks away from their computer, zero
                network requests are made. When they return and click something, the app automatically
                detects the expired token, refreshes it behind the scenes, and retries the action.
                This "reactive refresh" pattern continues for up to <strong>7 days</strong> from the original
                login, after which the user must enter a new OTP.
                <strong>POST /auth/refresh</strong> is not rate-limited. If refresh fails and the user requests an OTP again, one request is allowed without counting when they had a recent successful login or refresh (recovery pass).
            </p>
        </div>

        <!-- UserInfo -->
        <div class="method-box recommended" style="margin-bottom: 1rem;">
            <h4 id="ep-userinfo">üë§ User Info ‚Äî <code>GET /auth/me</code></h4>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>What it is:</strong> Returns profile information about the currently logged-in user
                based on the scopes granted during authentication. Uses the HttpOnly cookie automatically
                ‚Äî no manual token passing required.
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted);">
                <strong>Why it matters:</strong> Your frontend can call this to display the user's name or
                preferred username without needing to decode the JWT yourself. The response only includes
                claims allowed by the scopes that were originally requested.
            </p>
        </div>

        <!-- Introspection -->
        <div class="method-box recommended" style="margin-bottom: 1rem;">
            <h4 id="ep-introspect">üîç Token Introspection ‚Äî <code>POST /auth/introspect</code></h4>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>What it is:</strong> A way for your server to ask "is this token still valid?" by
                sending a token to this endpoint and getting back a definitive yes/no answer along with
                the token's claims (who it belongs to, when it expires, etc.). This follows the
                <strong>RFC 7662</strong> standard.
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                <strong>When to use it:</strong> Most of the time you don't need this ‚Äî verifying the JWT
                signature locally using JWKS is faster and doesn't require a network call. Introspection is
                useful when you need to check if a token has been <em>explicitly revoked</em> (e.g., the user
                logged out) or when you want a single source of truth from the auth server itself.
            </p>
            <p style="font-size: 0.8rem; color: var(--text-secondary);">
                <strong>Security:</strong> This endpoint requires a valid API key via the
                <code>X-OTP-API-Key</code> header to prevent unauthorized token scanning.
            </p>
        </div>

        <!-- Logout -->
        <div class="method-box recommended" style="margin-bottom: 1rem;">
            <h4 id="ep-logout">üö™ Logout ‚Äî <code>POST /auth/logout</code></h4>
            <p style="font-size: 0.8rem; color: var(--text-muted);">
                <strong>What it is:</strong> Ends the user's session completely. It revokes the access and
                refresh tokens on the server side (so they can never be reused even if intercepted),
                deletes the session data from server storage, and clears the HttpOnly cookies from the
                browser. After calling this, the user must authenticate again with a new OTP.
            </p>
        </div>

        <!-- ===== How Authentication Works (Grant Type) ===== -->
        <h3 id="sec-grant-type" style="margin-top: 1.5rem;">‚öôÔ∏è How Authentication Works (Grant Type)</h3>
        <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.75rem;">
            Most OIDC providers use a flow where the user is redirected to a login page and back (called the
            "authorization code" flow). This service uses a different approach ‚Äî a <strong>custom OTP grant type</strong>
            (<code>urn:ietf:params:oauth:grant-type:otp</code>) ‚Äî where the user receives a 9-digit one-time
            password via email and submits it directly. No browser redirects, no third-party login pages.
            There is also a standard <code>refresh_token</code> grant type for silently renewing expired tokens.
        </p>
        <p style="font-size: 0.8rem; color: var(--text-muted);">
            The response from a successful OTP verification is fully OIDC-compliant and includes:
            <code>access_token</code> (RS256 JWT, 15 min), <code>id_token</code> (identity claims),
            <code>refresh_token</code> (opaque, single-use, 7-day max), <code>token_type</code>,
            <code>expires_in</code>, <code>refresh_expires_in</code>, and <code>scope</code>.
        </p>

        <!-- ===== Token Lifetimes ===== -->
        <h3 id="sec-token-lifetimes" style="margin-top: 1.5rem;">‚è±Ô∏è Token Lifetimes</h3>
        <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.75rem;">
            Each token type has a specific lifespan. Short-lived access tokens limit the damage window if a
            token is ever intercepted. The refresh token allows seamless re-authentication up to a hard limit.
        </p>
        <table class="security-table" style="font-size: 0.85rem;">
            <thead><tr><th>Token</th><th>Lifetime</th><th>How It's Delivered</th></tr></thead>
            <tbody>
                <tr id="token-access">
                    <td><strong>Access token</strong> (RS256 JWT)</td>
                    <td>15 minutes</td>
                    <td>JSON response body + <code>auth_token</code> HttpOnly cookie</td>
                </tr>
                <tr id="token-id">
                    <td><strong>ID token</strong> (RS256 JWT)</td>
                    <td>15 minutes (same as access)</td>
                    <td>JSON response body only (not stored in cookies)</td>
                </tr>
                <tr id="token-refresh">
                    <td><strong>Refresh token</strong> (opaque string)</td>
                    <td>7-day absolute max from original login</td>
                    <td>JSON response body + <code>refresh_token</code> HttpOnly cookie</td>
                </tr>
            </tbody>
        </table>

        <!-- ===== ID Token Claims ===== -->
        <h3 id="sec-claims" style="margin-top: 1.5rem;">üìã What's Inside an ID Token (Claims)</h3>
        <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.75rem;">
            A "claim" is a piece of information embedded in the token. When your server verifies a token,
            it can read these claims to learn who the user is and whether the token is still valid ‚Äî
            all without making any additional API calls.
        </p>
        <table class="security-table" style="font-size: 0.85rem;">
            <thead><tr><th>Claim</th><th>Full Name</th><th>What It Tells You</th></tr></thead>
            <tbody>
                <tr id="claim-iss"><td><code>iss</code></td><td>Issuer</td><td>The URL of this auth service. Your server should verify this matches exactly ‚Äî it proves the token came from the right place.</td></tr>
                <tr id="claim-sub"><td><code>sub</code></td><td>Subject</td><td>The unique customer ID. This is <strong>the</strong> identifier you use to look up the user in your own systems.</td></tr>
                <tr id="claim-aud"><td><code>aud</code></td><td>Audience</td><td>Your API key ID. Confirms this token was issued <em>for your application</em> specifically, not a different tenant.</td></tr>
                <tr id="claim-exp"><td><code>exp</code></td><td>Expiration</td><td>Unix timestamp when the token stops being valid. Always check this ‚Äî reject expired tokens.</td></tr>
                <tr id="claim-iat"><td><code>iat</code></td><td>Issued At</td><td>Unix timestamp when the token was created. Useful for calculating token age.</td></tr>
                <tr id="claim-at-hash"><td><code>at_hash</code></td><td>Access Token Hash</td><td>A cryptographic fingerprint of the access token. Lets you verify that the ID token and access token were issued together as a pair.</td></tr>
                <tr id="claim-email-verified"><td><code>email_verified</code></td><td>Email Verified</td><td>Always <code>true</code> ‚Äî confirms the user proved ownership of their email via OTP. The actual email address is <strong>never</strong> included (see Privacy Model below).</td></tr>
            </tbody>
        </table>

        <!-- ===== Scopes ===== -->
        <h3 id="sec-scopes" style="margin-top: 1.5rem;">üéØ Scopes ‚Äî Controlling What Information You Receive</h3>
        <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.75rem;">
            Scopes act as permissions that control which claims are included in the tokens and what the
            <code>/auth/me</code> endpoint returns. You request scopes during authentication, and the
            service only returns the claims those scopes allow.
        </p>
        <table class="security-table" style="font-size: 0.85rem;">
            <thead><tr><th>Scope</th><th>What It Unlocks</th></tr></thead>
            <tbody>
                <tr id="scope-openid"><td><code>openid</code></td><td>Core identity claims: <code>sub</code> (customer ID), <code>iss</code>, <code>aud</code>, <code>exp</code>, <code>iat</code>, <code>at_hash</code>, <code>email_verified</code></td></tr>
                <tr id="scope-profile"><td><code>profile</code></td><td>Display name and preferred username: <code>name</code>, <code>preferred_username</code></td></tr>
            </tbody>
        </table>
        <p style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.75rem;">
            <strong>How to request scopes:</strong> Currently, <code>openid profile</code> is automatically
            granted on every successful OTP verification ‚Äî you don't need to pass a <code>scope</code>
            parameter. All tokens include both sets of claims by default. If additional scopes are added
            in the future, you will be able to request specific scopes by including a <code>scope</code>
            field in the <code>verify-otp</code> request body (e.g., <code>{ "email": "...", "otp": "...", "scope": "openid" }</code>).
        </p>

        <!-- ===== Privacy Model ===== -->
        <h3 id="sec-privacy" style="margin-top: 1.5rem;">üîí Privacy Model ‚Äî How We Protect User Data</h3>
        <p style="font-size: 0.8rem; color: var(--text-muted);">
            Email addresses are <strong>never</strong> included in JWT payloads, token responses, or any API response.
            The <code>customerId</code> (the <code>sub</code> claim in tokens) is the sole external identifier
            used to represent a user across all services. Only <code>email_verified: true</code> is included
            to confirm that the user proved ownership of their email via OTP. The actual email address exists
            only in encrypted server-side storage, used exclusively for delivering OTP codes and maintaining
            session records ‚Äî it is never transmitted to your application or any third party.
        </p>

        <!-- ===== Error Responses ===== -->
        <h3 id="sec-errors" style="margin-top: 1.5rem;">‚ùå Error Responses ‚Äî What to Expect When Things Go Wrong</h3>
        <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.75rem;">
            All error responses follow the <strong>RFC 7807 Problem Details</strong> format ‚Äî a standard
            JSON structure that makes errors machine-readable and human-understandable. Your error-handling
            code can always rely on the same shape:
        </p>
        <div class="code-example" style="margin-bottom: 0.75rem;"><span class="comment">// Every error response has this shape (Content-Type: application/problem+json)</span>
{
    <span class="string">"type"</span>:     <span class="string">"https://tools.ietf.org/html/rfc7231#section-6.5.1"</span>,  <span class="comment">// RFC reference</span>
    <span class="string">"title"</span>:    <span class="string">"Bad Request"</span>,                                      <span class="comment">// Human-readable category</span>
    <span class="string">"status"</span>:   400,                                                  <span class="comment">// HTTP status code</span>
    <span class="string">"detail"</span>:   <span class="string">"Valid email address required"</span>,                       <span class="comment">// Specific error message</span>
    <span class="string">"instance"</span>: <span class="string">"https://auth.idling.app/auth/request-otp"</span>            <span class="comment">// URL that was called</span>
}</div>
        <table class="security-table" style="font-size: 0.85rem;">
            <thead><tr><th>Status Code</th><th>When It Happens</th><th>The <code>detail</code> Field Tells You</th></tr></thead>
            <tbody>
                <tr id="error-400">
                    <td><span class="badge badge-warning">400</span></td>
                    <td>Invalid email format, missing OTP, malformed request body</td>
                    <td>Exactly what's wrong with the input (e.g., <code>"Valid 9-digit OTP required"</code>)</td>
                </tr>
                <tr id="error-401">
                    <td><span class="badge badge-danger">401</span></td>
                    <td>Wrong OTP code, no API key, invalid API key, expired token</td>
                    <td>Why authentication failed. For OTP errors, also includes <code>remaining_attempts</code></td>
                </tr>
                <tr id="error-403">
                    <td><span class="badge badge-danger">403</span></td>
                    <td>Valid API key but request origin not in the allowed list</td>
                    <td>Origin restriction violated</td>
                </tr>
                <tr id="error-429">
                    <td><span class="badge badge-warning">429</span></td>
                    <td>Too many OTP requests or too many failed verification attempts</td>
                    <td>Rate limit or quota exceeded. Includes <code>retry_after</code> (seconds) and <code>remaining</code> count. One OTP request per 30 min is allowed without counting when the email had a recent successful login/refresh (recovery pass).</td>
                </tr>
                <tr id="error-500">
                    <td><span class="badge badge-danger">500</span></td>
                    <td>Server-side failure (email delivery, database, etc.)</td>
                    <td>Generic message ‚Äî retry the request or contact support</td>
                </tr>
            </tbody>
        </table>
        <p style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem;">
            <strong>Tip:</strong> Always read the <code>detail</code> field for the specific message, and
            check for <code>remaining_attempts</code> on 401s (OTP failures) and <code>retry_after</code>
            on 429s (rate limits) to give your users actionable feedback.
        </p>

        <!-- ========================================================= -->
        <!-- Integration Methods (HOW the developer calls the service)  -->
        <!-- ========================================================= -->
        <h3 id="sec-integration">üõ°Ô∏è Integration Methods</h3>
        <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 1rem;">
            Both methods produce the same OIDC tokens. The difference is where the API key lives
            and whether your server proxies the calls.
        </p>
        
        <div class="tabs" role="tablist" aria-label="Integration method">
            <button class="tab-btn active" role="tab" aria-selected="true" aria-controls="tab-backend" id="tabBtn-backend" onclick="showTab('backend',this)">‚úÖ Backend Proxy (Recommended)</button>
            <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-frontend" id="tabBtn-frontend" onclick="showTab('frontend',this)">‚ö° Direct Frontend</button>
        </div>
        
        <!-- Backend Tab -->
        <div id="tab-backend" class="tab-content active" role="tabpanel" aria-labelledby="tabBtn-backend">
            <div class="method-box recommended">
                <h4>‚úÖ Method 1: Backend Proxy</h4>
                <p style="font-size: 0.8rem; color: var(--success); margin-bottom: 0.5rem;">
                    <strong>HIGHEST SECURITY</strong> ‚Äî API key never reaches the browser
                </p>
            </div>
            
            <div class="mermaid-container">
                <div class="diagram-title">Backend Integration Flow</div>
                <div class="mermaid">
sequenceDiagram
    participant B as Browser
    participant Y as Your Server
    participant O as OTP Auth API

    Note over Y: API key in env vars (secret)

    B->>Y: Request OTP
    Y->>O: POST /auth/request-otp
    Note over Y,O: X-OTP-API-Key header
    O-->>Y: OTP sent to user email
    Y-->>B: Success

    B->>Y: Submit OTP code
    Y->>O: POST /auth/verify-otp
    Note over Y,O: X-OTP-API-Key header
    O-->>Y: RS256 JWT (access + id + refresh)
    Y-->>B: Sets HttpOnly cookie
                </div>
            </div>
            
            <div class="code-example"><span class="comment">// YOUR BACKEND SERVER (Node.js / Express example)</span>
<span class="keyword">const</span> OTP_API_KEY = process.env.OTP_AUTH_API_KEY; <span class="comment">// Secret ‚Äî never expose to browser</span>
<span class="keyword">const</span> AUTH_BASE  = <span class="string">'{{BASE_URL}}'</span>;

<span class="comment">// Step 1: User submits their email ‚Üí send OTP</span>
app.post(<span class="string">'/api/auth/request-otp'</span>, <span class="keyword">async</span> (req, res) => {
    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="function">fetch</span>(`${AUTH_BASE}/auth/request-otp`, {
        method: <span class="string">'POST'</span>,
        headers: {
            <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,
            <span class="string">'X-OTP-API-Key'</span>: OTP_API_KEY
        },
        body: JSON.stringify({ email: req.body.email })
    });
    <span class="comment">// ‚Üí { success: true, message: "OTP sent to email", expiresIn: 600, remaining: 4 }</span>
    res.status(response.status).json(<span class="keyword">await</span> response.json());
});

<span class="comment">// Step 2: User enters the 9-digit OTP code ‚Üí exchange for tokens</span>
app.post(<span class="string">'/api/auth/verify-otp'</span>, <span class="keyword">async</span> (req, res) => {
    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="function">fetch</span>(`${AUTH_BASE}/auth/verify-otp`, {
        method: <span class="string">'POST'</span>,
        headers: {
            <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,
            <span class="string">'X-OTP-API-Key'</span>: OTP_API_KEY
        },
        body: JSON.stringify({ email: req.body.email, otp: req.body.otp })
    });

    <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();
    <span class="keyword">if</span> (!response.ok) <span class="keyword">return</span> res.status(response.status).json(data);

    <span class="comment">// The auth service also sets HttpOnly cookies on its domain.</span>
    <span class="comment">// For YOUR domain, forward the auth_token as an HttpOnly cookie:</span>
    res.cookie(<span class="string">'auth_token'</span>, data.access_token, {
        httpOnly: <span class="keyword">true</span>,
        secure: process.env.NODE_ENV === <span class="string">'production'</span>,
        sameSite: <span class="string">'lax'</span>,
        maxAge: data.expires_in * 1000,       <span class="comment">// 15 min in ms</span>
    });
    res.cookie(<span class="string">'refresh_token'</span>, data.refresh_token, {
        httpOnly: <span class="keyword">true</span>,
        secure: process.env.NODE_ENV === <span class="string">'production'</span>,
        sameSite: <span class="string">'lax'</span>,
        maxAge: data.refresh_expires_in * 1000, <span class="comment">// up to 7 days in ms</span>
    });

    <span class="comment">// Return only safe, non-secret data to the browser</span>
    res.json({
        displayName: data.displayName,
        customerId: data.sub,
        expiresIn: data.expires_in,
    });
});</div>

            <p style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.75rem;">
                <strong>Successful verify-otp response shape:</strong>
            </p>
            <div class="code-example" style="margin-top: 0.5rem;"><span class="comment">// 200 OK ‚Äî Content-Type: application/json</span>
<span class="comment">// Also sets auth_token + refresh_token as HttpOnly cookies on the auth domain</span>
{
    <span class="string">"access_token"</span>: <span class="string">"eyJhbGciOiJSUzI1NiIs..."</span>,  <span class="comment">// RS256 JWT (15 min)</span>
    <span class="string">"id_token"</span>:     <span class="string">"eyJhbGciOiJSUzI1NiIs..."</span>,  <span class="comment">// RS256 JWT (identity claims)</span>
    <span class="string">"refresh_token"</span>: <span class="string">"opaque_random_string"</span>,       <span class="comment">// Single-use, 7-day max</span>
    <span class="string">"token_type"</span>:    <span class="string">"Bearer"</span>,
    <span class="string">"expires_in"</span>:    900,                            <span class="comment">// Seconds until access_token expires</span>
    <span class="string">"refresh_expires_in"</span>: 604800,                    <span class="comment">// Seconds until refresh token expires</span>
    <span class="string">"scope"</span>:         <span class="string">"openid profile"</span>,
    <span class="string">"displayName"</span>:   <span class="string">"username"</span>,                    <span class="comment">// User's display name</span>
    <span class="string">"sub"</span>:           <span class="string">"cust_abc123"</span>                   <span class="comment">// customerId ‚Äî your primary user ID</span>
}</div>
            
            <p style="font-size: 0.85rem; margin-top: 1rem; color: var(--text-secondary);">
                <strong>Verifying tokens in your resource server</strong> ‚Äî use the
                <a href="https://github.com/panva/jose" target="_blank" rel="noopener noreferrer" style="color: var(--accent);">jose</a>
                library (works in Node.js, Deno, Bun, Cloudflare Workers, and browsers):
            </p>
            <div class="code-example" style="margin-top: 0.5rem;"><span class="comment">// npm install jose</span>
<span class="keyword">import</span> { createRemoteJWKSet, jwtVerify } <span class="keyword">from</span> <span class="string">'jose'</span>;

<span class="comment">// Create a JWKS fetcher (caches keys automatically)</span>
<span class="keyword">const</span> JWKS = <span class="function">createRemoteJWKSet</span>(
    <span class="keyword">new</span> <span class="function">URL</span>(<span class="string">'{{BASE_URL}}/.well-known/jwks.json'</span>)
);

<span class="comment">// In your route handler / middleware:</span>
<span class="keyword">async function</span> <span class="function">verifyAccessToken</span>(token) {
    <span class="keyword">const</span> { payload } = <span class="keyword">await</span> <span class="function">jwtVerify</span>(token, JWKS, {
        issuer: <span class="string">'{{BASE_URL}}'</span>,    <span class="comment">// must match the iss claim exactly</span>
        audience: OTP_API_KEY,           <span class="comment">// your API key ID (the aud claim)</span>
    });

    <span class="comment">// payload.sub = customerId (use this to identify the user)</span>
    <span class="comment">// payload.exp = expiration (already verified by jwtVerify)</span>
    <span class="comment">// payload.email_verified = true (user proved email ownership)</span>
    <span class="keyword">return</span> payload;
}

<span class="comment">// Example: Express.js middleware</span>
app.use(<span class="keyword">async</span> (req, res, next) => {
    <span class="keyword">const</span> token = req.cookies.auth_token
        || req.headers.authorization?.replace(<span class="string">'Bearer '</span>, <span class="string">''</span>);

    <span class="keyword">if</span> (!token) <span class="keyword">return</span> res.status(401).json({ error: <span class="string">'No token'</span> });

    <span class="keyword">try</span> {
        req.user = <span class="keyword">await</span> <span class="function">verifyAccessToken</span>(token);
        <span class="function">next</span>();
    } <span class="keyword">catch</span> (err) {
        res.status(401).json({ error: <span class="string">'Invalid or expired token'</span> });
    }
});</div>
            <p style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">
                <strong>Other languages:</strong>
                Python ‚Üí <code>PyJWKClient</code> from <code>PyJWT</code> &nbsp;|&nbsp;
                Go ‚Üí <code>go-jose/v4</code> &nbsp;|&nbsp;
                Java ‚Üí <code>nimbus-jose-jwt</code> &nbsp;|&nbsp;
                .NET ‚Üí <code>Microsoft.IdentityModel.Tokens</code>
                ‚Äî all support JWKS auto-discovery from the <code>/.well-known/jwks.json</code> URL.
            </p>
        </div>
        
        <!-- Frontend Tab -->
        <div id="tab-frontend" class="tab-content" role="tabpanel" aria-labelledby="tabBtn-frontend">
            <div class="method-box alternative">
                <h4>‚ö° Method 2: Direct Frontend</h4>
                <p style="font-size: 0.8rem; color: var(--warning); margin-bottom: 0.5rem;">
                    <strong>MODERATE SECURITY</strong> ‚Äî API key visible (optionally add origin restrictions)
                </p>
            </div>
            
            <div class="mermaid-container">
                <div class="diagram-title">Direct Frontend Flow</div>
                <div class="mermaid">
sequenceDiagram
    participant B as Browser
    participant O as OTP Auth API
    participant H as Attacker

    Note over B,O: Key visible in JS bundle
    Note over B,O: Configure origins to restrict

    B->>O: POST /auth/request-otp
    Note over B,O: X-OTP-API-Key in header
    O-->>B: OTP sent to email

    H->>O: Same key, wrong origin
    O-->>H: 403 Forbidden
                </div>
            </div>
            
            <div class="code-example"><span class="comment">// YOUR FRONTEND (React / Vue / Vanilla JS)</span>
<span class="keyword">const</span> OTP_API_KEY = <span class="string">'otp_live_sk_xxx'</span>; <span class="comment">// Visible ‚Äî restrict with per-key origins</span>
<span class="keyword">const</span> AUTH_BASE  = <span class="string">'{{BASE_URL}}'</span>;

<span class="comment">// Step 1: Send OTP to the user's email</span>
<span class="keyword">async function</span> <span class="function">requestOTP</span>(email) {
    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="function">fetch</span>(`${AUTH_BASE}/auth/request-otp`, {
        method: <span class="string">'POST'</span>,
        headers: {
            <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,
            <span class="string">'X-OTP-API-Key'</span>: OTP_API_KEY
        },
        body: JSON.stringify({ email })
    });
    <span class="keyword">if</span> (!res.ok) <span class="keyword">throw new</span> Error((<span class="keyword">await</span> res.json()).detail);
    <span class="keyword">return</span> res.json(); <span class="comment">// { success: true, expiresIn: 600, remaining: 4 }</span>
}

<span class="comment">// Step 2: User enters the 9-digit code ‚Üí exchange for tokens</span>
<span class="keyword">async function</span> <span class="function">verifyOTP</span>(email, otp) {
    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="function">fetch</span>(`${AUTH_BASE}/auth/verify-otp`, {
        method: <span class="string">'POST'</span>,
        credentials: <span class="string">'include'</span>,  <span class="comment">// IMPORTANT: sends/receives HttpOnly cookies</span>
        headers: {
            <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,
            <span class="string">'X-OTP-API-Key'</span>: OTP_API_KEY
        },
        body: JSON.stringify({ email, otp })
    });
    <span class="keyword">if</span> (!res.ok) <span class="keyword">throw new</span> Error((<span class="keyword">await</span> res.json()).detail);

    <span class="keyword">const</span> data = <span class="keyword">await</span> res.json();
    <span class="comment">// Cookies (auth_token, refresh_token) are set automatically by the browser.</span>
    <span class="comment">// data.sub = customerId, data.displayName = user's name</span>
    <span class="keyword">return</span> data;
}

<span class="comment">// Step 3: Make authenticated requests (cookie is sent automatically)</span>
<span class="keyword">async function</span> <span class="function">fetchProtectedResource</span>(url) {
    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="function">fetch</span>(url, { credentials: <span class="string">'include'</span> });

    <span class="keyword">if</span> (res.status === 401) {
        <span class="comment">// Token expired ‚Äî try refreshing</span>
        <span class="keyword">const</span> refreshRes = <span class="keyword">await</span> <span class="function">fetch</span>(`${AUTH_BASE}/auth/refresh`, {
            method: <span class="string">'POST'</span>,
            credentials: <span class="string">'include'</span>,  <span class="comment">// sends refresh_token cookie</span>
        });
        <span class="keyword">if</span> (!refreshRes.ok) <span class="keyword">throw new</span> Error(<span class="string">'Session expired ‚Äî please log in again'</span>);

        <span class="comment">// New cookies set automatically ‚Äî retry original request</span>
        <span class="keyword">return</span> <span class="function">fetch</span>(url, { credentials: <span class="string">'include'</span> });
    }

    <span class="keyword">return</span> res;
}</div>
        </div>
        
        <!-- CORS / Origin Restrictions -->
        <h3 id="sec-origins">üåê Origin Restrictions ‚Äî Controlling Where Your Key Can Be Used</h3>
        <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 1rem;">
            Every API key can optionally be locked to specific web origins. This controls which websites
            are allowed to make requests using that key. If someone copies your key and tries to use it
            from a different website, the request is rejected.
        </p>

        <div class="mermaid-container">
            <div class="diagram-title">How Origin Checking Works</div>
            <div class="mermaid">
flowchart TD
    A[Request arrives] --> B{Has API Key?}
    B -->|No| Z[401 Unauthorized]
    B -->|Yes| C{Key Valid?}
    C -->|No| Z
    C -->|Yes| D{Key has origins?}
    D -->|No| E["Allow ANY origin"]
    D -->|Yes| F{Origin in list?}
    F -->|Yes| G["Allow request"]
    F -->|No| H["403 Forbidden"]
    
    style E fill:#28a745,color:#fff
    style G fill:#28a745,color:#fff
    style H fill:#ea2b1f,color:#fff
    style Z fill:#ea2b1f,color:#fff
            </div>
        </div>

        <h4 style="margin-top: 1rem;">How to configure origins</h4>
        <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.75rem;">
            In the OTP Auth dashboard, go to <strong>API Keys</strong>, find the key you want to restrict,
            and click the <strong>Origins</strong> button (e.g. <strong>Origins (0)</strong>). Add the origins (websites) that should be allowed to
            use this key. An origin is the protocol + domain + port of a URL ‚Äî nothing after the port.
        </p>

        <h4>Origin format examples</h4>
        <table class="security-table" style="font-size: 0.85rem;">
            <thead><tr><th>URL</th><th>Origin Value to Add</th></tr></thead>
            <tbody>
                <tr><td><code>https://myapp.com/login</code></td><td><code>https://myapp.com</code></td></tr>
                <tr><td><code>https://app.mycompany.io:8443/dashboard</code></td><td><code>https://app.mycompany.io:8443</code></td></tr>
                <tr><td><code>http://localhost:3000/auth</code></td><td><code>http://localhost:3000</code></td></tr>
                <tr><td><code>http://localhost:5173</code> (Vite default)</td><td><code>http://localhost:5173</code></td></tr>
            </tbody>
        </table>

        <h4 style="margin-top: 1rem;">Common scenarios</h4>
        <table class="security-table" style="font-size: 0.85rem;">
            <thead><tr><th>Scenario</th><th>Origins to Configure</th><th>Why</th></tr></thead>
            <tbody>
                <tr>
                    <td><strong>Backend-only key</strong></td>
                    <td>None (leave empty)</td>
                    <td>Server-to-server calls don't send an <code>Origin</code> header, so origin restrictions don't apply. The key is already protected by being in your server's environment variables.</td>
                </tr>
                <tr>
                    <td><strong>Frontend key ‚Äî production</strong></td>
                    <td><code>https://myapp.com</code></td>
                    <td>Only your production website can use this key. Anyone who copies it and tries it from a different site gets <code>403 Forbidden</code>.</td>
                </tr>
                <tr>
                    <td><strong>Frontend key ‚Äî production + staging</strong></td>
                    <td><code>https://myapp.com</code><br><code>https://staging.myapp.com</code></td>
                    <td>Same key works for both environments. Add each origin separately.</td>
                </tr>
                <tr>
                    <td><strong>Frontend key ‚Äî local development</strong></td>
                    <td><code>http://localhost:3000</code><br><code>http://localhost:5173</code></td>
                    <td>Add every local port your dev server uses. You can add production origins to the same key too.</td>
                </tr>
                <tr>
                    <td><strong>This test page (opened from file)</strong></td>
                    <td>Option A: Serve the file (e.g. <code>python -m http.server 8080</code>) and add <code>http://localhost:8080</code>.<br>Option B: Add the literal <code>null</code> to allowed origins.</td>
                    <td>Pages opened as <code>file://</code> send <code>Origin: null</code>. The server does not auto-allow null. Use Option A (recommended) so the page has a real origin, or Option B to allow null explicitly for this key (all endpoints, including token responses).</td>
                </tr>
            </tbody>
        </table>

        <p style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.75rem;">
            <strong>Null origin (file://):</strong> There is no server-side fallback that allows <code>null</code> automatically.
            You must either serve this test page from a local web server (so the browser sends a real origin like <code>http://localhost:8080</code>) and add that origin to the key, or add the literal <code>null</code> to the key's allowed origins. Both are explicit choices.
        </p>

        <h4 style="margin-top: 1rem;">What happens at runtime</h4>
        <div class="code-example"><span class="comment">// Request from https://myapp.com (origin IS in the allowed list)</span>
<span class="function">fetch</span>(<span class="string">'{{BASE_URL}}/auth/request-otp'</span>, {
    method: <span class="string">'POST'</span>,
    headers: {
        <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,
        <span class="string">'X-OTP-API-Key'</span>: <span class="string">'otp_live_sk_xxx'</span>
    },
    body: JSON.stringify({ email: <span class="string">'user@example.com'</span> })
});
<span class="comment">// ‚Üí 200 OK ‚Äî origin matches, request proceeds</span>

<span class="comment">// Same request from https://evil-site.com (origin NOT in the allowed list)</span>
<span class="comment">// ‚Üí 403 Forbidden ‚Äî origin rejected, no OTP is ever sent</span>

<span class="comment">// Same key used from your Node.js server (no Origin header at all)</span>
<span class="comment">// ‚Üí 200 OK ‚Äî server-to-server calls bypass origin checks entirely</span></div>

        <p style="background: var(--bg); padding: 0.75rem; border-radius: 6px; font-size: 0.8rem; color: var(--warning); margin-top: 0.75rem;">
            <strong>‚ö†Ô∏è Key distinction:</strong> "No origins configured" does <strong>not</strong> mean "anyone can access."
            It means anyone <em>who possesses the valid API key</em> can use it from any website.
            No valid key = no access, regardless of origin settings. The key itself is always the first line of defence.
        </p>
        
        <!-- Key Compromise -->
        <h3 id="sec-key-compromise">üö® If Your API Key Is Compromised</h3>
        <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.75rem;">
            If you suspect your API key has been leaked, exposed in a public repository, or used by an
            unauthorized party ‚Äî act immediately. Revoking a key is instant and irreversible; all
            requests using the old key will fail immediately with <code>401 Unauthorized</code>.
        </p>
        <div class="mermaid-container">
            <div class="diagram-title">Key Rotation Procedure</div>
            <div class="mermaid">
flowchart LR
    A[Key Compromised] --> B[Dashboard]
    B --> C[Revoke Key]
    C --> D[Create New Key]
    D --> E[Update App]
    
    style A fill:#ea2b1f,color:#fff
    style C fill:#ffc107,color:#000
    style E fill:#28a745,color:#fff
            </div>
        </div>
        <p style="font-size: 0.85rem; margin-top: 0.5rem;"><strong>Step-by-step:</strong></p>
        <ol style="font-size: 0.8rem; color: var(--text-muted); padding-left: 1.25rem; margin-bottom: 0.75rem;">
            <li style="margin-bottom: 0.5rem;"><strong>Revoke the compromised key</strong> ‚Äî Go to the
                <strong>OTP Auth Dashboard ‚Üí API Keys</strong> page. Find the compromised key and click
                the <strong>üóëÔ∏è Revoke</strong> button. This takes effect immediately ‚Äî any request
                using this key from this moment forward will be rejected.</li>
            <li style="margin-bottom: 0.5rem;"><strong>Create a new key</strong> ‚Äî On the same page,
                click <strong>Create API Key</strong>. Give it a descriptive name (e.g., "production-v2").
                Copy the new key ‚Äî it is only shown once.</li>
            <li style="margin-bottom: 0.5rem;"><strong>Update your application</strong> ‚Äî Replace the old
                key in your environment variables (<code>OTP_AUTH_API_KEY</code>) or frontend configuration.
                If using a backend proxy, update your server's <code>.env</code> file and redeploy. If using
                a frontend key, push a new build with the updated key.</li>
            <li style="margin-bottom: 0.5rem;"><strong>Configure origin restrictions</strong> (if frontend)
                ‚Äî On the new key, click the <strong>Origins</strong> button and add your allowed origins to
                prevent the same exposure from being exploitable again.</li>
            <li><strong>Audit your logs</strong> ‚Äî Check the <strong>Audit Logs</strong> page in the
                dashboard to see if the compromised key was used for any unauthorized requests.</li>
        </ol>
        <p style="font-size: 0.8rem; color: var(--text-muted);">
            <strong>Impact:</strong> Revoking a key does <strong>not</strong> invalidate any JWTs that were
            already issued using that key. Existing user sessions remain valid until their tokens expire
            (15 minutes for access tokens). If you need to immediately invalidate specific user sessions,
            use the <code>POST /auth/logout</code> endpoint for those users.
        </p>
        
        <!-- Environment Info -->
        <h3 id="sec-test-page">üìã This Test Page</h3>
        <ul>
            <li><strong>API Base URL:</strong> <code>{{BASE_URL}}</code></li>
            <li><strong>No origin config?</strong> This page works from any <em>real</em> origin (e.g. <code>https://‚Ä¶</code>, <code>http://localhost:‚Ä¶</code>). Opened as <code>file://</code> it sends <code>Origin: null</code>, which is not allowed unless you add <code>null</code> or serve the page.</li>
            <li><strong>Origin config?</strong> Add this page's origin via Dashboard ‚Üí API Keys ‚Üí <strong>Origins</strong> button (e.g. <code>http://localhost:8080</code> if you serve the file locally).</li>
            <li><strong>Opened from file (file://)?</strong> Either serve the file (e.g. <code>python -m http.server 8080</code>) and add that origin, or add the literal <code>null</code> to this key's allowed origins. No automatic allowance for null.</li>
        </ul>
    </div>
</div>

<!-- Security Documentation Section -->
<div class="card security-docs">
    <div class="collapsible-header" onclick="toggleSecurityDocs()">
        <h2>‚ö†Ô∏è Security & Integration Guide</h2>
        <span class="toggle-icon" id="toggleIcon">‚ñº</span>
    </div>
    <div class="collapsible-content expanded" id="securityContent">
        <p style="margin: 1rem 0; color: var(--text-muted); font-size: 0.875rem;">
            <strong>IMPORTANT:</strong> Read this before integrating into your production application.
        </p>
        
        <!-- API Key Purpose -->
        <h3>üîë What This API Key Does vs. Doesn't Do</h3>
        <table class="security-table">
            <thead>
                <tr>
                    <th>Purpose</th>
                    <th>API Key</th>
                    <th>JWT Token</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Identifies Tenant/Customer</td>
                    <td><span class="badge badge-success">‚úì Yes</span></td>
                    <td><span class="badge badge-warning">Inherits</span></td>
                </tr>
                <tr>
                    <td>Per-key origin restrictions (optional)</td>
                    <td><span class="badge badge-success">‚úì Yes</span></td>
                    <td>‚Äî</td>
                </tr>
                <tr>
                    <td>Applies rate limits</td>
                    <td><span class="badge badge-success">‚úì Yes</span></td>
                    <td>‚Äî</td>
                </tr>
                <tr>
                    <td>Authenticates the USER</td>
                    <td><span class="badge badge-danger">‚úó No</span></td>
                    <td><span class="badge badge-success">‚úì Yes</span></td>
                </tr>
                <tr>
                    <td>Grants data access</td>
                    <td><span class="badge badge-danger">‚úó No</span></td>
                    <td><span class="badge badge-success">‚úì Yes</span></td>
                </tr>
                <tr>
                    <td>Should be kept secret</td>
                    <td><span class="badge badge-warning">Depends*</span></td>
                    <td><span class="badge badge-success">‚úì Always</span></td>
                </tr>
            </tbody>
        </table>
        <p style="font-size: 0.75rem; color: var(--text-muted);">
            * Backend = keep secret. Frontend = visible (optionally restrict via per-key origins).
        </p>
        
        <!-- Security Model - PLAIN AS MUD -->
        <div style="background: var(--bg-light); border: 2px solid var(--accent); border-radius: 8px; padding: 1rem; margin: 1.5rem 0;">
            <h3 style="margin: 0 0 0.75rem 0; color: var(--accent);">üîê Security Model - How It Actually Works</h3>
            
            <p style="font-size: 0.9rem; margin-bottom: 1rem; font-weight: bold;">
                The API key itself IS the security. No valid key = no access. Period.
            </p>
            
            <table class="security-table" style="margin-bottom: 1rem;">
                <thead>
                    <tr>
                        <th>Scenario</th>
                        <th>What Happens</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>No API key provided</strong></td>
                        <td><span class="badge badge-danger">401 Unauthorized</span> ‚Äî Nothing happens</td>
                    </tr>
                    <tr>
                        <td><strong>Invalid/revoked API key</strong></td>
                        <td><span class="badge badge-danger">401 Unauthorized</span> ‚Äî Nothing happens</td>
                    </tr>
                    <tr>
                        <td><strong>Valid key, NO origins configured</strong></td>
                        <td><span class="badge badge-success">‚úì Works</span> ‚Äî Key authenticates, any origin allowed</td>
                    </tr>
                    <tr>
                        <td><strong>Valid key, origins configured</strong></td>
                        <td><span class="badge badge-success">‚úì Works</span> ‚Äî Only from those specific origins</td>
                    </tr>
                </tbody>
            </table>
            
            <div style="background: var(--bg); padding: 0.75rem; border-radius: 4px; font-size: 0.85rem;">
                <p style="margin: 0 0 0.5rem 0;"><strong>Think of it like a password:</strong></p>
                <ul style="margin: 0; padding-left: 1.25rem;">
                    <li><strong>Backend keys:</strong> Stored in env vars, never exposed. Works from "any origin" because it's only used from YOUR server.</li>
                    <li><strong>Frontend keys:</strong> Visible in browser JS. Configure origins to prevent someone from copying it and using it elsewhere.</li>
                </ul>
                <p style="margin: 0.75rem 0 0 0; color: var(--warning);">
                    <strong>‚ö†Ô∏è "Any origin" doesn't mean "anyone can access"</strong> ‚Äî it means "anyone WITH THE VALID KEY can access from any origin."
                </p>
            </div>
        </div>
        
        <!-- Integration Methods -->
        <h3>üõ°Ô∏è Integration Methods</h3>
        
        <div class="tabs">
            <button class="tab-btn active" onclick="showTab('backend')">‚úÖ Backend-Only (Recommended)</button>
            <button class="tab-btn" onclick="showTab('frontend')">‚ö° Direct Frontend</button>
            <button class="tab-btn" onclick="showTab('oidc')">üåê OIDC Token Verification</button>
        </div>
        
        <!-- Backend Tab -->
        <div id="tab-backend" class="tab-content active">
            <div class="method-box recommended">
                <h4>‚úÖ Method 1: Backend-Only Integration</h4>
                <p style="font-size: 0.8rem; color: var(--success); margin-bottom: 0.5rem;">
                    <strong>HIGHEST SECURITY</strong> ‚Äî API key never reaches the browser
                </p>
            </div>
            
            <div class="mermaid-container">
                <div class="diagram-title">Backend Integration Flow</div>
                <div class="mermaid">
sequenceDiagram
    participant B as Browser
    participant Y as Your Server
    participant O as OTP Auth API

    Note over Y: API key in env vars (secret)

    B->>Y: Request OTP
    Y->>O: POST /auth/request-otp
    Note over Y,O: X-OTP-API-Key header
    O-->>Y: OTP sent to user email
    Y-->>B: Success

    B->>Y: Submit OTP code
    Y->>O: POST /auth/verify-otp
    Note over Y,O: X-OTP-API-Key header
    O-->>Y: JWT access token
    Y-->>B: Sets HttpOnly cookie
                </div>
            </div>
            
            <div class="code-example">
<span class="comment">// YOUR BACKEND SERVER (Node.js example)</span>
<span class="keyword">const</span> OTP_API_KEY = process.env.OTP_AUTH_API_KEY; <span class="comment">// Secret!</span>

app.post(<span class="string">'/api/auth/request-otp'</span>, <span class="keyword">async</span> (req, res) => {
    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'{{BASE_URL}}/auth/request-otp'</span>, {
        method: <span class="string">'POST'</span>,
        headers: {
            <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,
            <span class="string">'X-OTP-API-Key'</span>: OTP_API_KEY
        },
        body: JSON.stringify({ email: req.body.email })
    });
    res.json(<span class="keyword">await</span> response.json());
});
            </div>
        </div>
        
        <!-- Frontend Tab -->
        <div id="tab-frontend" class="tab-content">
            <div class="method-box alternative">
                <h4>‚ö° Method 2: Direct Frontend Integration</h4>
                <p style="font-size: 0.8rem; color: var(--warning); margin-bottom: 0.5rem;">
                    <strong>MODERATE SECURITY</strong> ‚Äî API key visible (optionally add origin restrictions)
                </p>
            </div>
            
            <div class="mermaid-container">
                <div class="diagram-title">Direct Frontend Flow</div>
                <div class="mermaid">
sequenceDiagram
    participant B as Browser
    participant O as OTP Auth API
    participant H as Attacker

    Note over B,O: Key visible in JS bundle
    Note over B,O: Configure origins to restrict

    B->>O: POST /auth/request-otp
    Note over B,O: X-OTP-API-Key in header
    O-->>B: OTP sent to email

    H->>O: Same key, wrong origin
    O-->>H: 403 Forbidden
                </div>
            </div>
            
            <div class="code-example">
<span class="comment">// YOUR FRONTEND (React/Vue/Vanilla JS)</span>
<span class="keyword">const</span> OTP_API_KEY = <span class="string">'otp_live_sk_xxx'</span>; <span class="comment">// Visible (restrict with per-key origins)</span>

<span class="keyword">async function</span> <span class="function">requestOTP</span>(email) {
    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'{{BASE_URL}}/auth/request-otp'</span>, {
        method: <span class="string">'POST'</span>,
        headers: {
            <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,
            <span class="string">'X-OTP-API-Key'</span>: OTP_API_KEY
        },
        body: JSON.stringify({ email })
    });
    <span class="keyword">return</span> response.json();
}
            </div>
        </div>
        
        <!-- OIDC Tab -->
        <div id="tab-oidc" class="tab-content">
            <div class="method-box recommended">
                <h4>üåê OIDC-Compliant Token Issuance</h4>
                <p style="font-size: 0.8rem; color: var(--success); margin-bottom: 0.5rem;">
                    <strong>RS256 SIGNED</strong> ‚Äî Tokens verified via JWKS, no shared secret required
                </p>
            </div>
            
            <div class="mermaid-container">
                <div class="diagram-title">Full Authentication + Service Verification Flow</div>
                <div class="mermaid">
sequenceDiagram
    participant B as Browser/App
    participant A as Auth Service
    participant S as Resource Server

    B->>A: POST /auth/verify-otp
    Note over B,A: email + OTP code sent
    A-->>B: access_token + refresh_token
    Note over A,B: auth_token cookie (15m)<br/>refresh_token cookie (7d)

    B->>S: Request with auth_token cookie
    S->>A: GET /.well-known/jwks.json
    Note over S,A: Cached for 10 minutes
    S->>S: Verify RS256 signature
    S->>S: Extract sub (customerId)
    S-->>B: Protected resource returned

    Note over B: Access token expires (15m)
    B->>A: POST /auth/refresh
    Note over B,A: Sends refresh_token cookie
    A->>A: Rotate refresh token
    A-->>B: New access_token + refresh_token
    Note over A,B: Max 7 days from original login
                </div>
            </div>
            
            <div class="code-example">
<span class="comment">// Service-to-service verification (any service)</span>
<span class="keyword">import</span> { decodeJWTHeader, verifyRS256JWT } <span class="keyword">from</span> <span class="string">'@strixun/api-framework/jwt'</span>;

<span class="comment">// Fetch JWKS once and cache</span>
<span class="keyword">const</span> jwksResp = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'{{BASE_URL}}/.well-known/jwks.json'</span>);
<span class="keyword">const</span> { keys } = <span class="keyword">await</span> jwksResp.json();

<span class="comment">// Verify incoming token</span>
<span class="keyword">const</span> header = decodeJWTHeader(token);
<span class="keyword">const</span> key = keys.find(k => k.kid === header?.kid);
<span class="keyword">const</span> payload = <span class="keyword">await</span> verifyRS256JWT(token, key);
            </div>
            
            <p style="font-size: 0.85rem; margin-top: 1rem;">
                <strong>OIDC Endpoints:</strong>
            </p>
            <ul style="font-size: 0.85rem;">
                <li><code>GET /.well-known/openid-configuration</code> ‚Äî Discovery document (issuer, endpoints, supported features)</li>
                <li><code>GET /.well-known/jwks.json</code> ‚Äî Public signing keys (RS256)</li>
                <li><code>POST /auth/verify-otp</code> ‚Äî Token endpoint (OTP exchange ‚Üí access_token + id_token + refresh_token, sets HttpOnly cookies)</li>
                <li><code>POST /auth/refresh</code> ‚Äî Refresh tokens (exchange opaque refresh_token cookie for new access + refresh tokens with rotation)</li>
                <li><code>GET /auth/me</code> ‚Äî UserInfo endpoint (scope-based claims, uses HttpOnly cookie)</li>
                <li><code>POST /auth/introspect</code> ‚Äî Token introspection (RFC 7662)</li>
                <li><code>POST /auth/logout</code> ‚Äî Revoke tokens, delete session + refresh token from KV, clear cookies</li>
            </ul>

            <p style="font-size: 0.85rem; margin-top: 1rem;">
                <strong>Grant Types:</strong> <code>urn:ietf:params:oauth:grant-type:otp</code>, <code>refresh_token</code>
            </p>

            <p style="font-size: 0.85rem; margin-top: 1rem;">
                <strong>Token Lifetimes:</strong>
            </p>
            <table class="security-table" style="font-size: 0.85rem;">
                <thead><tr><th>Token</th><th>Lifetime</th><th>Delivery</th></tr></thead>
                <tbody>
                    <tr><td>Access token (JWT, RS256)</td><td>15 minutes</td><td>Response body + <code>auth_token</code> HttpOnly cookie</td></tr>
                    <tr><td>ID token (JWT, RS256)</td><td>15 minutes (same as access)</td><td>Response body only</td></tr>
                    <tr><td>Refresh token (opaque)</td><td>7-day absolute max from login</td><td>Response body + <code>refresh_token</code> HttpOnly cookie</td></tr>
                </tbody>
            </table>

            <p style="font-size: 0.8rem; color: var(--text-muted); margin-top: 1rem;">
                This service uses a custom OTP grant type instead of the standard authorization code flow.
                Users authenticate by receiving a 9-digit one-time password via email and exchanging it at the token endpoint.
                The response is fully OIDC-compliant: <code>access_token</code> (RS256, 15 min),
                <code>id_token</code> (identity claims), <code>refresh_token</code> (opaque, single-use, 7-day max),
                <code>token_type</code>, <code>expires_in</code>, <code>refresh_expires_in</code>, and <code>scope</code>.
            </p>

            <p style="font-size: 0.85rem; margin-top: 1rem;">
                <strong>Refresh Behaviour (no heartbeat):</strong>
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted);">
                There is <strong>no polling or background heartbeat</strong>. Token refresh is entirely <strong>reactive</strong> --
                it only fires when the user performs an action after the 15-minute access token has expired.
                If the user is idle, zero network requests are made. The auth store catches the 401, calls
                <code>POST /auth/refresh</code> (sending the <code>refresh_token</code> HttpOnly cookie),
                receives new tokens, and retries the original request transparently.
                This continues for up to 7 days from the original login.
            </p>

            <p style="font-size: 0.85rem; margin-top: 1rem;">
                <strong>Privacy Model:</strong>
            </p>
            <p style="font-size: 0.8rem; color: var(--text-muted);">
                Email addresses are <strong>never</strong> included in JWT payloads, token responses, or any API response.
                The <code>customerId</code> (<code>sub</code> claim) is the sole external identifier.
                Only <code>email_verified: true</code> is included to confirm OTP verification occurred.
                Email exists only in server-side KV storage for internal operations (OTP delivery, session records).
            </p>

            <p style="font-size: 0.85rem; margin-top: 1rem;">
                <strong>Supported Scopes:</strong>
            </p>
            <table class="security-table" style="font-size: 0.85rem;">
                <thead><tr><th>Scope</th><th>Claims Returned</th></tr></thead>
                <tbody>
                    <tr><td><code>openid</code></td><td><code>sub</code>, <code>iss</code>, <code>aud</code>, <code>exp</code>, <code>iat</code>, <code>at_hash</code>, <code>email_verified</code></td></tr>
                    <tr><td><code>profile</code></td><td><code>name</code>, <code>preferred_username</code></td></tr>
                </tbody>
            </table>

            <p style="font-size: 0.85rem; margin-top: 1rem;">
                <strong>ID Token Claims (RS256-signed):</strong>
            </p>
            <table class="security-table" style="font-size: 0.85rem;">
                <thead><tr><th>Claim</th><th>Description</th></tr></thead>
                <tbody>
                    <tr><td><code>iss</code></td><td>Issuer URL (must match Discovery <code>issuer</code> exactly)</td></tr>
                    <tr><td><code>sub</code></td><td>Subject identifier (customerId)</td></tr>
                    <tr><td><code>aud</code></td><td>Audience (API key ID / <code>client_id</code>)</td></tr>
                    <tr><td><code>exp</code></td><td>Expiration time (Unix timestamp)</td></tr>
                    <tr><td><code>iat</code></td><td>Issued-at time (Unix timestamp)</td></tr>
                    <tr><td><code>at_hash</code></td><td>Access token hash (SHA-256, left half, base64url)</td></tr>
                    <tr><td><code>email_verified</code></td><td>Always <code>true</code> (verified by OTP). Raw email is never included.</td></tr>
                </tbody>
            </table>
        </div>
        
        <!-- CORS Setup -->
        <h3>üåê CORS Configuration (Per-Key)</h3>
        <div class="mermaid-container">
            <div class="mermaid">
flowchart TD
    A[Request arrives] --> B{Has API Key?}
    B -->|No| Z[401 Unauthorized]
    B -->|Yes| C{Key Valid?}
    C -->|No| Z
    C -->|Yes| D{Key has origins?}
    D -->|No| E["‚úì Allow ANY origin"]
    D -->|Yes| F{Origin in list?}
    F -->|Yes| G["‚úì Allow request"]
    F -->|No| H["‚úó 403 Forbidden"]
    
    style E fill:#28a745,color:#fff
    style G fill:#28a745,color:#fff
    style H fill:#ea2b1f,color:#fff
    style Z fill:#ea2b1f,color:#fff
            </div>
        </div>
        
        <ul>
            <li><strong>No origins = ANY origin allowed</strong> (key is the auth)</li>
            <li><strong>With origins = ONLY those origins</strong> (extra security)</li>
            <li>Configure in <strong>Dashboard ‚Üí API Keys ‚Üí üåê button</strong> per key</li>
            <li>Server-to-server calls work regardless (no Origin header)</li>
        </ul>
        <p style="background: var(--bg); padding: 0.5rem 0.75rem; border-radius: 4px; font-size: 0.8rem; color: var(--warning); margin-top: 0.5rem;">
            <strong>Remember:</strong> "Any origin" ‚â† "anyone can access". It means anyone <em>with the valid key</em> can access from any origin. No key = no access.
        </p>
        
        <!-- Key Compromise -->
        <h3>üö® If API Key Is Compromised</h3>
        <div class="mermaid-container">
            <div class="mermaid">
flowchart LR
    A[Key Compromised] --> B[Dashboard]
    B --> C[Revoke Key]
    C --> D[Create New Key]
    D --> E[Update App]
    
    style A fill:#ea2b1f,color:#fff
    style C fill:#ffc107,color:#000
    style E fill:#28a745,color:#fff
            </div>
        </div>
        
        <!-- Environment Info -->
        <h3>üìã This Test Page</h3>
        <ul>
            <li><strong>API Base URL:</strong> <code>{{BASE_URL}}</code></li>
            <li><strong>No origin config?</strong> This page works immediately from any origin</li>
            <li><strong>Origin config?</strong> Add this page's origin via Dashboard ‚Üí API Keys ‚Üí üåê button</li>
            <li><strong>Serving locally:</strong> Run <code>python -m http.server 8080</code> (add <code>http://localhost:8080</code> if using origin restrictions)</li>
        </ul>
    </div>
</div>

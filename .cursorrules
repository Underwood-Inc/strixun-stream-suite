# Cursor AI Rules - Strixun Stream Suite

## CSS/SCSS Rules - CRITICAL

### NEVER Use Nested BEM Selectors in Svelte Components
- **ABSOLUTE PROHIBITION**: Never use nested BEM selectors with `&__` or `&--` in Svelte `<style>` blocks
- **Why**: Svelte's scoped styles don't compile nested BEM selectors correctly, causing styles to not apply
- **Solution**: Always use explicit descendant selectors

### ❌ WRONG - Nested BEM (DO NOT USE):
```scss
.component {
  &__child {
    color: red;
  }
}
```

### ✅ CORRECT - Explicit Selectors (ALWAYS USE):
```scss
.component {
  // Base styles
}

.component .component__child {
  color: red;
}
```

### CSS Specificity Rules
- Always use proper selector specificity
- Prefer class selectors over ID selectors
- Use BEM naming conventions for class names: `.block__element--modifier`
- Write explicit descendant selectors: `.parent .parent__child` not `.parent { &__child {} }`
- Use CSS custom properties (variables) for theming: `var(--color-name)`

### CSS Variable Usage
- **ALWAYS** use CSS variables from `_variables.scss` for colors, spacing, etc.
- **NEVER** hardcode color values like `#ff0000` or `rgb(255, 0, 0)`
- Use: `color: var(--text);` not `color: #f9f9f9;`
- Use: `background: var(--card);` not `background: #252017;`

### Positioning and Layout
- Use `position: fixed` for tooltips, modals, and overlays that need to escape parent containers
- Use `position: absolute` for positioned elements within a relative parent
- Use `position: relative` for creating positioning context
- Use `position: sticky` for scroll-sticking elements
- **NEVER** use `position: fixed` inside a `position: relative` container without portal rendering

### Z-Index Management
- Tooltips and overlays: `z-index: 99999` (highest)
- Modals and dialogs: `z-index: 10000`
- Dropdowns and popovers: `z-index: 1000`
- Sticky headers: `z-index: 100`
- Regular content: `z-index: 1` or auto
- **NEVER** use arbitrary z-index values without documentation

### Transitions and Animations
- Always use CSS custom properties for transition durations: `transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);`
- Use `requestAnimationFrame` for JavaScript-driven animations
- Disable transitions during drag/resize operations: `.resizing { transition: none; }`
- Use GPU-accelerated properties: `transform`, `opacity` (not `width`, `height`, `top`, `left`)

### Responsive Design
- Use CSS custom properties for breakpoints
- Mobile-first approach: start with mobile styles, add desktop with `@media (min-width: ...)`
- Use `clamp()` for fluid typography: `font-size: clamp(14px, 2vw, 18px);`
- Use `min()`, `max()`, and `clamp()` for responsive spacing

### Performance
- Use `will-change` sparingly and only for elements that will animate
- Use `transform: translateZ(0)` or `transform: translate3d(0,0,0)` for GPU acceleration
- Avoid animating `width`, `height`, `top`, `left` - use `transform` instead
- Use `contain` property for isolated components: `contain: layout style paint;`

### Portal Rendering
- Tooltips, modals, and overlays MUST be rendered at body level using portals
- Use Svelte actions or manual DOM manipulation to append to `document.body`
- Set portal container: `position: fixed; z-index: 99999; pointer-events: none;`
- Clean up portal containers in `onDestroy`

### Scrollbar Styling
- Use `::-webkit-scrollbar` for WebKit browsers
- Use `scrollbar-width` and `scrollbar-color` for Firefox
- Always provide both WebKit and Firefox fallbacks
- Use CSS variables for scrollbar colors

### Content Adjustment (Layout Shift Prevention)
- When scrollbars appear/disappear, use negative margin + padding to prevent layout shift
- Apply adjustment only when scrollbar is present
- Use CSS variables for dynamic width: `margin-right: var(--scrollbar-width, 0px);`
- Remove adjustment when scrollbar disappears

### Smooth Width Transitions for Side Panels/Overlays
- **CRITICAL**: Transitions must be applied to the element that changes, not parent selectors
- **NEVER** use `:has()` selector for width transitions - CSS transitions don't work on selector matching changes
- **Problem**: When using `:has()` on a parent, the transition is scoped incorrectly and won't animate
  ```scss
  // ❌ WRONG - transition won't work because selector matching doesn't trigger transitions
  .parent:has(.child.expanded) .content {
    transition: margin-right 0.3s ease;
    margin-right: 280px;
  }
  ```
- **Solution**: Use CSS variables on the element that needs to transition
  ```scss
  // ✅ CORRECT - transition is on the element that changes
  .content {
    transition: margin-right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    margin-right: var(--filter-aside-width, 0px);
  }
  ```
  ```typescript
  // Set CSS variable on document root, not on parent element
  $: document.documentElement.style.setProperty('--filter-aside-width', expanded ? `${width}px` : '0px');
  ```
- **Why**: CSS transitions only work on property value changes, not selector matching changes
- **Scoping**: The transition must be on the same element that has the property being animated
- This ensures smooth transitions when side panels expand/collapse
- Works for any dynamic width adjustment that needs to animate

## Component Architecture Rules

### Component Composition
- Components MUST be reusable, composable, and unopinionated
- NO business logic in UI components
- Use slots for composition
- Props should be generic and UI-focused
- Use CSS variables for theming, not hardcoded values

### File Organization
- Keep component files under 300 lines
- Split large files into smaller, composable modules
- One component per file
- Co-locate styles with components (Svelte `<style>` blocks)

## TypeScript Rules

### Type Safety
- Always use TypeScript types, never `any`
- Use interfaces for object shapes
- Use type unions for limited value sets: `'top' | 'bottom' | 'left' | 'right'`
- Export types from component files

### Import Organization
- Group imports: Svelte → stores → modules → types → utils
- Use absolute imports with path aliases: `@/components`, `@/stores`
- Never import business logic into UI components

## General Code Quality

### Naming Conventions
- Use descriptive, semantic names
- Use camelCase for variables and functions
- Use PascalCase for components and classes
- Use kebab-case for CSS classes and file names
- Use SCREAMING_SNAKE_CASE for constants

### Documentation
- Document complex logic with inline comments
- Use JSDoc for function documentation
- Include usage examples in component documentation
- Document CSS custom properties and their purpose

### Error Handling
- Always handle edge cases
- Provide fallbacks for missing data
- Use optional chaining: `obj?.prop?.nested`
- Validate inputs in components

## Git Commit Rules

- Use conventional commit syntax: `type(scope): description`
- Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`
- Examples:
  - `feat(ui): add tooltip component with portal rendering`
  - `fix(css): remove !important from button styles`
  - `refactor(components): split ActivityLog into smaller modules`

## Testing Considerations

- Components should be testable in isolation
- Avoid side effects in component initialization
- Use dependency injection for services
- Mock external dependencies in tests

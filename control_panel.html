<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBS Animation Suite</title>
    <style>
        :root {
            --bg: #0d1117;
            --card: #161b22;
            --border: #30363d;
            --accent: #58a6ff;
            --accent2: #a371f7;
            --success: #3fb950;
            --warning: #d29922;
            --danger: #f85149;
            --text: #e6edf3;
            --muted: #8b949e;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
        }
        
        /* Layout */
        .app { display: flex; flex-direction: column; min-height: 100vh; }
        .header {
            background: var(--card);
            border-bottom: 1px solid var(--border);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .header h1 { font-size: 1.2em; display: flex; align-items: center; gap: 8px; }
        .status-dot {
            width: 10px; height: 10px;
            border-radius: 50%;
            background: var(--danger);
        }
        .status-dot.connected { background: var(--success); }
        .status-dot.connecting { background: var(--warning); animation: pulse 1s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; } }
        
        .tabs {
            display: flex;
            background: var(--card);
            border-bottom: 1px solid var(--border);
            overflow-x: auto;
        }
        .tab {
            padding: 12px 20px;
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
        }
        .tab:hover { color: var(--text); }
        .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
        
        .content { flex: 1; padding: 20px; overflow-y: auto; }
        .page { display: none; }
        .page.active { display: block; }
        
        /* Components */
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .card h3 {
            font-size: 0.9em;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 14px;
            margin-bottom: 8px;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        textarea { resize: vertical; min-height: 100px; font-family: inherit; }
        
        label { display: block; font-size: 0.85em; color: var(--muted); margin-bottom: 4px; }
        
        button {
            padding: 8px 16px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.15s;
        }
        button:hover { background: var(--border); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-primary { background: var(--accent); border-color: var(--accent); color: #000; }
        .btn-primary:hover { background: #79b8ff; }
        .btn-success { background: var(--success); border-color: var(--success); color: #000; }
        .btn-danger { background: var(--danger); border-color: var(--danger); color: #fff; }
        .btn-lg { padding: 12px 24px; font-size: 16px; }
        .btn-block { width: 100%; }
        
        .row { display: flex; gap: 8px; margin-bottom: 8px; }
        .row > * { flex: 1; }
        
        .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; }
        
        .source-btn {
            padding: 16px;
            text-align: center;
            background: linear-gradient(135deg, var(--accent), var(--accent2));
            border: none;
            color: #fff;
            font-weight: 600;
        }
        .source-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        
        .log {
            background: #000;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        .log-entry { margin-bottom: 2px; }
        .log-entry.error { color: var(--danger); }
        .log-entry.success { color: var(--success); }
        .log-entry.info { color: var(--accent); }
        
        .source-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: var(--bg);
            border-radius: 6px;
            margin-bottom: 6px;
        }
        .source-item .name { font-weight: 500; }
        .source-item .type { font-size: 0.8em; color: var(--muted); }
        
        .toggle {
            width: 44px; height: 24px;
            background: var(--border);
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
        }
        .toggle.on { background: var(--success); }
        .toggle::after {
            content: '';
            position: absolute;
            width: 18px; height: 18px;
            background: #fff;
            border-radius: 50%;
            top: 3px; left: 3px;
            transition: transform 0.2s;
        }
        .toggle.on::after { transform: translateX(20px); }
        
        .url-box {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .url-box input { margin: 0; flex: 1; }
        
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            background: var(--border);
        }
        .badge-success { background: var(--success); color: #000; }
        
        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--muted);
        }
        
        /* Text cycler specific */
        .text-preview {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            font-size: 1.5em;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <h1><span class="status-dot" id="statusDot"></span> OBS Animation Suite</h1>
            <div style="display:flex;gap:8px">
                <button onclick="location.reload()" title="Reload Panel">ðŸ”„</button>
                <button onclick="showPage('setup')" id="connectHeaderBtn">Connect</button>
            </div>
        </header>
        
        <nav class="tabs">
            <button class="tab active" onclick="showPage('dashboard')">Dashboard</button>
            <button class="tab" onclick="showPage('sources')">Sources</button>
            <button class="tab" onclick="showPage('text')">Text Cycler</button>
            <button class="tab" onclick="showPage('swaps')">Swaps</button>
            <button class="tab" onclick="showPage('setup')">Setup</button>
        </nav>
        
        <main class="content">
            <!-- Dashboard -->
            <div id="page-dashboard" class="page active">
                <div class="card">
                    <h3>Quick Actions</h3>
                    <div class="grid">
                        <button class="source-btn" onclick="cycleAspect()">ðŸ”„ Cycle Aspect</button>
                        <button class="source-btn" onclick="refreshScenes()">ðŸ”ƒ Refresh</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Current Scene</h3>
                    <div id="currentScene" class="empty-state">Connect to OBS first</div>
                </div>
                
                <div class="card">
                    <h3>Swap Configs</h3>
                    <div class="grid" id="swapGrid">
                        <button class="source-btn" onclick="triggerSwap(1)">Swap 1</button>
                        <button class="source-btn" onclick="triggerSwap(2)">Swap 2</button>
                        <button class="source-btn" onclick="triggerSwap(3)">Swap 3</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Activity Log</h3>
                    <div id="log" class="log"></div>
                </div>
            </div>
            
            <!-- Sources -->
            <div id="page-sources" class="page">
                <div class="card">
                    <h3>Scene Sources</h3>
                    <button onclick="refreshSources()" style="margin-bottom:12px">ðŸ”ƒ Refresh Sources</button>
                    <div id="sourcesList"></div>
                </div>
            </div>
            
            <!-- Text Cycler -->
            <div id="page-text" class="page">
                <div class="card">
                    <h3>Text Source</h3>
                    <select id="textSource" onchange="loadTextSource()">
                        <option value="">-- Select Text Source --</option>
                    </select>
                </div>
                
                <div class="card">
                    <h3>Preview</h3>
                    <div class="text-preview" id="textPreview">Select a source</div>
                </div>
                
                <div class="card">
                    <h3>Text Lines</h3>
                    <textarea id="textLines" placeholder="Enter text lines (one per line)&#10;Line 1&#10;Line 2&#10;Line 3"></textarea>
                </div>
                
                <div class="card">
                    <h3>Settings</h3>
                    <div class="row">
                        <div>
                            <label>Duration (ms)</label>
                            <input type="number" id="textDuration" value="3000" min="500" step="100">
                        </div>
                        <div>
                            <label>Transition</label>
                            <select id="textTransition">
                                <option value="none">None</option>
                                <option value="obfuscate" selected>Obfuscate</option>
                                <option value="typewriter">Typewriter</option>
                                <option value="glitch">Glitch</option>
                            </select>
                        </div>
                        <div>
                            <label>Trans. Duration</label>
                            <input type="number" id="transDuration" value="500" min="100" step="50">
                        </div>
                    </div>
                </div>
                
                <div class="row">
                    <button class="btn-success btn-lg" id="startCycleBtn" onclick="startTextCycle()">â–¶ Start</button>
                    <button class="btn-danger btn-lg" id="stopCycleBtn" onclick="stopTextCycle()" disabled>â–  Stop</button>
                </div>
            </div>
            
            <!-- Swaps -->
            <div id="page-swaps" class="page">
                <div class="card">
                    <h3>Aspect Override</h3>
                    <p style="color:var(--muted);margin-bottom:12px;font-size:0.9em">Temporarily override aspect ratio for swaps</p>
                    <div class="row">
                        <button id="aspectOff" class="btn-primary" onclick="setAspect(0)">Off</button>
                        <button id="aspectPreserve" onclick="setAspect(1)">Preserve</button>
                        <button id="aspectStretch" onclick="setAspect(2)">Stretch</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Trigger Swaps</h3>
                    <p style="color:var(--muted);margin-bottom:12px;font-size:0.9em">Assign hotkeys in OBS: Settings â†’ Hotkeys â†’ "Swap: ..."</p>
                    <div class="grid" id="swapButtons"></div>
                </div>
            </div>
            
            <!-- Setup -->
            <div id="page-setup" class="page">
                <div class="card">
                    <h3>Connection</h3>
                    <div class="row">
                        <div>
                            <label>Host</label>
                            <input type="text" id="host" value="localhost">
                        </div>
                        <div>
                            <label>Port</label>
                            <input type="text" id="port" value="4455">
                        </div>
                    </div>
                    <label>Password</label>
                    <input type="password" id="password" placeholder="Leave empty if not set">
                    <button class="btn-primary btn-block" id="connectBtn" onclick="toggleConnection()">Connect</button>
                </div>
                
                <div class="card">
                    <h3>Add as OBS Dock</h3>
                    <p style="color:var(--muted);margin-bottom:12px;font-size:0.9em">
                        In OBS: <strong>View â†’ Docks â†’ Custom Browser Docks</strong><br>
                        Click + and paste this URL:
                    </p>
                    <div class="url-box">
                        <input type="text" id="dockUrl" readonly>
                        <button onclick="copyUrl()">ðŸ“‹ Copy</button>
                    </div>
                    <p style="color:var(--muted);margin-top:8px;font-size:0.85em" id="copyStatus"></p>
                </div>
                
                <div class="card">
                    <h3>OBS WebSocket Setup</h3>
                    <ol style="color:var(--muted);padding-left:20px;font-size:0.9em;line-height:2">
                        <li>In OBS: <strong>Tools â†’ WebSocket Server Settings</strong></li>
                        <li>Check "Enable WebSocket server"</li>
                        <li>Note the port (default: 4455)</li>
                        <li>Set password if desired</li>
                        <li>Click Apply, then connect here</li>
                    </ol>
                </div>
                
                <div class="card">
                    <h3>Keyboard Shortcuts</h3>
                    <p style="color:var(--muted);font-size:0.9em">When this panel is focused:</p>
                    <ul style="color:var(--muted);padding-left:20px;font-size:0.9em;line-height:2">
                        <li><strong>1-9</strong> - Trigger swap configs</li>
                        <li><strong>A</strong> - Cycle aspect override</li>
                        <li><strong>Space</strong> - Start/stop text cycler</li>
                    </ul>
                </div>
            </div>
        </main>
    </div>

<script>
// ============ State ============
let ws = null;
let connected = false;
let msgId = 1;
let pendingRequests = {};
let currentScene = '';
let sources = [];
let textSources = [];
let aspectMode = 0;

// Text cycler state
let cycleInterval = null;
let cycleIndex = 0;
let isTransitioning = false;
let transitionFrame = null;

// Character sets
const CHARS_ENCHANT = 'á”‘á’·á“µâ†¸á’·âŽ“âŠ£â‘â•Žâ‹®ê–Œê–Žá’²ãƒªð™¹á‘‘âˆ·á“­â„¸âšâŠâˆ´||â¨…Î±Î²Î³Î´ÎµÎ¶Î·Î¸';
const CHARS_GLITCH = 'â–ˆâ–“â–’â–‘â•”â•—â•šâ•â•‘â•â”Œâ”â””â”˜â”‚â”€';

// ============ Initialization ============
document.addEventListener('DOMContentLoaded', () => {
    // Set dock URL
    const url = window.location.href;
    document.getElementById('dockUrl').value = url;
    
    renderSwapButtons();
    log('Ready. Connect to OBS to begin.', 'info');
});

// ============ UI ============
function showPage(id) {
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.getElementById('page-' + id).classList.add('active');
    event.target.classList.add('active');
}

function log(msg, type = '') {
    const el = document.getElementById('log');
    const entry = document.createElement('div');
    entry.className = 'log-entry ' + type;
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    el.insertBefore(entry, el.firstChild);
    if (el.children.length > 50) el.removeChild(el.lastChild);
}

function copyUrl() {
    const url = document.getElementById('dockUrl');
    url.select();
    document.execCommand('copy');
    document.getElementById('copyStatus').textContent = 'âœ“ Copied to clipboard!';
    setTimeout(() => document.getElementById('copyStatus').textContent = '', 2000);
}

function renderSwapButtons() {
    const grid = document.getElementById('swapButtons');
    grid.innerHTML = '';
    for (let i = 1; i <= 9; i++) {
        const btn = document.createElement('button');
        btn.className = 'source-btn';
        btn.textContent = `Swap ${i}`;
        btn.onclick = () => triggerSwap(i);
        grid.appendChild(btn);
    }
}

function updateConnectionUI() {
    const dot = document.getElementById('statusDot');
    const btn = document.getElementById('connectBtn');
    const headerBtn = document.getElementById('connectHeaderBtn');
    
    if (connected) {
        dot.className = 'status-dot connected';
        btn.textContent = 'Disconnect';
        btn.className = 'btn-danger btn-block';
        headerBtn.textContent = 'Connected';
        headerBtn.className = 'btn-success';
    } else {
        dot.className = 'status-dot';
        btn.textContent = 'Connect';
        btn.className = 'btn-primary btn-block';
        headerBtn.textContent = 'Connect';
        headerBtn.className = '';
    }
}

// ============ WebSocket ============
function toggleConnection() {
    connected ? disconnect() : connect();
}

function connect() {
    const host = document.getElementById('host').value || 'localhost';
    const port = document.getElementById('port').value || '4455';
    const password = document.getElementById('password').value;
    
    document.getElementById('statusDot').className = 'status-dot connecting';
    log('Connecting...', 'info');
    
    try {
        ws = new WebSocket(`ws://${host}:${port}`);
        ws.onopen = () => log('Socket open, authenticating...');
        ws.onmessage = e => handleMessage(JSON.parse(e.data), password);
        ws.onerror = () => { log('Connection error', 'error'); disconnect(); };
        ws.onclose = () => { connected = false; updateConnectionUI(); log('Disconnected'); };
    } catch (e) {
        log('Failed: ' + e.message, 'error');
    }
}

function disconnect() {
    if (ws) ws.close();
    connected = false;
    updateConnectionUI();
}

async function handleMessage(data, password) {
    if (data.op === 0) { // Hello
        const auth = data.d.authentication;
        if (auth && password) {
            const secret = await sha256(password + auth.salt);
            const authStr = await sha256(secret + auth.challenge);
            send({ op: 1, d: { rpcVersion: 1, authentication: authStr } });
        } else if (!auth) {
            send({ op: 1, d: { rpcVersion: 1 } });
        } else {
            log('Password required', 'error');
            disconnect();
        }
    } else if (data.op === 2) { // Identified
        connected = true;
        updateConnectionUI();
        log('Connected to OBS!', 'success');
        refreshScenes();
    } else if (data.op === 7) { // Response
        const req = pendingRequests[data.d.requestId];
        if (req) {
            if (data.d.requestStatus.result) {
                req.resolve(data.d.responseData);
            } else {
                req.reject(data.d.requestStatus.comment);
            }
            delete pendingRequests[data.d.requestId];
        }
    } else if (data.op === 5) { // Event
        handleEvent(data.d);
    }
}

function handleEvent(event) {
    if (event.eventType === 'CurrentProgramSceneChanged') {
        currentScene = event.eventData.sceneName;
        document.getElementById('currentScene').textContent = currentScene;
        refreshSources();
    }
}

function send(data) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(data));
    }
}

function request(type, data = {}) {
    return new Promise((resolve, reject) => {
        const id = 'req_' + (msgId++);
        pendingRequests[id] = { resolve, reject };
        send({ op: 6, d: { requestType: type, requestId: id, requestData: data } });
        setTimeout(() => {
            if (pendingRequests[id]) {
                delete pendingRequests[id];
                reject('Timeout');
            }
        }, 5000);
    });
}

async function sha256(msg) {
    const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(msg));
    return btoa(String.fromCharCode(...new Uint8Array(buf)));
}

// ============ OBS Actions ============
async function refreshScenes() {
    if (!connected) return;
    try {
        const data = await request('GetCurrentProgramScene');
        currentScene = data.currentProgramSceneName;
        document.getElementById('currentScene').innerHTML = `<strong>${currentScene}</strong>`;
        refreshSources();
        log('Refreshed scene: ' + currentScene);
    } catch (e) {
        log('Error: ' + e, 'error');
    }
}

async function refreshSources() {
    if (!connected || !currentScene) return;
    try {
        const data = await request('GetSceneItemList', { sceneName: currentScene });
        sources = data.sceneItems || [];
        renderSources();
        updateTextSourceDropdown();
        log(`Found ${sources.length} sources`);
    } catch (e) {
        log('Error getting sources: ' + e, 'error');
    }
}

function renderSources() {
    const list = document.getElementById('sourcesList');
    if (sources.length === 0) {
        list.innerHTML = '<div class="empty-state">No sources in current scene</div>';
        return;
    }
    
    list.innerHTML = sources.map(s => `
        <div class="source-item">
            <div>
                <div class="name">${s.sourceName}</div>
                <div class="type">${s.inputKind || 'scene'}</div>
            </div>
            <div class="toggle ${s.sceneItemEnabled ? 'on' : ''}" 
                 onclick="toggleSource('${s.sourceName}', ${s.sceneItemId}, ${!s.sceneItemEnabled})"></div>
        </div>
    `).join('');
}

async function toggleSource(name, id, enabled) {
    try {
        await request('SetSceneItemEnabled', {
            sceneName: currentScene,
            sceneItemId: id,
            sceneItemEnabled: enabled
        });
        log(`${name}: ${enabled ? 'shown' : 'hidden'}`, 'success');
        refreshSources();
    } catch (e) {
        log('Error: ' + e, 'error');
    }
}

function triggerSwap(n) {
    if (!connected) { log('Not connected', 'error'); return; }
    request('TriggerHotkeyByName', { hotkeyName: `OBSBasicHotkeys.swap_${n}` })
        .then(() => log(`Triggered Swap ${n}`, 'success'))
        .catch(e => log('Swap failed: ' + e, 'error'));
}

function cycleAspect() {
    if (!connected) { log('Not connected', 'error'); return; }
    request('TriggerHotkeyByName', { hotkeyName: 'OBSBasicHotkeys.quick_cycle_aspect' })
        .then(() => log('Cycled aspect override', 'success'))
        .catch(e => log('Failed: ' + e, 'error'));
}

function setAspect(mode) {
    aspectMode = mode;
    document.getElementById('aspectOff').className = mode === 0 ? 'btn-primary' : '';
    document.getElementById('aspectPreserve').className = mode === 1 ? 'btn-primary' : '';
    document.getElementById('aspectStretch').className = mode === 2 ? 'btn-primary' : '';
    // Cycle until we reach desired mode (hacky but works)
    cycleAspect();
    log(`Aspect mode: ${['Off', 'Preserve', 'Stretch'][mode]}`, 'info');
}

// ============ Text Cycler ============
function updateTextSourceDropdown() {
    const select = document.getElementById('textSource');
    const current = select.value;
    
    textSources = sources.filter(s => 
        s.inputKind && (s.inputKind.includes('text') || s.inputKind === 'text_gdiplus_v2' || s.inputKind === 'text_ft2_source_v2')
    );
    
    select.innerHTML = '<option value="">-- Select Text Source --</option>' +
        textSources.map(s => `<option value="${s.sourceName}">${s.sourceName}</option>`).join('');
    
    if (current && textSources.find(s => s.sourceName === current)) {
        select.value = current;
    }
}

async function loadTextSource() {
    const name = document.getElementById('textSource').value;
    if (!name) {
        document.getElementById('textPreview').textContent = 'Select a source';
        return;
    }
    
    try {
        const data = await request('GetInputSettings', { inputName: name });
        const text = data.inputSettings.text || '';
        document.getElementById('textPreview').textContent = text || '(empty)';
    } catch (e) {
        log('Error loading text: ' + e, 'error');
    }
}

async function setText(text) {
    const name = document.getElementById('textSource').value;
    if (!name) return;
    
    try {
        await request('SetInputSettings', {
            inputName: name,
            inputSettings: { text: text }
        });
        document.getElementById('textPreview').textContent = text;
    } catch (e) {
        log('Error setting text: ' + e, 'error');
    }
}

function getTextLines() {
    return document.getElementById('textLines').value
        .split('\n')
        .map(l => l.trim())
        .filter(l => l.length > 0);
}

function startTextCycle() {
    const lines = getTextLines();
    if (lines.length === 0) {
        log('Enter at least one text line', 'error');
        return;
    }
    if (!document.getElementById('textSource').value) {
        log('Select a text source first', 'error');
        return;
    }
    
    const duration = parseInt(document.getElementById('textDuration').value) || 3000;
    
    document.getElementById('startCycleBtn').disabled = true;
    document.getElementById('stopCycleBtn').disabled = false;
    
    cycleIndex = 0;
    showNextText(lines);
    
    cycleInterval = setInterval(() => {
        cycleIndex = (cycleIndex + 1) % lines.length;
        showNextText(lines);
    }, duration);
    
    log('Text cycling started', 'success');
}

function stopTextCycle() {
    if (cycleInterval) {
        clearInterval(cycleInterval);
        cycleInterval = null;
    }
    if (transitionFrame) {
        cancelAnimationFrame(transitionFrame);
        transitionFrame = null;
    }
    isTransitioning = false;
    
    document.getElementById('startCycleBtn').disabled = false;
    document.getElementById('stopCycleBtn').disabled = true;
    
    log('Text cycling stopped');
}

function showNextText(lines) {
    const target = lines[cycleIndex];
    const transition = document.getElementById('textTransition').value;
    const transDur = parseInt(document.getElementById('transDuration').value) || 500;
    
    if (transition === 'none') {
        setText(target);
    } else {
        animateTransition(target, transition, transDur);
    }
}

function animateTransition(target, type, duration) {
    if (isTransitioning) return;
    isTransitioning = true;
    
    const startTime = performance.now();
    
    function frame() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        let display = target;
        if (type === 'obfuscate') {
            display = obfuscateText(target, progress);
        } else if (type === 'typewriter') {
            display = target.substring(0, Math.floor(progress * target.length));
        } else if (type === 'glitch') {
            display = glitchText(target, progress);
        }
        
        setText(display);
        
        if (progress < 1) {
            transitionFrame = requestAnimationFrame(frame);
        } else {
            setText(target);
            isTransitioning = false;
        }
    }
    
    transitionFrame = requestAnimationFrame(frame);
}

function obfuscateText(target, progress) {
    const revealed = Math.floor(progress * target.length);
    let result = '';
    for (let i = 0; i < target.length; i++) {
        if (i < revealed) {
            result += target[i];
        } else if (target[i] === ' ') {
            result += ' ';
        } else {
            result += CHARS_ENCHANT[Math.floor(Math.random() * CHARS_ENCHANT.length)];
        }
    }
    return result;
}

function glitchText(target, progress) {
    const glitchChance = 1 - progress;
    let result = '';
    for (let i = 0; i < target.length; i++) {
        if (target[i] === ' ') {
            result += ' ';
        } else if (Math.random() < glitchChance * 0.5) {
            result += CHARS_GLITCH[Math.floor(Math.random() * CHARS_GLITCH.length)];
        } else {
            result += target[i];
        }
    }
    return result;
}

// ============ Keyboard Shortcuts ============
document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    if (e.key >= '1' && e.key <= '9') triggerSwap(parseInt(e.key));
    if (e.key.toLowerCase() === 'a') cycleAspect();
    if (e.key === ' ') {
        e.preventDefault();
        cycleInterval ? stopTextCycle() : startTextCycle();
    }
});
</script>
</body>
</html>

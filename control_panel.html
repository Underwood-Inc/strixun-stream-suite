<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBS Animation Suite</title>
    <style>
        :root {
            --bg: #0d1117;
            --card: #161b22;
            --border: #30363d;
            --accent: #58a6ff;
            --accent2: #a371f7;
            --success: #3fb950;
            --warning: #d29922;
            --danger: #f85149;
            --text: #e6edf3;
            --muted: #8b949e;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
        }
        
        /* Layout */
        .app { display: flex; flex-direction: column; min-height: 100vh; }
        .header {
            background: var(--card);
            border-bottom: 1px solid var(--border);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .header h1 { font-size: 1.1em; display: flex; align-items: center; gap: 6px; }
        .title-text { white-space: nowrap; }
        .status-dot {
            width: 10px; height: 10px;
            border-radius: 50%;
            background: var(--danger);
        }
        .status-dot.connected { background: var(--success); }
        .status-dot.connecting { background: var(--warning); animation: pulse 1s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; } }
        
        .tabs {
            display: flex;
            background: var(--card);
            border-bottom: 1px solid var(--border);
            overflow-x: auto;
        }
        .tab {
            padding: 10px 16px;
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
            font-size: 1.1em;
            flex: 1;
            text-align: center;
        }
        .tab:hover { color: var(--text); }
        .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
        
        .content { flex: 1; padding: 20px; overflow-y: auto; }
        .page { display: none; }
        .page.active { display: block; }
        
        /* Components */
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .card h3 {
            font-size: 0.9em;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 14px;
            margin-bottom: 8px;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        textarea { resize: vertical; min-height: 100px; font-family: inherit; }
        
        label { display: block; font-size: 0.85em; color: var(--muted); margin-bottom: 4px; }
        
        button {
            padding: 8px 16px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.15s;
        }
        button:hover { background: var(--border); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-primary { background: var(--accent); border-color: var(--accent); color: #000; }
        .btn-primary:hover { background: #79b8ff; }
        .btn-success { background: var(--success); border-color: var(--success); color: #000; }
        .btn-danger { background: var(--danger); border-color: var(--danger); color: #fff; }
        .btn-lg { padding: 12px 24px; font-size: 16px; }
        .btn-block { width: 100%; }
        
        .row { display: flex; gap: 8px; margin-bottom: 8px; }
        .row > * { flex: 1; }
        
        .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; }
        
        .source-btn {
            padding: 16px;
            text-align: center;
            background: linear-gradient(135deg, var(--accent), var(--accent2));
            border: none;
            color: #fff;
            font-weight: 600;
        }
        .source-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        
        .log {
            background: #000;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        .log-entry { margin-bottom: 2px; }
        .log-entry.error { color: var(--danger); }
        .log-entry.success { color: var(--success); }
        .log-entry.info { color: var(--accent); }
        
        .source-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: var(--bg);
            border-radius: 6px;
            margin-bottom: 6px;
        }
        .source-item .name { font-weight: 500; }
        .source-item .type { font-size: 0.8em; color: var(--muted); }
        
        .toggle {
            width: 44px; height: 24px;
            background: var(--border);
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
        }
        .toggle.on { background: var(--success); }
        .toggle::after {
            content: '';
            position: absolute;
            width: 18px; height: 18px;
            background: #fff;
            border-radius: 50%;
            top: 3px; left: 3px;
            transition: transform 0.2s;
        }
        .toggle.on::after { transform: translateX(20px); }
        
        .url-box {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .url-box input { margin: 0; flex: 1; }
        
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            background: var(--border);
        }
        .badge-success { background: var(--success); color: #000; }
        
        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--muted);
        }
        
        /* Text cycler specific */
        .text-preview {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            font-size: 1.5em;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Responsive - Tiny dock (<250px) */
        @media (max-width: 250px) {
            .header { padding: 6px 8px; }
            .header h1 { font-size: 0.85em; }
            .title-text { display: none; }
            .tab { padding: 8px 4px; font-size: 1em; }
            .content { padding: 8px; }
            .card { padding: 8px; margin-bottom: 8px; }
            .card h3 { font-size: 0.7em; margin-bottom: 6px; }
            .grid { grid-template-columns: 1fr; gap: 4px; }
            .source-btn { padding: 8px 4px; font-size: 0.75em; }
            .row { flex-direction: column; gap: 4px; }
            .empty-state { padding: 15px 8px; font-size: 0.85em; }
            button { padding: 5px 8px; font-size: 0.8em; }
            .btn-lg { padding: 8px 12px; font-size: 0.85em; }
            input, select, textarea { padding: 5px 8px; font-size: 0.85em; }
            .log { padding: 6px; font-size: 0.65em; max-height: 100px; }
            .text-preview { padding: 10px; font-size: 1em; min-height: 50px; }
            .source-item { padding: 6px; }
            .source-item .name { font-size: 0.8em; }
            .toggle { width: 32px; height: 18px; flex-shrink: 0; }
            .toggle::after { width: 12px; height: 12px; top: 3px; }
            .toggle.on::after { transform: translateX(14px); }
            .url-box { flex-direction: column; }
        }
        
        /* Responsive - Narrow dock (250-350px) */
        @media (max-width: 350px) and (min-width: 251px) {
            .header { padding: 8px 10px; }
            .header h1 { font-size: 0.9em; }
            .tab { padding: 8px 6px; font-size: 1em; }
            .content { padding: 10px; }
            .card { padding: 10px; margin-bottom: 10px; }
            .card h3 { font-size: 0.75em; margin-bottom: 8px; }
            .grid { grid-template-columns: 1fr 1fr; gap: 6px; }
            .source-btn { padding: 10px 6px; font-size: 0.8em; }
            .row { flex-direction: column; }
            .empty-state { padding: 20px 10px; font-size: 0.9em; }
            button { padding: 6px 10px; font-size: 0.85em; }
            input, select, textarea { padding: 6px 10px; font-size: 0.9em; }
            .log { padding: 8px; font-size: 0.7em; max-height: 120px; }
            .text-preview { padding: 12px; font-size: 1.1em; min-height: 60px; }
        }
        
        /* Responsive - Medium dock (350-500px) */
        @media (max-width: 500px) and (min-width: 351px) {
            .header { padding: 10px 12px; }
            .header h1 { font-size: 1em; }
            .tab { padding: 10px 8px; }
            .content { padding: 12px; }
            .card { padding: 12px; }
            .grid { grid-template-columns: 1fr 1fr; }
            .source-btn { padding: 12px 8px; font-size: 0.85em; }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <h1><span class="status-dot" id="statusDot"></span><span class="title-text">Animation Suite</span></h1>
            <div style="display:flex;gap:4px">
                <button onclick="location.reload()" title="Reload Panel">üîÑ</button>
                <button onclick="showPage('setup')" id="connectHeaderBtn">Connect</button>
            </div>
        </header>
        
        <nav class="tabs">
            <button class="tab active" onclick="showPage('dashboard')" title="Dashboard">üè†</button>
            <button class="tab" onclick="showPage('sources')" title="Sources">üì¶</button>
            <button class="tab" onclick="showPage('text')" title="Text Cycler">üìù</button>
            <button class="tab" onclick="showPage('swaps')" title="Swaps">üîÑ</button>
            <button class="tab" onclick="showPage('setup')" title="Setup">‚öôÔ∏è</button>
        </nav>
        
        <main class="content">
            <!-- Dashboard -->
            <div id="page-dashboard" class="page active">
                <div class="card">
                    <h3>Quick Actions</h3>
                    <div class="grid">
                        <button class="source-btn" onclick="cycleAspect()">üîÑ Cycle Aspect</button>
                        <button class="source-btn" onclick="refreshScenes()">üîÉ Refresh</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Current Scene</h3>
                    <div id="currentScene" class="empty-state">Connect to OBS first</div>
                </div>
                
                <div class="card">
                    <h3>Quick Swaps</h3>
                    <div class="grid" id="dashSwapGrid"></div>
                </div>
                
                <div class="card">
                    <h3>Activity Log</h3>
                    <div id="log" class="log"></div>
                </div>
            </div>
            
            <!-- Sources -->
            <div id="page-sources" class="page">
                <div class="card">
                    <h3>Scene Sources</h3>
                    <button onclick="refreshSources()" style="margin-bottom:12px">üîÉ Refresh Sources</button>
                    <div id="sourcesList"></div>
                </div>
            </div>
            
            <!-- Text Cycler -->
            <div id="page-text" class="page">
                <div class="card">
                    <h3>Text Source</h3>
                    <select id="textSource" onchange="loadTextSource()">
                        <option value="">-- Select Text Source --</option>
                    </select>
                </div>
                
                <div class="card">
                    <h3>Preview</h3>
                    <div class="text-preview" id="textPreview">Select a source</div>
                </div>
                
                <div class="card">
                    <h3>Text Lines</h3>
                    <textarea id="textLines" placeholder="Enter text lines (one per line)&#10;Line 1&#10;Line 2&#10;Line 3"></textarea>
                </div>
                
                <div class="card">
                    <h3>Settings</h3>
                    <div class="row">
                        <div>
                            <label>Duration (ms)</label>
                            <input type="number" id="textDuration" value="3000" min="500" step="100">
                        </div>
                        <div>
                            <label>Transition</label>
                            <select id="textTransition">
                                <option value="none">None</option>
                                <option value="obfuscate" selected>Obfuscate</option>
                                <option value="typewriter">Typewriter</option>
                                <option value="glitch">Glitch</option>
                            </select>
                        </div>
                        <div>
                            <label>Trans. Duration</label>
                            <input type="number" id="transDuration" value="500" min="100" step="50">
                        </div>
                    </div>
                </div>
                
                <div class="row">
                    <button class="btn-success btn-lg" id="startCycleBtn" onclick="startTextCycle()">‚ñ∂ Start</button>
                    <button class="btn-danger btn-lg" id="stopCycleBtn" onclick="stopTextCycle()" disabled>‚ñ† Stop</button>
                </div>
            </div>
            
            <!-- Swaps -->
            <div id="page-swaps" class="page">
                <div class="card">
                    <h3>Quick Swap</h3>
                    <p style="color:var(--muted);margin-bottom:12px;font-size:0.85em">Select two sources and swap their position/size</p>
                    <label>Source A</label>
                    <select id="swapSourceA"></select>
                    <label>Source B</label>
                    <select id="swapSourceB"></select>
                    <div class="row" style="margin-top:8px">
                        <button class="btn-primary btn-lg" onclick="executeSwap()">üîÑ Swap Now</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Settings</h3>
                    <div class="row">
                        <div>
                            <label>Duration (ms)</label>
                            <input type="number" id="swapDuration" value="300" min="0" max="2000" step="50">
                        </div>
                        <div>
                            <label>Easing</label>
                            <select id="swapEasing">
                                <option value="linear">Linear</option>
                                <option value="ease" selected>Ease</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut">Ease Out</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Saved Configs</h3>
                    <div id="savedSwaps"></div>
                    <button onclick="saveCurrentSwap()" style="margin-top:8px">üíæ Save Current</button>
                </div>
            </div>
            
            <!-- Setup -->
            <div id="page-setup" class="page">
                <div class="card">
                    <h3>Connection</h3>
                    <div class="row">
                        <div>
                            <label>Host</label>
                            <input type="text" id="host" value="localhost">
                        </div>
                        <div>
                            <label>Port</label>
                            <input type="text" id="port" value="4455">
                        </div>
                    </div>
                    <label>Password</label>
                    <input type="password" id="password" placeholder="Leave empty if not set">
                    <button class="btn-primary btn-block" id="connectBtn" onclick="toggleConnection()">Connect</button>
                </div>
                
                <div class="card">
                    <h3>Add as OBS Dock</h3>
                    <p style="color:var(--muted);margin-bottom:12px;font-size:0.9em">
                        In OBS: <strong>View ‚Üí Docks ‚Üí Custom Browser Docks</strong><br>
                        Click + and paste this URL:
                    </p>
                    <div class="url-box">
                        <input type="text" id="dockUrl" readonly>
                        <button onclick="copyUrl()">üìã Copy</button>
                    </div>
                    <p style="color:var(--muted);margin-top:8px;font-size:0.85em" id="copyStatus"></p>
                </div>
                
                <div class="card">
                    <h3>OBS WebSocket Setup</h3>
                    <ol style="color:var(--muted);padding-left:20px;font-size:0.9em;line-height:2">
                        <li>In OBS: <strong>Tools ‚Üí WebSocket Server Settings</strong></li>
                        <li>Check "Enable WebSocket server"</li>
                        <li>Note the port (default: 4455)</li>
                        <li>Set password if desired</li>
                        <li>Click Apply, then connect here</li>
                    </ol>
                </div>
                
                <div class="card">
                    <h3>Keyboard Shortcuts</h3>
                    <p style="color:var(--muted);font-size:0.9em">When this panel is focused:</p>
                    <ul style="color:var(--muted);padding-left:20px;font-size:0.9em;line-height:2">
                        <li><strong>1-9</strong> - Trigger saved swap configs</li>
                        <li><strong>Space</strong> - Start/stop text cycler</li>
                    </ul>
                </div>
            </div>
        </main>
    </div>

<script>
// ============ State ============
let ws = null;
let connected = false;
let msgId = 1;
let pendingRequests = {};
let currentScene = '';
let sources = [];
let textSources = [];
let aspectMode = 0;

// Text cycler state
let cycleInterval = null;
let cycleIndex = 0;
let isTransitioning = false;
let transitionFrame = null;

// Character sets
const CHARS_ENCHANT = '·îë·í∑·ìµ‚Ü∏·í∑‚éì‚ä£‚çë‚ïé‚ãÆÍñåÍñé·í≤„É™ùôπ·ëë‚à∑·ì≠‚Ñ∏‚öç‚çä‚à¥||‚®ÖŒ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏';
const CHARS_GLITCH = '‚ñà‚ñì‚ñí‚ñë‚ïî‚ïó‚ïö‚ïù‚ïë‚ïê‚îå‚îê‚îî‚îò‚îÇ‚îÄ';

// ============ Initialization ============
document.addEventListener('DOMContentLoaded', () => {
    // Set dock URL
    const url = window.location.href;
    document.getElementById('dockUrl').value = url;
    
    renderSavedSwaps();
    log('Ready. Connect to OBS to begin.', 'info');
});

// ============ UI ============
function showPage(id) {
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.getElementById('page-' + id).classList.add('active');
    event.target.classList.add('active');
}

function log(msg, type = '') {
    const el = document.getElementById('log');
    const entry = document.createElement('div');
    entry.className = 'log-entry ' + type;
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    el.insertBefore(entry, el.firstChild);
    if (el.children.length > 50) el.removeChild(el.lastChild);
}

function copyUrl() {
    const url = document.getElementById('dockUrl');
    url.select();
    document.execCommand('copy');
    document.getElementById('copyStatus').textContent = '‚úì Copied to clipboard!';
    setTimeout(() => document.getElementById('copyStatus').textContent = '', 2000);
}

function renderDashSwaps() {
    const grid = document.getElementById('dashSwapGrid');
    if (swapConfigs.length === 0) {
        grid.innerHTML = '<div class="empty-state" style="padding:10px;grid-column:1/-1">No saved swaps. Go to üîÑ tab to create one.</div>';
        return;
    }
    grid.innerHTML = swapConfigs.map((c, i) => 
        `<button class="source-btn" onclick="loadSwapConfig(${i})">${c.name}</button>`
    ).join('');
}

function updateConnectionUI() {
    const dot = document.getElementById('statusDot');
    const btn = document.getElementById('connectBtn');
    const headerBtn = document.getElementById('connectHeaderBtn');
    
    if (connected) {
        dot.className = 'status-dot connected';
        btn.textContent = 'Disconnect';
        btn.className = 'btn-danger btn-block';
        headerBtn.textContent = 'Connected';
        headerBtn.className = 'btn-success';
    } else {
        dot.className = 'status-dot';
        btn.textContent = 'Connect';
        btn.className = 'btn-primary btn-block';
        headerBtn.textContent = 'Connect';
        headerBtn.className = '';
    }
}

// ============ WebSocket ============
function toggleConnection() {
    connected ? disconnect() : connect();
}

function connect() {
    const host = document.getElementById('host').value || 'localhost';
    const port = document.getElementById('port').value || '4455';
    const password = document.getElementById('password').value;
    
    document.getElementById('statusDot').className = 'status-dot connecting';
    log('Connecting...', 'info');
    
    try {
        ws = new WebSocket(`ws://${host}:${port}`);
        ws.onopen = () => log('Socket open, authenticating...');
        ws.onmessage = e => handleMessage(JSON.parse(e.data), password);
        ws.onerror = () => { log('Connection error', 'error'); disconnect(); };
        ws.onclose = () => { connected = false; updateConnectionUI(); log('Disconnected'); };
    } catch (e) {
        log('Failed: ' + e.message, 'error');
    }
}

function disconnect() {
    if (ws) ws.close();
    connected = false;
    updateConnectionUI();
}

async function handleMessage(data, password) {
    if (data.op === 0) { // Hello
        const auth = data.d.authentication;
        if (auth && password) {
            const secret = await sha256(password + auth.salt);
            const authStr = await sha256(secret + auth.challenge);
            send({ op: 1, d: { rpcVersion: 1, authentication: authStr } });
        } else if (!auth) {
            send({ op: 1, d: { rpcVersion: 1 } });
        } else {
            log('Password required', 'error');
            disconnect();
        }
    } else if (data.op === 2) { // Identified
        connected = true;
        updateConnectionUI();
        log('Connected to OBS!', 'success');
        refreshScenes();
    } else if (data.op === 7) { // Response
        const req = pendingRequests[data.d.requestId];
        if (req) {
            if (data.d.requestStatus.result) {
                req.resolve(data.d.responseData);
            } else {
                req.reject(data.d.requestStatus.comment);
            }
            delete pendingRequests[data.d.requestId];
        }
    } else if (data.op === 5) { // Event
        handleEvent(data.d);
    }
}

function handleEvent(event) {
    if (event.eventType === 'CurrentProgramSceneChanged') {
        currentScene = event.eventData.sceneName;
        document.getElementById('currentScene').textContent = currentScene;
        refreshSources();
    }
}

function send(data) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(data));
    }
}

function request(type, data = {}) {
    return new Promise((resolve, reject) => {
        const id = 'req_' + (msgId++);
        pendingRequests[id] = { resolve, reject };
        send({ op: 6, d: { requestType: type, requestId: id, requestData: data } });
        setTimeout(() => {
            if (pendingRequests[id]) {
                delete pendingRequests[id];
                reject('Timeout');
            }
        }, 5000);
    });
}

async function sha256(msg) {
    const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(msg));
    return btoa(String.fromCharCode(...new Uint8Array(buf)));
}

// ============ OBS Actions ============
async function refreshScenes() {
    if (!connected) return;
    try {
        const data = await request('GetCurrentProgramScene');
        currentScene = data.currentProgramSceneName;
        document.getElementById('currentScene').innerHTML = `<strong>${currentScene}</strong>`;
        refreshSources();
        log('Refreshed scene: ' + currentScene);
    } catch (e) {
        log('Error: ' + e, 'error');
    }
}

async function refreshSources() {
    if (!connected || !currentScene) return;
    try {
        const data = await request('GetSceneItemList', { sceneName: currentScene });
        sources = data.sceneItems || [];
        renderSources();
        updateTextSourceDropdown();
        updateSwapDropdowns();
        log(`Found ${sources.length} sources`);
    } catch (e) {
        log('Error getting sources: ' + e, 'error');
    }
}

function renderSources() {
    const list = document.getElementById('sourcesList');
    if (sources.length === 0) {
        list.innerHTML = '<div class="empty-state">No sources in current scene</div>';
        return;
    }
    
    list.innerHTML = sources.map(s => `
        <div class="source-item">
            <div>
                <div class="name">${s.sourceName}</div>
                <div class="type">${s.inputKind || 'scene'}</div>
            </div>
            <div class="toggle ${s.sceneItemEnabled ? 'on' : ''}" 
                 onclick="toggleSource('${s.sourceName}', ${s.sceneItemId}, ${!s.sceneItemEnabled})"></div>
        </div>
    `).join('');
}

async function toggleSource(name, id, enabled) {
    try {
        await request('SetSceneItemEnabled', {
            sceneName: currentScene,
            sceneItemId: id,
            sceneItemEnabled: enabled
        });
        log(`${name}: ${enabled ? 'shown' : 'hidden'}`, 'success');
        refreshSources();
    } catch (e) {
        log('Error: ' + e, 'error');
    }
}

// ============ Source Swap (Direct via WebSocket) ============
let swapConfigs = JSON.parse(localStorage.getItem('swapConfigs') || '[]');
let isSwapping = false;

function updateSwapDropdowns() {
    const selA = document.getElementById('swapSourceA');
    const selB = document.getElementById('swapSourceB');
    const opts = '<option value="">-- Select --</option>' + 
        sources.map(s => `<option value="${s.sourceName}">${s.sourceName}</option>`).join('');
    selA.innerHTML = opts;
    selB.innerHTML = opts;
}

async function getSceneItemId(sourceName) {
    const item = sources.find(s => s.sourceName === sourceName);
    return item ? item.sceneItemId : null;
}

async function getTransform(sceneItemId) {
    const data = await request('GetSceneItemTransform', {
        sceneName: currentScene,
        sceneItemId: sceneItemId
    });
    return data.sceneItemTransform;
}

async function setTransform(sceneItemId, transform) {
    await request('SetSceneItemTransform', {
        sceneName: currentScene,
        sceneItemId: sceneItemId,
        sceneItemTransform: transform
    });
}

function easeFunc(t, type) {
    switch(type) {
        case 'easeIn': return t * t;
        case 'easeOut': return t * (2 - t);
        case 'ease': return t < 0.5 ? 2*t*t : -1+(4-2*t)*t;
        default: return t; // linear
    }
}

function lerp(a, b, t) { return a + (b - a) * t; }

async function executeSwap() {
    if (!connected) { log('Not connected', 'error'); return; }
    if (isSwapping) { log('Swap in progress', 'error'); return; }
    
    const nameA = document.getElementById('swapSourceA').value;
    const nameB = document.getElementById('swapSourceB').value;
    
    if (!nameA || !nameB) { log('Select both sources', 'error'); return; }
    if (nameA === nameB) { log('Select different sources', 'error'); return; }
    
    const idA = await getSceneItemId(nameA);
    const idB = await getSceneItemId(nameB);
    
    if (!idA || !idB) { log('Source not found', 'error'); return; }
    
    isSwapping = true;
    log(`Swapping ${nameA} ‚Üî ${nameB}...`, 'info');
    
    try {
        const tA = await getTransform(idA);
        const tB = await getTransform(idB);
        
        const duration = parseInt(document.getElementById('swapDuration').value) || 300;
        const easing = document.getElementById('swapEasing').value;
        
        // Properties to swap
        const propsToSwap = ['positionX', 'positionY', 'boundsWidth', 'boundsHeight', 'scaleX', 'scaleY'];
        
        const startA = {}, startB = {}, endA = {}, endB = {};
        for (const p of propsToSwap) {
            startA[p] = tA[p];
            startB[p] = tB[p];
            endA[p] = tB[p];
            endB[p] = tA[p];
        }
        
        if (duration <= 0) {
            // Instant swap
            await setTransform(idA, endA);
            await setTransform(idB, endB);
        } else {
            // Animated swap
            const startTime = performance.now();
            
            await new Promise(resolve => {
                function animate() {
                    const elapsed = performance.now() - startTime;
                    const rawT = Math.min(elapsed / duration, 1);
                    const t = easeFunc(rawT, easing);
                    
                    const currentA = {}, currentB = {};
                    for (const p of propsToSwap) {
                        currentA[p] = lerp(startA[p], endA[p], t);
                        currentB[p] = lerp(startB[p], endB[p], t);
                    }
                    
                    Promise.all([
                        setTransform(idA, currentA),
                        setTransform(idB, currentB)
                    ]).then(() => {
                        if (rawT < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    });
                }
                requestAnimationFrame(animate);
            });
        }
        
        log(`Swapped ${nameA} ‚Üî ${nameB}`, 'success');
    } catch (e) {
        log('Swap error: ' + e, 'error');
    }
    
    isSwapping = false;
}

function saveCurrentSwap() {
    const nameA = document.getElementById('swapSourceA').value;
    const nameB = document.getElementById('swapSourceB').value;
    if (!nameA || !nameB) { log('Select both sources first', 'error'); return; }
    
    const name = prompt('Config name:', `${nameA} ‚Üî ${nameB}`);
    if (!name) return;
    
    swapConfigs.push({ name, sourceA: nameA, sourceB: nameB });
    localStorage.setItem('swapConfigs', JSON.stringify(swapConfigs));
    renderSavedSwaps();
    log(`Saved config: ${name}`, 'success');
}

function renderSavedSwaps() {
    const container = document.getElementById('savedSwaps');
    if (swapConfigs.length === 0) {
        container.innerHTML = '<div class="empty-state" style="padding:15px">No saved configs</div>';
    } else {
        container.innerHTML = swapConfigs.map((c, i) => `
            <div class="source-item">
                <div>
                    <div class="name">${c.name}</div>
                    <div class="type">${c.sourceA} ‚Üî ${c.sourceB}</div>
                </div>
                <div style="display:flex;gap:4px">
                    <button onclick="loadSwapConfig(${i})">‚ñ∂</button>
                    <button onclick="deleteSwapConfig(${i})">‚úï</button>
                </div>
            </div>
        `).join('');
    }
    renderDashSwaps();
}

function loadSwapConfig(index) {
    const c = swapConfigs[index];
    document.getElementById('swapSourceA').value = c.sourceA;
    document.getElementById('swapSourceB').value = c.sourceB;
    executeSwap();
}

function deleteSwapConfig(index) {
    swapConfigs.splice(index, 1);
    localStorage.setItem('swapConfigs', JSON.stringify(swapConfigs));
    renderSavedSwaps();
}

// ============ Text Cycler ============
function updateTextSourceDropdown() {
    const select = document.getElementById('textSource');
    const current = select.value;
    
    textSources = sources.filter(s => 
        s.inputKind && (s.inputKind.includes('text') || s.inputKind === 'text_gdiplus_v2' || s.inputKind === 'text_ft2_source_v2')
    );
    
    select.innerHTML = '<option value="">-- Select Text Source --</option>' +
        textSources.map(s => `<option value="${s.sourceName}">${s.sourceName}</option>`).join('');
    
    if (current && textSources.find(s => s.sourceName === current)) {
        select.value = current;
    }
}

async function loadTextSource() {
    const name = document.getElementById('textSource').value;
    if (!name) {
        document.getElementById('textPreview').textContent = 'Select a source';
        return;
    }
    
    try {
        const data = await request('GetInputSettings', { inputName: name });
        const text = data.inputSettings.text || '';
        document.getElementById('textPreview').textContent = text || '(empty)';
    } catch (e) {
        log('Error loading text: ' + e, 'error');
    }
}

async function setText(text) {
    const name = document.getElementById('textSource').value;
    if (!name) return;
    
    try {
        await request('SetInputSettings', {
            inputName: name,
            inputSettings: { text: text }
        });
        document.getElementById('textPreview').textContent = text;
    } catch (e) {
        log('Error setting text: ' + e, 'error');
    }
}

function getTextLines() {
    return document.getElementById('textLines').value
        .split('\n')
        .map(l => l.trim())
        .filter(l => l.length > 0);
}

function startTextCycle() {
    const lines = getTextLines();
    if (lines.length === 0) {
        log('Enter at least one text line', 'error');
        return;
    }
    if (!document.getElementById('textSource').value) {
        log('Select a text source first', 'error');
        return;
    }
    
    const duration = parseInt(document.getElementById('textDuration').value) || 3000;
    
    document.getElementById('startCycleBtn').disabled = true;
    document.getElementById('stopCycleBtn').disabled = false;
    
    cycleIndex = 0;
    showNextText(lines);
    
    cycleInterval = setInterval(() => {
        cycleIndex = (cycleIndex + 1) % lines.length;
        showNextText(lines);
    }, duration);
    
    log('Text cycling started', 'success');
}

function stopTextCycle() {
    if (cycleInterval) {
        clearInterval(cycleInterval);
        cycleInterval = null;
    }
    if (transitionFrame) {
        cancelAnimationFrame(transitionFrame);
        transitionFrame = null;
    }
    isTransitioning = false;
    
    document.getElementById('startCycleBtn').disabled = false;
    document.getElementById('stopCycleBtn').disabled = true;
    
    log('Text cycling stopped');
}

function showNextText(lines) {
    const target = lines[cycleIndex];
    const transition = document.getElementById('textTransition').value;
    const transDur = parseInt(document.getElementById('transDuration').value) || 500;
    
    if (transition === 'none') {
        setText(target);
    } else {
        animateTransition(target, transition, transDur);
    }
}

function animateTransition(target, type, duration) {
    if (isTransitioning) return;
    isTransitioning = true;
    
    const startTime = performance.now();
    
    function frame() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        let display = target;
        if (type === 'obfuscate') {
            display = obfuscateText(target, progress);
        } else if (type === 'typewriter') {
            display = target.substring(0, Math.floor(progress * target.length));
        } else if (type === 'glitch') {
            display = glitchText(target, progress);
        }
        
        setText(display);
        
        if (progress < 1) {
            transitionFrame = requestAnimationFrame(frame);
        } else {
            setText(target);
            isTransitioning = false;
        }
    }
    
    transitionFrame = requestAnimationFrame(frame);
}

function obfuscateText(target, progress) {
    const revealed = Math.floor(progress * target.length);
    let result = '';
    for (let i = 0; i < target.length; i++) {
        if (i < revealed) {
            result += target[i];
        } else if (target[i] === ' ') {
            result += ' ';
        } else {
            result += CHARS_ENCHANT[Math.floor(Math.random() * CHARS_ENCHANT.length)];
        }
    }
    return result;
}

function glitchText(target, progress) {
    const glitchChance = 1 - progress;
    let result = '';
    for (let i = 0; i < target.length; i++) {
        if (target[i] === ' ') {
            result += ' ';
        } else if (Math.random() < glitchChance * 0.5) {
            result += CHARS_GLITCH[Math.floor(Math.random() * CHARS_GLITCH.length)];
        } else {
            result += target[i];
        }
    }
    return result;
}

// ============ Keyboard Shortcuts ============
document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    // 1-9 triggers saved swap configs
    if (e.key >= '1' && e.key <= '9') {
        const idx = parseInt(e.key) - 1;
        if (idx < swapConfigs.length) loadSwapConfig(idx);
    }
    // Space toggles text cycler
    if (e.key === ' ') {
        e.preventDefault();
        cycleInterval ? stopTextCycle() : startTextCycle();
    }
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strixun's Stream Suite</title>
    <link rel="stylesheet" href="assets/css/control-panel.css">
    <!-- Auto-configuration (injected during deployment) -->
    <script src="config.js"></script>
    <!-- Storage System (must load first) -->
    <script src="assets/js/storage.js"></script>
    <!-- WebSocket/OBS Connection Module (depends on storage) -->
    <script src="assets/js/websocket.js"></script>
    <!-- Text Cycler Module -->
    <script src="assets/js/text-cycler.js"></script>
    <!-- Storage Sync Module -->
    <script src="assets/js/storage-sync.js"></script>
    <!-- Source Swaps Module -->
    <script src="assets/js/source-swaps.js"></script>
    <!-- Installer Module -->
    <script src="assets/js/modules/installer.js"></script>
    <!-- Source Management Module (depends on websocket) -->
    <script src="assets/js/modules/sources.js"></script>
</head>
<body>
    <div class="app">
        <header class="header">
            <h1><span class="status-dot" id="statusDot"></span><span class="title-text">Stream Suite</span></h1>
            <div style="display:flex;gap:4px">
                <button onclick="location.reload()" title="Reload Panel">üîÑ</button>
                <button onclick="showPage('setup')" id="connectHeaderBtn">Connect</button>
            </div>
        </header>
        
        <nav class="tabs">
            <button class="tab active" onclick="showPage('dashboard')" title="Dashboard">üè†</button>
            <button class="tab" onclick="showPage('sources')" title="Sources">üì¶</button>
            <button class="tab" onclick="showPage('text')" title="Text Cycler">üìù</button>
            <button class="tab" onclick="showPage('swaps')" title="Swaps">üîÑ</button>
            <button class="tab" onclick="showPage('layouts')" title="Layouts">üìê</button>
            <button class="tab" onclick="showPage('scripts')" title="Script Manager">üìú</button>
            <button class="tab" onclick="showPage('install')" title="Installer">üì•</button>
            <button class="tab" onclick="showPage('setup')" title="Setup">‚öôÔ∏è</button>
        </nav>
        
        <div class="split-container">
            <main class="split-main content">
                <!-- Dashboard -->
                <div id="page-dashboard" class="page active">
                <!-- Script Status Card -->
                <div class="card" id="dashboardStatusCard">
                    <h3>üìä System Status</h3>
                    <div id="dashboardScriptStatus">
                        <div class="script-status-grid">
                            <div class="script-status-item missing">
                                <span class="script-status-item__icon">üîå</span>
                                <span class="script-status-item__name">OBS Connection</span>
                                <span class="script-status-item__badge">Offline</span>
                            </div>
                        </div>
                        <p class="hint" style="margin-top:8px">
                            <button onclick="showPage('setup')" class="btn-link">‚öôÔ∏è Go to Setup</button> to connect to OBS WebSocket
                        </p>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Quick Actions</h3>
                    <div class="grid">
                        <button class="source-btn requires-connection" onclick="cycleAspect()">üîÑ Cycle Aspect</button>
                        <button class="source-btn requires-connection" onclick="refreshScenes()">üîÉ Refresh</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Current Scene</h3>
                    <div id="currentScene" class="empty-state">Connect to OBS first</div>
                </div>
                
                <div class="card">
                    <h3>Quick Swaps</h3>
                    <div class="grid" id="dashSwapGrid"></div>
                </div>
            </div>
            
            <!-- Sources -->
            <div id="page-sources" class="page">
                <div class="card">
                    <h3>Visibility Animation</h3>
                    <label>Animation Type</label>
                    <select id="visAnimType">
                        <option value="none">None (instant)</option>
                        <option value="fade" selected>Fade</option>
                        <option value="slide_left">Slide Left</option>
                        <option value="slide_right">Slide Right</option>
                        <option value="slide_up">Slide Up</option>
                        <option value="slide_down">Slide Down</option>
                        <option value="zoom">Zoom</option>
                        <option value="pop">Pop (overshoot)</option>
                    </select>
                    <div class="row" style="margin-top:8px">
                        <div>
                            <label>Duration (ms)</label>
                            <input type="number" id="visAnimDuration" value="300" min="50" max="2000" step="50">
                        </div>
                        <div>
                            <label>Easing</label>
                            <select id="visAnimEasing">
                                <option value="ease">Ease</option>
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut" selected>Ease Out</option>
                                <option value="bounce">Bounce</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Opacity Control -->
                <div class="card">
                    <h3>üéöÔ∏è Opacity Control</h3>
                    <label>Source</label>
                    <select id="opacitySourceSelect" onchange="loadSourceOpacity()">
                        <option value="">-- Select Source --</option>
                    </select>
                    <div style="margin-top:12px">
                        <div style="display:flex;align-items:center;gap:12px">
                            <input type="range" id="opacitySlider" class="opacity-slider" 
                                   min="0" max="100" value="100" 
                                   oninput="updateOpacityPreview()">
                            <span id="opacityValue" style="font-weight:700;font-size:1.4em;min-width:55px;text-align:right;color:var(--accent)">100%</span>
                        </div>
                    </div>
                    <div class="row" style="margin-top:12px">
                        <button onclick="applySourceOpacity()" style="flex:1">‚úÖ Apply</button>
                        <button onclick="resetSourceOpacity()" class="btn-secondary" style="flex:1">üîÑ Reset to 100%</button>
                    </div>
                    <p class="hint" style="margin-top:8px;font-size:0.75em;color:var(--muted)">
                        üí° Setting to 100% removes the filter (no overhead)
                    </p>
                </div>
                
                <!-- Scene Browser -->
                <div class="card">
                    <h3>üé¨ Scenes</h3>
                    <div class="search-box">
                        <input type="text" class="search-box__input" id="scenesSearchInput" placeholder="Search scenes...">
                        <span class="search-box__icon">üîç</span>
                        <button class="search-box__clear" title="Clear">‚úï</button>
                    </div>
                    <div id="scenesList" class="config-list" style="max-height:200px;overflow-y:auto"></div>
                    <button onclick="refreshSceneList()" class="btn-secondary" style="width:100%;margin-top:8px">üîÉ Refresh Scenes</button>
                </div>
                
                <!-- Source Browser -->
                <div class="card">
                    <h3>üì¶ Sources</h3>
                    <p class="hint" id="sourcesSceneLabel" style="margin-bottom:8px">Select a scene above to view sources</p>
                    <div class="search-box">
                        <input type="text" class="search-box__input" id="sourcesSearchInput" placeholder="Search sources...">
                        <span class="search-box__icon">üîç</span>
                        <button class="search-box__clear" title="Clear">‚úï</button>
                    </div>
                    <div id="sourcesList"></div>
                </div>
            </div>
            
            <!-- Text Cycler -->
            <div id="page-text" class="page">
                <!-- Saved Configs -->
                <div class="card">
                    <h3>üíæ Saved Configs</h3>
                    <div class="search-box">
                        <input type="text" class="search-box__input" id="textConfigsSearchInput" placeholder="Search configs...">
                        <span class="search-box__icon">üîç</span>
                        <button class="search-box__clear" title="Clear">‚úï</button>
                    </div>
                    <div id="textCyclerConfigs" class="config-list"></div>
                    <div class="row" style="margin-top:8px">
                        <button onclick="newTextConfig()">‚ûï New Config</button>
                        <button onclick="exportTextConfigs()">üì§ Export</button>
                        <button onclick="importTextConfigs()">üì• Import</button>
                    </div>
                </div>

                <!-- Config Editor -->
                <div class="card" id="textConfigEditor" style="display:none">
                    <h3>‚úèÔ∏è Edit Config</h3>
                    <label>Config Name</label>
                    <input type="text" id="textConfigName" placeholder="My Text Cycler">
                    
                    <label>Mode</label>
                    <select id="textCyclerMode" onchange="updateTextCyclerMode()">
                        <option value="browser">Browser Source (smooth CSS animations)</option>
                        <option value="legacy">Legacy (OBS text source)</option>
                    </select>
                    <p id="modeInfo" style="font-size:0.75em;color:var(--muted);margin:4px 0 8px"></p>
                    
                    <div id="browserModeSettings">
                        <label>Config ID (for browser source URL)</label>
                        <div class="url-box">
                            <input type="text" id="textConfigId" placeholder="config1" style="flex:1" oninput="updateBrowserSourceUrlPreview()">
                            <button onclick="copyBrowserSourceUrl()">üìã Copy URL</button>
                        </div>
                        <p style="font-size:0.7em;color:var(--muted);margin-top:4px">
                            Add as OBS Browser Source: <code id="browserSourceUrlPreview"></code>
                        </p>
                    </div>
                    
                    <div id="legacyModeSettings" style="display:none">
                        <label>Text Source</label>
                        <select id="textSource" onchange="loadTextSource()">
                            <option value="">-- Select Text Source --</option>
                        </select>
                    </div>
                </div>

                <!-- Text Lines -->
                <div class="card" id="textLinesCard" style="display:none">
                    <h3>üìù Text Lines</h3>
                    <textarea id="textLines" placeholder="Enter text lines (one per line)&#10;Line 1&#10;Line 2&#10;Line 3" rows="5"></textarea>
                </div>
                
                <!-- Animation Settings -->
                <div class="card" id="textAnimationCard" style="display:none">
                    <h3>üé¨ Animation</h3>
                    <label>Transition Effect</label>
                    <select id="textTransition" onchange="updateTransitionMode()">
                        <option value="none">None (instant)</option>
                        <option value="fade">Fade</option>
                        <option value="obfuscate">Obfuscate (Minecraft enchant)</option>
                        <option value="typewriter">Typewriter</option>
                        <option value="glitch">Glitch</option>
                        <option value="scramble">Scramble ‚Üí Snap</option>
                        <option value="wave">Wave Reveal</option>
                        <option value="slide_left">Slide Left</option>
                        <option value="slide_right">Slide Right</option>
                        <option value="slide_up">Slide Up</option>
                        <option value="slide_down">Slide Down</option>
                        <option value="pop">Pop</option>
                    </select>
                    <p id="transitionInfo" style="font-size:0.75em;color:var(--muted);margin:4px 0 12px"></p>
                    <div class="row">
                        <div>
                            <label>Transition (ms)</label>
                            <input type="number" id="transDuration" value="500" min="100" max="3000" step="50">
                        </div>
                        <div>
                            <label>Cycle (ms)</label>
                            <input type="number" id="textDuration" value="3000" min="500" step="100">
                        </div>
                    </div>
                </div>

                <!-- Style Settings (Browser Mode Only) -->
                <div class="card" id="textStyleCard" style="display:none">
                    <h3>üé® Style (Browser Mode)</h3>
                    
                    <label>Font Family</label>
                    <select id="textFontFamily">
                        <option value="'Segoe UI', system-ui, sans-serif">Segoe UI (Default)</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="'Helvetica Neue', Helvetica, sans-serif">Helvetica</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="'Times New Roman', serif">Times New Roman</option>
                        <option value="'Courier New', monospace">Courier New</option>
                        <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                        <option value="Impact, sans-serif">Impact</option>
                        <option value="'Comic Sans MS', cursive">Comic Sans</option>
                    </select>
                    <input type="text" id="textFontFamilyCustom" placeholder="Or enter custom font: 'Font Name', fallback" style="margin-top:4px">
                    
                    <div class="row" style="margin-top:12px">
                        <div>
                            <label>Font Size</label>
                            <input type="text" id="textFontSize" value="48px" placeholder="48px">
                        </div>
                        <div>
                            <label>Font Weight</label>
                            <select id="textFontWeight">
                                <option value="100">Thin</option>
                                <option value="300">Light</option>
                                <option value="400">Normal</option>
                                <option value="500">Medium</option>
                                <option value="600">Semi-Bold</option>
                                <option value="700" selected>Bold</option>
                                <option value="800">Extra Bold</option>
                                <option value="900">Black</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="row">
                        <div>
                            <label>Text Color</label>
                            <div style="display:flex;gap:4px">
                                <input type="color" id="textColorPicker" value="#ffffff" style="width:40px;height:32px;padding:0;border:none;cursor:pointer">
                                <input type="text" id="textColor" value="#ffffff" placeholder="#ffffff" style="flex:1">
                            </div>
                        </div>
                        <div>
                            <label>Text Align</label>
                            <select id="textAlign">
                                <option value="center" selected>Center</option>
                                <option value="left">Left</option>
                                <option value="right">Right</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="row">
                        <div>
                            <label>Letter Spacing</label>
                            <input type="text" id="textLetterSpacing" value="normal" placeholder="normal, 2px, 0.1em">
                        </div>
                        <div>
                            <label>Line Height</label>
                            <input type="text" id="textLineHeight" value="1.2" placeholder="1.2, 1.5, 2">
                        </div>
                    </div>
                    
                    <div class="row">
                        <div>
                            <label>Text Transform</label>
                            <select id="textTransform">
                                <option value="none" selected>None</option>
                                <option value="uppercase">UPPERCASE</option>
                                <option value="lowercase">lowercase</option>
                                <option value="capitalize">Capitalize</option>
                            </select>
                        </div>
                        <div>
                            <label>Font Style</label>
                            <select id="textFontStyle">
                                <option value="normal" selected>Normal</option>
                                <option value="italic">Italic</option>
                            </select>
                        </div>
                    </div>
                    
                    <label>Text Shadow</label>
                    <input type="text" id="textShadow" value="2px 2px 4px rgba(0,0,0,0.5)" placeholder="2px 2px 4px rgba(0,0,0,0.5)">
                    
                    <label style="margin-top:8px">Text Stroke (Outline)</label>
                    <div class="row">
                        <div>
                            <input type="text" id="textStrokeWidth" value="0" placeholder="Width: 0, 1px, 2px">
                        </div>
                        <div>
                            <div style="display:flex;gap:4px">
                                <input type="color" id="textStrokeColorPicker" value="#000000" style="width:40px;height:32px;padding:0;border:none;cursor:pointer">
                                <input type="text" id="textStrokeColor" value="#000000" placeholder="#000000" style="flex:1">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Preview -->
                <div class="card" id="textPreviewCard" style="display:none">
                    <h3>üëÅÔ∏è Preview</h3>
                    <div class="text-preview" id="textPreview">Select or create a config</div>
                </div>
                
                <!-- Controls -->
                <div id="textControls" style="display:none">
                    <div class="row">
                        <button class="btn-success btn-lg" id="startCycleBtn" onclick="startTextCycler()">‚ñ∂ Start</button>
                        <button class="btn-danger btn-lg" id="stopCycleBtn" onclick="stopTextCycler()" disabled>‚ñ† Stop</button>
                    </div>
                    <div class="row" style="margin-top:8px">
                        <button onclick="saveCurrentTextConfig()">üíæ Save Config</button>
                        <button onclick="deleteCurrentTextConfig()" style="background:var(--danger);border-color:var(--danger)">üóëÔ∏è Delete</button>
                    </div>
                </div>
            </div>
            
            <!-- Swaps -->
            <div id="page-swaps" class="page">
                <div class="card">
                    <h3>Quick Swap</h3>
                    <p style="color:var(--muted);margin-bottom:12px;font-size:0.85em">Select two sources and swap their position/size</p>
                    <label>Source A</label>
                    <select id="swapSourceA"></select>
                    <label>Source B</label>
                    <select id="swapSourceB"></select>
                    <div class="row" style="margin-top:8px">
                        <button class="btn-primary btn-lg" onclick="executeSwap()">üîÑ Swap Now</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Animation</h3>
                    <label>Style</label>
                    <select id="swapStyle">
                        <option value="slide" selected>Slide (smooth move)</option>
                        <option value="teleport">Teleport (instant)</option>
                        <option value="scale">Scale (shrink/grow)</option>
                        <option value="bounce">Bounce (overshoot)</option>
                        <option value="elastic">Elastic (springy)</option>
                        <option value="arc">Arc (curved path)</option>
                    </select>
                    <div class="row">
                        <div>
                            <label>Duration (ms)</label>
                            <input type="number" id="swapDuration" value="400" min="0" max="3000" step="50">
                        </div>
                        <div>
                            <label>Easing</label>
                            <select id="swapEasing">
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut">Ease Out</option>
                                <option value="ease" selected>Ease In-Out</option>
                                <option value="back">Back (overshoot)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div style="margin-top:12px">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                            <input type="checkbox" id="swapPreserveAspect" checked>
                            <span>Preserve Aspect Ratio (default)</span>
                        </label>
                    </div>
                    
                    <div style="margin-top:8px">
                        <label>‚ö° Temporary Override</label>
                        <select id="swapTempOverride">
                            <option value="off" selected>Off (use config/global)</option>
                            <option value="preserve">Preserve</option>
                            <option value="stretch">Stretch</option>
                        </select>
                        <p style="font-size:0.75em;color:var(--muted);margin:4px 0 0">Force Preserve or Stretch for ALL swaps until set back to Off</p>
                    </div>
                    
                    <div style="margin-top:8px">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                            <input type="checkbox" id="swapDebugLogging">
                            <span>Debug Logging</span>
                        </label>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Add Swap Config</h3>
                    <label>Config Name</label>
                    <input type="text" id="swapConfigName" placeholder="e.g. Camera ‚Üî Gameplay">
                    <div class="row" style="margin-top:8px">
                        <div style="flex:1">
                            <label>Source A</label>
                            <select id="swapNewSourceA"></select>
                        </div>
                        <div style="flex:1">
                            <label>Source B</label>
                            <select id="swapNewSourceB"></select>
                        </div>
                    </div>
                    <button class="btn-primary" style="margin-top:12px;width:100%" onclick="addSwapConfig()">‚ûï Add Config</button>
                </div>
                
                <div class="card">
                    <h3>Saved Configs</h3>
                    <div class="search-box">
                        <input type="text" class="search-box__input" id="swapConfigsSearchInput" placeholder="Search configs...">
                        <span class="search-box__icon">üîç</span>
                        <button class="search-box__clear" title="Clear">‚úï</button>
                    </div>
                    <div id="savedSwaps"></div>
                    <div class="row" style="margin-top:8px">
                        <button onclick="refreshSwapSources()">üîÑ Refresh Sources</button>
                        <button onclick="exportConfigs()">üì§ Export</button>
                        <button onclick="importConfigs()">üì• Import</button>
                    </div>
                </div>
            </div>
            
            <!-- Layouts -->
            <div id="page-layouts" class="page">
                <div class="card">
                    <h3>üíæ Save Current Layout</h3>
                    <p style="color:var(--muted);margin-bottom:12px;font-size:0.85em">
                        Capture all source positions/sizes in current scene
                    </p>
                    <label>Layout Name</label>
                    <input type="text" id="layoutName" placeholder="e.g. Gaming Layout, Just Chatting">
                    <button class="btn-primary" style="margin-top:12px;width:100%" onclick="captureLayout()">
                        üì∏ Capture Current Layout
                    </button>
                </div>
                
                <div class="card">
                    <h3>üìÇ Saved Layouts</h3>
                    <p style="color:var(--muted);margin-bottom:8px;font-size:0.85em" id="layoutSceneInfo">
                        Scene: <span id="layoutCurrentScene">-</span>
                    </p>
                    <div class="search-box">
                        <input type="text" class="search-box__input" id="layoutSearchInput" placeholder="Search layouts...">
                        <span class="search-box__icon">üîç</span>
                        <button class="search-box__clear" title="Clear">‚úï</button>
                    </div>
                    <div id="savedLayouts" class="config-list"></div>
                    <div class="row" style="margin-top:8px">
                        <button onclick="refreshLayouts()">üîÑ Refresh</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>‚öôÔ∏è Animation Settings</h3>
                    <div class="row">
                        <div style="flex:1">
                            <label>Duration (ms)</label>
                            <input type="number" id="layoutDuration" value="500" min="100" max="2000" step="50">
                        </div>
                        <div style="flex:1">
                            <label>Easing</label>
                            <select id="layoutEasing">
                                <option value="ease_out" selected>Ease Out</option>
                                <option value="ease_in_out">Ease In/Out</option>
                                <option value="ease_in">Ease In</option>
                                <option value="linear">Linear</option>
                                <option value="bounce">Bounce</option>
                                <option value="elastic">Elastic</option>
                                <option value="back">Back</option>
                            </select>
                        </div>
                    </div>
                    <div style="margin-top:8px">
                        <label>Stagger (ms)</label>
                        <input type="number" id="layoutStagger" value="0" min="0" max="200" step="10">
                        <p style="font-size:0.75em;color:var(--muted);margin:4px 0 0">
                            Delay between each source animation (0 = all at once)
                        </p>
                    </div>
                    <div style="margin-top:12px">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                            <input type="checkbox" id="layoutApplyVisibility" checked>
                            <span>Apply visibility changes</span>
                        </label>
                    </div>
                </div>
                
                <div class="card">
                    <h3>‚ÑπÔ∏è How It Works</h3>
                    <ol style="padding-left:20px;color:var(--muted);font-size:0.85em;margin:0">
                        <li>Arrange sources how you want them</li>
                        <li>Enter a name and click "Capture"</li>
                        <li>Rearrange sources or change layouts</li>
                        <li>Click "Apply" to animate back</li>
                    </ol>
                    <p style="color:var(--muted);font-size:0.8em;margin-top:8px">
                        üí° <b>Tip:</b> Assign hotkeys in OBS ‚Üí Settings ‚Üí Hotkeys for quick switching!
                    </p>
                </div>
            </div>
            
            <!-- Script Manager -->
            <div id="page-scripts" class="page">
                <div class="card">
                    <h3>üìú Stream Suite Scripts</h3>
                    <p class="hint" style="margin-bottom:12px">Lua scripts that run inside OBS Studio. Install via the Installer tab.</p>
                    
                    <div id="scriptsList" class="scripts-grid"></div>
                </div>
                
                <div class="card">
                    <h3>üåê Browser Sources</h3>
                    <p class="hint" style="margin-bottom:12px">HTML files to add as Browser Sources in OBS.</p>
                    
                    <div class="scripts-grid">
                        <div class="script-card">
                            <div class="script-header">
                                <span class="script-icon">üé¨</span>
                                <div>
                                    <div class="script-name">Text Cycler Display</div>
                                    <div class="script-version">Browser Source</div>
                                </div>
                            </div>
                            <p class="script-desc">Beautiful CSS-animated text display. Receives messages from the control panel for smooth text cycling effects.</p>
                            <div class="script-file">text_cycler_display.html</div>
                        </div>
                        
                        <div class="script-card">
                            <div class="script-header">
                                <span class="script-icon">üéõÔ∏è</span>
                                <div>
                                    <div class="script-name">Control Panel Dock</div>
                                    <div class="script-version">Custom Dock</div>
                                </div>
                            </div>
                            <p class="script-desc">This control panel! Add as a Custom Browser Dock in OBS for quick access to all features.</p>
                            <div class="script-file">control_panel.html</div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>üìñ Quick Reference</h3>
                    <div class="info-box">
                        <strong>Adding Scripts to OBS:</strong>
                        <ol style="margin:8px 0 0 16px;font-size:0.85em">
                            <li>Tools ‚Üí Scripts</li>
                            <li>Click + (Add Scripts)</li>
                            <li>Navigate to your script folder</li>
                            <li>Select the .lua files</li>
                        </ol>
                    </div>
                    <div class="info-box" style="margin-top:8px">
                        <strong>Adding Custom Browser Dock:</strong>
                        <ol style="margin:8px 0 0 16px;font-size:0.85em">
                            <li>View ‚Üí Docks ‚Üí Custom Browser Docks</li>
                            <li>Name: "Stream Suite"</li>
                            <li>URL: file:///path/to/control_panel.html</li>
                        </ol>
                    </div>
                </div>
            </div>
            
            <!-- Installer Wizard -->
            <div id="page-install" class="page">
                <div class="card">
                    <h3>üì• Installation Wizard</h3>
                    <p class="hint">Automatically install Lua scripts to your OBS scripts folder.</p>
                    
                    <!-- Step 1: Detect/Select Paths -->
                    <div id="installStep1" class="install-step active">
                        <h4>Step 1: Configure Paths</h4>
                        
                        <label>Source Files Location</label>
                        <div class="url-box">
                            <input type="text" id="installSourcePath" readonly>
                            <button onclick="window.Installer.detectSourcePath()">üîç Detect</button>
                        </div>
                        <p class="hint">Where the script files are located (this folder)</p>
                        
                        <label>OBS Scripts Folder</label>
                        <div class="url-box">
                            <input type="text" id="installTargetPath" placeholder="C:\Users\YourName\AppData\Roaming\obs-studio\scripts">
                            <button onclick="window.Installer.browseTargetPath()">üìÅ Browse</button>
                            <button onclick="window.Installer.detectOBSPath()">üîç Auto-Detect</button>
                        </div>
                        <p class="hint">Where scripts will be installed. Common locations:</p>
                        <div class="path-suggestions" id="pathSuggestions"></div>
                        
                        <div class="row" style="margin-top:12px">
                            <button onclick="window.Installer.goToInstallStep(2)" class="btn-primary">Next: Select Scripts ‚Üí</button>
                        </div>
                    </div>
                    
                    <!-- Step 2: Select Scripts -->
                    <div id="installStep2" class="install-step">
                        <h4>Step 2: Select Scripts to Install</h4>
                        
                        <div id="installScriptsList" class="install-scripts-list"></div>
                        
                        <div class="row" style="margin-top:12px">
                            <button onclick="window.Installer.goToInstallStep(1)">‚Üê Back</button>
                            <button onclick="window.Installer.goToInstallStep(3)" class="btn-primary">Next: Review ‚Üí</button>
                        </div>
                    </div>
                    
                    <!-- Step 3: Review & Install -->
                    <div id="installStep3" class="install-step">
                        <h4>Step 3: Review & Install</h4>
                        
                        <div id="installReview" class="install-review"></div>
                        
                        <div class="install-method-select" style="margin-top:12px">
                            <label>Installation Method</label>
                            <select id="installMethod">
                                <option value="powershell">PowerShell Script (Windows)</option>
                                <option value="batch">Batch File (Windows)</option>
                                <option value="bash">Bash Script (Linux/Mac)</option>
                                <option value="manual">Manual Instructions</option>
                            </select>
                        </div>
                        
                        <div class="row" style="margin-top:12px">
                            <button onclick="window.Installer.goToInstallStep(2)">‚Üê Back</button>
                            <button onclick="window.Installer.generateInstallScript()" class="btn-primary">Generate Install Script</button>
                        </div>
                    </div>
                    
                    <!-- Step 4: Execute/Copy Script -->
                    <div id="installStep4" class="install-step">
                        <h4>Step 4: Run Installation</h4>
                        
                        <div id="installOutput" class="install-output"></div>
                        
                        <!-- Dock Warning -->
                        <div id="dockDownloadWarning" class="feature-notice" style="display:none;margin-bottom:12px">
                            <div class="feature-notice__title">‚ö†Ô∏è OBS Dock Detected</div>
                            <div class="feature-notice__text">
                                File downloads don't work in OBS docks. Use <strong>Copy Script</strong> instead, 
                                then paste into a text editor and save manually.
                            </div>
                        </div>
                        
                        <div class="row" style="margin-top:12px">
                            <button onclick="window.Installer.goToInstallStep(3)">‚Üê Back</button>
                            <button onclick="window.Installer.copyInstallScript()" class="btn-success">üìã Copy Script</button>
                            <button onclick="window.Installer.downloadInstallScript()" id="downloadScriptBtn" class="btn-primary" title="Download install script">üíæ Download</button>
                        </div>
                        
                        <!-- Browser Instructions (shown when NOT in dock) -->
                        <div id="browserInstructions" class="info-box" style="margin-top:12px">
                            <strong>After downloading:</strong>
                            <ol style="margin:4px 0 0 16px;font-size:0.85em">
                                <li>Right-click the downloaded script</li>
                                <li>Run as Administrator (Windows) or chmod +x && run (Linux/Mac)</li>
                                <li>Restart OBS Studio</li>
                                <li>Go to Tools ‚Üí Scripts to configure</li>
                            </ol>
                        </div>
                        
                        <!-- Dock Instructions (shown when IN dock) -->
                        <div id="dockInstructions" class="info-box" style="display:none;margin-top:12px">
                            <strong>üìã After copying the script:</strong>
                            <ol style="margin:4px 0 0 16px;font-size:0.85em">
                                <li>Open Notepad, VS Code, or any text editor</li>
                                <li>Paste the script (Ctrl+V)</li>
                                <li>Save as <code>.ps1</code> (PowerShell), <code>.bat</code> (Batch), or <code>.sh</code> (Bash)</li>
                                <li>Run the saved file as Administrator</li>
                                <li>Restart OBS Studio</li>
                            </ol>
                            <p style="margin-top:8px;font-size:0.85em;color:var(--muted)">
                                üí° <strong>Tip:</strong> Open this control panel in your regular browser for easier downloading!
                            </p>
                        </div>
                    </div>
                </div>
                
                <!-- Existing Installation Detection -->
                <div class="card" id="existingInstallCard" style="display:none">
                    <h3>‚ö†Ô∏è Existing Installation Detected</h3>
                    <div id="existingInstallInfo"></div>
                    <div class="row" style="margin-top:12px">
                        <button onclick="window.Installer.handleExistingInstall('skip')">Skip Existing</button>
                        <button onclick="window.Installer.handleExistingInstall('backup')" class="btn-warning">Backup & Replace</button>
                        <button onclick="window.Installer.handleExistingInstall('replace')" class="btn-danger">Replace All</button>
                    </div>
                </div>
                
            </div>
            
            <!-- Setup -->
            <div id="page-setup" class="page">
                <div class="card">
                    <h3>Connection</h3>
                    <div class="row">
                        <div>
                            <label>Host</label>
                            <input type="text" id="host" value="localhost">
                        </div>
                        <div>
                            <label>Port</label>
                            <input type="text" id="port" value="4455">
                        </div>
                    </div>
                    <label>Password</label>
                    <input type="password" id="password" placeholder="Leave empty if not set">
                    <div style="margin:8px 0">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                            <input type="checkbox" id="rememberCreds" style="width:auto;margin:0">
                            <span>Remember credentials</span>
                        </label>
                        <p style="font-size:0.75em;color:var(--warning);margin-top:4px" id="securityWarning"></p>
                        <button type="button" onclick="clearSavedCredentials()" style="font-size:0.75em;padding:4px 8px;margin-top:4px;background:var(--danger);border:none;color:#fff;border-radius:4px;cursor:pointer">Clear Saved Credentials</button>
                    </div>
                    <button class="btn-primary btn-block" id="connectBtn" onclick="toggleConnection()">Connect</button>
                </div>
                
                <div class="card">
                    <h3>Add as OBS Dock</h3>
                    <p style="color:var(--muted);margin-bottom:12px;font-size:0.9em">
                        In OBS: <strong>View ‚Üí Docks ‚Üí Custom Browser Docks</strong><br>
                        Click + and paste this URL:
                    </p>
                    <div class="url-box">
                        <input type="text" id="dockUrl" readonly>
                        <button onclick="copyUrl()">üìã Copy</button>
                    </div>
                    <p style="color:var(--muted);margin-top:8px;font-size:0.85em" id="copyStatus"></p>
                </div>
                
                <div class="card">
                    <h3>OBS WebSocket Setup</h3>
                    <ol style="color:var(--muted);padding-left:20px;font-size:0.9em;line-height:2">
                        <li>In OBS: <strong>Tools ‚Üí WebSocket Server Settings</strong></li>
                        <li>Check "Enable WebSocket server"</li>
                        <li>Note the port (default: 4455)</li>
                        <li>Set password if desired</li>
                        <li>Click Apply, then connect here</li>
                    </ol>
                </div>
                
                <div class="card">
                    <h3>üéÆ Twitch API Settings</h3>
                    <p style="color:var(--muted);font-size:0.85em;margin-bottom:12px">
                        Get credentials from 
                        <button onclick="openUrlOrCopy('https://dev.twitch.tv/console/apps', 'Twitch Developer Console')" class="btn-link">dev.twitch.tv/console</button>
                    </p>
                    
                    <label>Twitch Client ID <span style="color:var(--muted);font-weight:normal">(Optional - Auto-configured)</span></label>
                    <input type="text" id="twitchClientId" placeholder="Auto-configured from deployment">
                    <p class="hint" style="margin-top:4px;font-size:0.75em">
                        ‚ú® Auto-configured during deployment. Only override if using a different Twitch app.
                        <span id="autoDetectedClientId" style="display:block;margin-top:4px;color:var(--success)"></span>
                    </p>
                    
                    <label style="margin-top:12px">API Server URL <span style="color:var(--muted);font-weight:normal">(Optional - Auto-detected)</span></label>
                    <input type="text" id="twitchApiServer" placeholder="Auto-detected from deployment config">
                    <p class="hint" style="margin-top:4px;font-size:0.75em">
                        ‚ú® Auto-configured during GitHub Pages deployment. Only override if using a custom Worker URL.
                        <span id="autoDetectedApiUrl" style="display:block;margin-top:4px;color:var(--success)"></span>
                    </p>
                    
                    <div style="margin-top:12px;padding:8px;background:rgba(255,255,255,0.05);border-radius:6px;font-size:0.8em">
                        <strong style="color:var(--accent)">OAuth Redirect URI:</strong>
                        <code style="display:block;margin-top:4px;padding:6px;background:var(--bg);border-radius:4px;word-break:break-all;user-select:all">https://underwood-inc.github.io/strixun-stream-suite/twitch_auth_callback.html</code>
                        <p style="color:var(--muted);margin-top:4px">‚òùÔ∏è Add this URL to your Twitch app's OAuth Redirect URLs</p>
                    </div>
                    
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:12px">
                        <button onclick="saveTwitchSettings()" style="padding:8px;background:var(--primary);border:none;color:#fff;border-radius:6px;cursor:pointer">üíæ Save Settings</button>
                        <button onclick="testTwitchApi()" style="padding:8px;background:rgba(255,255,255,0.1);border:none;color:#fff;border-radius:6px;cursor:pointer">üîå Test Connection</button>
                    </div>
                    <div id="twitchApiStatus" style="margin-top:8px;font-size:0.8em;text-align:center;color:var(--muted)"></div>
                </div>
                
                <div class="card">
                    <h3>Keyboard Shortcuts</h3>
                    <p style="color:var(--muted);font-size:0.9em">When this panel is focused:</p>
                    <ul style="color:var(--muted);padding-left:20px;font-size:0.9em;line-height:2">
                        <li><strong>1-9</strong> - Trigger saved swap configs</li>
                        <li><strong>Space</strong> - Start/stop text cycler</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h3>üîÑ Cross-Client Sync</h3>
                    <p style="color:var(--muted);font-size:0.85em;margin-bottom:8px">
                        Sync configs between OBS dock and remote browser panels via WebSocket.
                    </p>
                    <div style="display:grid;gap:8px">
                        <button class="btn-primary btn-block requires-connection" onclick="requestStorageFromOBS()">
                            üì• Pull Storage from OBS Dock
                        </button>
                        <button class="btn-block requires-connection" onclick="manualStorageSync()" style="background:var(--border)">
                            üì° Push Storage to Other Clients
                        </button>
                    </div>
                    <p class="hint" style="margin-top:6px">
                        <strong>Pull</strong> = Overwrite local with OBS dock's storage<br>
                        <strong>Push</strong> = Send your storage to other clients
                    </p>
                    <div class="form-check" style="margin-top:8px">
                        <input type="checkbox" id="autoSyncOnConnect" checked onchange="saveAutoSyncPref()">
                        <label for="autoSyncOnConnect">Auto-pull from OBS on connect</label>
                    </div>
                </div>
                
                <div class="card">
                    <h3>üíæ Data & Backup</h3>
                    
                    <!-- Storage Engine Status -->
                    <div id="storageEngineStatus" style="display:flex;gap:12px;margin-bottom:12px;padding:8px;background:rgba(0,0,0,0.2);border-radius:6px;font-size:0.85em">
                        <span id="idbStatus">‚è≥ IndexedDB</span>
                        <span id="lsStatus">‚è≥ localStorage</span>
                    </div>
                    
                    <!-- Data Categories -->
                    <div style="margin-bottom:12px">
                        <div style="font-size:0.8em;color:var(--muted);margin-bottom:6px;font-weight:600">SELECT DATA TO EXPORT:</div>
                        <div style="display:grid;gap:6px">
                            <label style="display:flex;align-items:center;gap:8px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:4px;cursor:pointer;font-size:0.85em">
                                <input type="checkbox" id="exportSwaps" checked style="width:auto;margin:0">
                                <span>üîÑ Swap Configs</span>
                                <span id="swapCount" style="margin-left:auto;color:var(--muted);font-size:0.9em">(0)</span>
                            </label>
                            <label style="display:flex;align-items:center;gap:8px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:4px;cursor:pointer;font-size:0.85em">
                                <input type="checkbox" id="exportLayouts" checked style="width:auto;margin:0">
                                <span>üìê Layout Presets</span>
                                <span id="layoutCount" style="margin-left:auto;color:var(--muted);font-size:0.9em">(0)</span>
                            </label>
                            <label style="display:flex;align-items:center;gap:8px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:4px;cursor:pointer;font-size:0.85em">
                                <input type="checkbox" id="exportTextCyclers" checked style="width:auto;margin:0">
                                <span>üìù Text Cycler Configs</span>
                                <span id="textCyclerCount" style="margin-left:auto;color:var(--muted);font-size:0.9em">(0)</span>
                            </label>
                            <label style="display:flex;align-items:center;gap:8px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:4px;cursor:pointer;font-size:0.85em">
                                <input type="checkbox" id="exportUIState" checked style="width:auto;margin:0">
                                <span>‚öôÔ∏è UI Preferences</span>
                                <span style="margin-left:auto;color:var(--muted);font-size:0.9em">(dropdowns, settings)</span>
                            </label>
                            <label style="display:flex;align-items:center;gap:8px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:4px;cursor:pointer;font-size:0.85em">
                                <input type="checkbox" id="exportCredentials" style="width:auto;margin:0">
                                <span>üîê Connection Settings</span>
                                <span style="margin-left:auto;color:var(--warning);font-size:0.8em">(host/port only)</span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px">
                        <button onclick="exportSelectedData()" style="padding:10px;background:var(--primary);border:none;color:#fff;border-radius:6px;cursor:pointer;font-weight:500">üì§ Export Selected</button>
                        <button onclick="importDataWithOptions()" style="padding:10px;background:var(--accent);border:none;color:#000;border-radius:6px;cursor:pointer;font-weight:500">üì• Import Backup</button>
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                        <button onclick="forceStorageSync()" style="padding:8px;background:rgba(255,255,255,0.1);border:none;color:#fff;border-radius:6px;cursor:pointer;font-size:0.85em">üîÑ Force Sync</button>
                        <button onclick="copyBackupToClipboard()" style="padding:8px;background:rgba(255,255,255,0.1);border:none;color:#fff;border-radius:6px;cursor:pointer;font-size:0.85em">üìã Copy as JSON</button>
                    </div>
                    
                    <!-- Info -->
                    <div style="margin-top:10px;padding:8px;background:rgba(255,200,0,0.1);border-radius:6px;border-left:3px solid var(--warning)">
                        <p style="font-size:0.75em;color:var(--warning);margin:0">‚ö†Ô∏è <strong>OBS browser docks can lose data</strong> when cache is cleared. Export backups regularly!</p>
                    </div>
                    
                    <!-- Last backup info -->
                    <div id="lastBackupInfo" style="margin-top:8px;font-size:0.75em;color:var(--muted);text-align:center"></div>
                </div>
                
                <!-- Version Info -->
                <div class="card">
                    <h3>üì¶ Version</h3>
                    <div id="versionInfo" style="font-size:0.9em">
                        <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid rgba(255,255,255,0.1)">
                            <span style="color:var(--muted)">Local Version:</span>
                            <span id="localVersion" style="font-weight:600;font-family:monospace">--</span>
                        </div>
                        <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid rgba(255,255,255,0.1)">
                            <span style="color:var(--muted)">Remote (main):</span>
                            <span id="remoteVersion" style="font-weight:600;font-family:monospace">--</span>
                        </div>
                        <div id="versionStatus" style="margin-top:10px;padding:8px;border-radius:6px;text-align:center;font-size:0.85em">
                            <span style="color:var(--muted)">Click below to check for updates</span>
                        </div>
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:12px">
                        <button onclick="checkForUpdates()" style="padding:8px;background:var(--primary);border:none;color:#fff;border-radius:6px;cursor:pointer;font-size:0.85em">üîÑ Check Updates</button>
                        <button onclick="openGitHubRepo()" style="padding:8px;background:rgba(255,255,255,0.1);border:none;color:#fff;border-radius:6px;cursor:pointer;font-size:0.85em">üêô Open GitHub</button>
                    </div>
                    <div style="margin-top:10px;font-size:0.75em;color:var(--muted);text-align:center">
                        <span id="lastVersionCheck">Never checked</span>
                    </div>
                </div>
            </div>
            </main>
            
            <!-- Draggable Divider -->
            <div class="split-divider" id="splitDivider" title="Drag to resize"></div>
            
            <!-- Persistent Activity Log Panel -->
            <div class="split-log" id="splitLog">
                <div class="split-log__header">
                    <button class="split-log__toggle" id="logToggle" title="Toggle Log">‚ñº</button>
                    <span class="split-log__title">Activity Log</span>
                    <div class="search-box split-log__search">
                        <input type="text" class="search-box__input" id="logSearchInput" placeholder="Search log...">
                        <span class="search-box__icon">üîç</span>
                        <button class="search-box__clear" id="logSearchClear" title="Clear search">‚úï</button>
                    </div>
                    <button class="split-log__clear btn-link" onclick="clearLog()">Clear</button>
                </div>
                <div class="split-log__content" id="log"></div>
            </div>
        </div>
    </div>

<script>
// ============ Storage System ============
// Storage system is loaded from assets/js/storage.js
// All functions (initIndexedDB, loadStorageCache, createRecoverySnapshot, etc.)
// and the 'storage' object are already available globally from that file
// No aliases needed - use them directly!

// ============ Storage Backup & Status Functions ============
function updateStorageStatus() {
    // Update engine status indicators
    const idbEl = document.getElementById('idbStatus');
    const lsEl = document.getElementById('lsStatus');
    
    if (idbEl) {
        const idbReady = window.SSS_Storage.idbReady();
        idbEl.textContent = idbReady ? '‚úÖ IndexedDB' : '‚ùå IndexedDB';
        idbEl.style.color = idbReady ? 'var(--success)' : 'var(--danger)';
    }
    
    if (lsEl) {
        const lsWorks = (() => {
            try {
                localStorage.setItem('_test', '1');
                localStorage.removeItem('_test');
                return true;
            } catch (e) { return false; }
        })();
        lsEl.textContent = lsWorks ? '‚úÖ localStorage' : '‚ùå localStorage';
        lsEl.style.color = lsWorks ? 'var(--success)' : 'var(--danger)';
    }
    
    // Update config counts
    const swapCountEl = document.getElementById('swapCount');
    const layoutCountEl = document.getElementById('layoutCount');
    const textCyclerCountEl = document.getElementById('textCyclerCount');
    
    if (swapCountEl) swapCountEl.textContent = `(${swapConfigs?.length || 0})`;
    if (layoutCountEl) layoutCountEl.textContent = `(${layoutPresets?.length || 0})`;
    if (textCyclerCountEl) {
        const count = window.TextCycler ? window.TextCycler.getConfigs().length : 0;
        textCyclerCountEl.textContent = `(${count})`;
    }
    
    // Update last backup info
    const lastBackupEl = document.getElementById('lastBackupInfo');
    if (lastBackupEl) {
        const lastBackup = storage.get('lastBackupTimestamp');
        if (lastBackup) {
            const date = new Date(lastBackup);
            lastBackupEl.textContent = `Last backup: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
        } else {
            lastBackupEl.textContent = 'No backup yet - consider exporting!';
        }
    }
}

function getSelectedExportData() {
    const backup = {
        version: 2,
        timestamp: new Date().toISOString(),
        exportedCategories: []
    };
    
    const swapConfigsForExport = window.SourceSwaps ? window.SourceSwaps.getConfigs() : [];
    if (document.getElementById('exportSwaps')?.checked && swapConfigsForExport?.length) {
        backup.swapConfigs = swapConfigsForExport;
        backup.exportedCategories.push('swaps');
    }
    
    if (document.getElementById('exportLayouts')?.checked && layoutPresets?.length) {
        backup.layoutPresets = layoutPresets;
        backup.exportedCategories.push('layouts');
    }
    
    if (document.getElementById('exportTextCyclers')?.checked) {
        const configs = window.TextCycler ? window.TextCycler.getConfigs() : [];
        if (configs.length) {
            backup.textCyclerConfigs = configs;
            backup.exportedCategories.push('textCyclers');
        }
    }
    
    
    if (document.getElementById('exportUIState')?.checked) {
        backup.ui_state = storage.get('ui_state') || {};
        backup.exportedCategories.push('uiState');
    }
    
    if (document.getElementById('exportCredentials')?.checked) {
        // Only export non-sensitive connection info
        backup.connectionSettings = {
            host: storage.getRaw('obs_host'),
            port: storage.getRaw('obs_port')
            // Note: password is NOT exported for security
        };
        backup.exportedCategories.push('connection');
    }
    
    return backup;
}

function exportSelectedData() {
    const backup = getSelectedExportData();
    
    if (backup.exportedCategories.length === 0) {
        log('Nothing to export! Select at least one category or add some configs.', 'error');
        return;
    }
    
    const json = JSON.stringify(backup, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `strixun-backup-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Record backup timestamp
    storage.set('lastBackupTimestamp', new Date().toISOString());
    updateStorageStatus();
    
    log(`Exported: ${backup.exportedCategories.join(', ')}`, 'success');
}

function copyBackupToClipboard() {
    const backup = getSelectedExportData();
    
    if (backup.exportedCategories.length === 0) {
        log('Nothing to copy! Select at least one category.', 'error');
        return;
    }
    
    const json = JSON.stringify(backup, null, 2);
    navigator.clipboard.writeText(json).then(() => {
        log('Backup JSON copied to clipboard!', 'success');
    }).catch(() => {
        // Fallback
        prompt('Copy this JSON:', json);
    });
}

function importDataWithOptions() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
            const text = await file.text();
            const backup = JSON.parse(text);
            
            if (!backup.version) {
                log('Invalid backup file format', 'error');
                return;
            }
            
            // Build import summary
            const categories = [];
            if (backup.swapConfigs?.length) categories.push(`${backup.swapConfigs.length} swap configs`);
            if (backup.layoutPresets?.length) categories.push(`${backup.layoutPresets.length} layout presets`);
            if (backup.textCyclerConfigs?.length) categories.push(`${backup.textCyclerConfigs.length} text cycler configs`);
            if (backup.ui_state) categories.push('UI preferences');
            if (backup.connectionSettings) categories.push('connection settings');
            
            if (categories.length === 0) {
                log('Backup file is empty!', 'error');
                return;
            }
            
            // Build import options dialog
            const importChoices = await showImportDialog(backup, categories);
            if (!importChoices) return; // Cancelled
            
            let imported = [];
            
            // Restore selected configs
            if (importChoices.swaps && backup.swapConfigs) {
                if (importChoices.merge) {
                    // Merge: add new, skip duplicates
                    const currentConfigs = window.SourceSwaps ? window.SourceSwaps.getConfigs() : [];
                    const existingNames = new Set(currentConfigs.map(c => c.name));
                    const newConfigs = backup.swapConfigs.filter(c => !existingNames.has(c.name));
                    if (window.SourceSwaps) {
                        window.SourceSwaps.setConfigs([...currentConfigs, ...newConfigs]);
                    }
                    imported.push(`${newConfigs.length} new swaps (merged)`);
                } else {
                    if (window.SourceSwaps) {
                        window.SourceSwaps.setConfigs(backup.swapConfigs);
                    }
                    imported.push(`${backup.swapConfigs.length} swaps (replaced)`);
                }
                if (window.SourceSwaps) {
                    storage.set('swapConfigs', window.SourceSwaps.getConfigs());
                }
            }
            
            if (importChoices.layouts && backup.layoutPresets) {
                if (importChoices.merge) {
                    const existingIds = new Set(layoutPresets.map(l => l.id));
                    const newLayouts = backup.layoutPresets.filter(l => !existingIds.has(l.id));
                    layoutPresets = [...layoutPresets, ...newLayouts];
                    imported.push(`${newLayouts.length} new layouts (merged)`);
                } else {
                    layoutPresets = backup.layoutPresets;
                    imported.push(`${backup.layoutPresets.length} layouts (replaced)`);
                }
                storage.set('layoutPresets', layoutPresets);
            }
            
            if (importChoices.textCyclers && backup.textCyclerConfigs && window.TextCycler) {
                if (importChoices.merge) {
                    const existingConfigs = window.TextCycler.getConfigs();
                    const existingIds = new Set(existingConfigs.map(c => c.id));
                    const newConfigs = backup.textCyclerConfigs.filter(c => !existingIds.has(c.id));
                    window.TextCycler.addConfigs(newConfigs);
                    imported.push(`${newConfigs.length} new text cyclers (merged)`);
                } else {
                    window.TextCycler.setConfigs(backup.textCyclerConfigs);
                    imported.push(`${backup.textCyclerConfigs.length} text cyclers (replaced)`);
                }
            }
            
            
            if (importChoices.uiState && backup.ui_state) {
                storage.set('ui_state', backup.ui_state);
                imported.push('UI preferences');
            }
            
            if (importChoices.connection && backup.connectionSettings) {
                if (backup.connectionSettings.host) storage.setRaw('obs_host', backup.connectionSettings.host);
                if (backup.connectionSettings.port) storage.setRaw('obs_port', backup.connectionSettings.port);
                imported.push('connection settings');
            }
            
            // Re-render everything
            renderSavedSwaps();
            renderSavedLayouts();
            renderTextCyclerConfigs();
            loadUIState();
            updateStorageStatus();
            
            log(`Imported: ${imported.join(', ')}`, 'success');
        } catch (err) {
            log('Import failed: ' + err.message, 'error');
        }
    };
    
    input.click();
}

async function showImportDialog(backup, categories) {
    return new Promise((resolve) => {
        // Simple confirm-based dialog (could be replaced with modal later)
        const hasSwaps = backup.swapConfigs?.length > 0;
        const hasLayouts = backup.layoutPresets?.length > 0;
        const hasTextCyclers = backup.textCyclerConfigs?.length > 0;
        const hasUI = !!backup.ui_state;
        const hasConnection = !!backup.connectionSettings;
        
        const msg = `Import backup from ${backup.timestamp ? new Date(backup.timestamp).toLocaleString() : 'unknown date'}?

Found:
${categories.map(c => '‚Ä¢ ' + c).join('\n')}

Import mode:
‚Ä¢ OK = REPLACE existing (overwrite)
‚Ä¢ Cancel = abort

(Hold Shift + OK to MERGE instead of replace)`;
        
        const result = confirm(msg);
        if (!result) {
            resolve(null);
            return;
        }
        
        // Check if shift was held (merge mode) - using a simple approach
        const mergeMode = false; // For now, always replace. Could enhance with modal later.
        
        resolve({
            swaps: hasSwaps,
            layouts: hasLayouts,
            textCyclers: hasTextCyclers,
            uiState: hasUI,
            connection: hasConnection,
            merge: mergeMode
        });
    });
}

async function forceStorageSync() {
    log('Forcing storage sync...', 'info');
    
    // Re-save all configs to both storages
    storage.set('swapConfigs', swapConfigs);
    if (window.TextCycler) {
        window.TextCycler.saveTextCyclerConfigs();
    }
    
    // Flush to ensure everything is written
    await storage.flush();
    
    updateStorageStatus();
    log('Storage synced to IndexedDB + localStorage', 'success');
}

// Legacy export function (for backwards compatibility)
function exportAllData() {
    // Check all boxes and export
    ['exportSwaps', 'exportLayouts', 'exportTextCyclers', 'exportUIState'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.checked = true;
    });
    exportSelectedData();
}

// Legacy import function (for backwards compatibility)
function importAllData() {
    importDataWithOptions();
}

// ============ Recovery UI Functions ============
// These functions use the storage system but add UI-specific logic

async function offerRecovery() {
    const recovery = checkForRecoverySnapshot();
    if (!recovery) return false;
    
    const age = new Date() - new Date(recovery.timestamp);
    const ageStr = age < 3600000 ? `${Math.round(age/60000)} minutes` : `${Math.round(age/3600000)} hours`;
    
    const msg = `üîÑ Recovery Data Found!

Your configs appear empty, but we found a backup from ${ageStr} ago:
‚Ä¢ ${recovery.swapConfigs?.length || 0} swap configs
‚Ä¢ ${recovery.textCyclerConfigs?.length || 0} text cycler configs  

Restore this backup?`;
    
    if (confirm(msg)) {
        if (recovery.swapConfigs) {
            if (window.SourceSwaps) {
                window.SourceSwaps.setConfigs(recovery.swapConfigs);
            }
            storage.set('swapConfigs', recovery.swapConfigs);
        }
        if (recovery.textCyclerConfigs && window.TextCycler) {
            window.TextCycler.setConfigs(recovery.textCyclerConfigs);
        }
        
        renderSavedSwaps();
        renderSavedLayouts();
        renderTextCyclerConfigs();
        updateStorageStatus();
        
        log('Configs restored from recovery backup!', 'success');
        return true;
    }
    return false;
}

// ============ Smart Search Module ============
const SmartSearch = {
    instances: new Map(),
    
    /**
     * Create a search instance for a container
     * @param {string} id - Unique identifier for this search
     * @param {HTMLElement} inputEl - The search input element
     * @param {HTMLElement} containerEl - The container with searchable items
     * @param {Object} options - Configuration options
     */
    create(id, inputEl, containerEl, options = {}) {
        const config = {
            itemSelector: options.itemSelector || '.source-item, .config-item, .script-card',
            textSelector: options.textSelector || '.name, .script-name, h3, h4',
            minChars: options.minChars || 1,
            debounceMs: options.debounceMs || 150,
            onFilter: options.onFilter || null,
            showCount: options.showCount !== false
        };
        
        let debounceTimer = null;
        
        const doSearch = () => {
            const query = inputEl.value.toLowerCase().trim();
            const items = containerEl.querySelectorAll(config.itemSelector);
            let visibleCount = 0;
            let totalCount = items.length;
            
            items.forEach(item => {
                // Get text content from multiple possible selectors
                let text = '';
                if (config.textSelector) {
                    const textEls = item.querySelectorAll(config.textSelector);
                    textEls.forEach(el => text += ' ' + el.textContent);
                }
                text = text || item.textContent;
                text = text.toLowerCase();
                
                // Remove old highlights
                item.querySelectorAll('.search-highlight').forEach(h => {
                    h.replaceWith(h.textContent);
                });
                
                if (!query || query.length < config.minChars) {
                    item.classList.remove('search-hidden');
                    visibleCount++;
                    return;
                }
                
                if (text.includes(query)) {
                    item.classList.remove('search-hidden');
                    visibleCount++;
                    // Add highlights
                    SmartSearch.highlightText(item, query, config.textSelector);
                } else {
                    item.classList.add('search-hidden');
                }
            });
            
            // Update count badge if enabled
            if (config.showCount && query.length >= config.minChars) {
                SmartSearch.updateCountBadge(inputEl, visibleCount, totalCount);
            } else {
                SmartSearch.removeCountBadge(inputEl);
            }
            
            // Show/hide no results message
            SmartSearch.updateNoResults(containerEl, visibleCount, query.length >= config.minChars);
            
            if (config.onFilter) config.onFilter(query, visibleCount, totalCount);
        };
        
        // Debounced search
        const onInput = () => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(doSearch, config.debounceMs);
        };
        
        inputEl.addEventListener('input', onInput);
        
        // Clear button support
        const clearBtn = inputEl.parentElement?.querySelector('.search-box__clear');
        if (clearBtn) {
            clearBtn.addEventListener('click', () => {
                inputEl.value = '';
                doSearch();
                inputEl.focus();
            });
        }
        
        this.instances.set(id, { inputEl, containerEl, config, doSearch });
        return { doSearch, clear: () => { inputEl.value = ''; doSearch(); } };
    },
    
    highlightText(element, query, textSelector) {
        const textEls = textSelector ? element.querySelectorAll(textSelector) : [element];
        textEls.forEach(el => {
            if (el.children.length > 0) return; // Skip elements with children
            const text = el.textContent;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            if (regex.test(text)) {
                el.innerHTML = text.replace(regex, '<span class="search-highlight">$1</span>');
            }
        });
    },
    
    updateCountBadge(inputEl, visible, total) {
        let badge = inputEl.parentElement?.querySelector('.search-box__count');
        if (!badge) {
            badge = document.createElement('span');
            badge.className = 'search-box__count';
            inputEl.parentElement?.insertBefore(badge, inputEl.nextSibling?.nextSibling);
        }
        badge.textContent = `${visible}/${total}`;
    },
    
    removeCountBadge(inputEl) {
        inputEl.parentElement?.querySelector('.search-box__count')?.remove();
    },
    
    updateNoResults(container, count, isSearching) {
        let msg = container.querySelector('.search-no-results');
        if (isSearching && count === 0) {
            if (!msg) {
                msg = document.createElement('div');
                msg.className = 'search-no-results';
                msg.textContent = 'No results found';
                container.appendChild(msg);
            }
        } else if (msg) {
            msg.remove();
        }
    },
    
    refresh(id) {
        const instance = this.instances.get(id);
        if (instance) instance.doSearch();
    }
};

/**
 * Helper to initialize search for a list container
 * Always initializes, but hides search box when < 3 items
 */
function initSearchForList(id, inputId, containerEl, itemCount) {
    const searchInput = document.getElementById(inputId);
    if (!searchInput) return;
    
    const searchBox = searchInput.closest('.search-box');
    
    // Show/hide search box based on item count
    if (searchBox) {
        searchBox.style.display = itemCount >= 3 ? '' : 'none';
    }
    
    // Always initialize if not already done
    if (!SmartSearch.instances.has(id)) {
        SmartSearch.create(id, searchInput, containerEl, { 
            itemSelector: '.source-item, .config-item, .script-card' 
        });
        console.log(`[Search] Initialized search for: ${id}`);
    } else {
        // Refresh to re-scan items
        SmartSearch.refresh(id);
    }
}

// ============ Collapsible Cards Module ============
const CollapsibleCards = {
    storageKey: 'ui_collapsed_cards',
    
    init() {
        // Get saved state
        const savedState = storage.get(this.storageKey) || {};
        
        // Find all cards with h3 and make them collapsible
        document.querySelectorAll('.card > h3').forEach((h3, index) => {
            const card = h3.parentElement;
            const cardId = card.id || `card-${index}`;
            card.dataset.cardId = cardId;
            
            // Wrap content after h3 in card-body div
            const cardBody = document.createElement('div');
            cardBody.className = 'card-body';
            while (h3.nextSibling) {
                cardBody.appendChild(h3.nextSibling);
            }
            card.appendChild(cardBody);
            
            // Add collapsible class
            card.classList.add('collapsible');
            
            // Restore saved state
            if (savedState[cardId]) {
                card.classList.add('collapsed');
            }
            
            // Add click handler
            h3.addEventListener('click', (e) => {
                // Don't toggle if clicking a button inside h3
                if (e.target.tagName === 'BUTTON') return;
                
                card.classList.toggle('collapsed');
                this.saveState();
            });
        });
    },
    
    saveState() {
        const state = {};
        document.querySelectorAll('.card.collapsible').forEach(card => {
            if (card.classList.contains('collapsed')) {
                state[card.dataset.cardId] = true;
            }
        });
        storage.set(this.storageKey, state);
    },
    
    expandAll() {
        document.querySelectorAll('.card.collapsible.collapsed').forEach(card => {
            card.classList.remove('collapsed');
        });
        this.saveState();
    },
    
    collapseAll() {
        document.querySelectorAll('.card.collapsible').forEach(card => {
            card.classList.add('collapsed');
        });
        this.saveState();
    }
};

// ============ Split Panel Module ============
const SplitPanel = {
    storageKey: 'ui_split_panel',
    minLogHeight: 40,
    maxLogHeight: 500,
    defaultLogHeight: 150,
    
    init() {
        const divider = document.getElementById('splitDivider');
        const logPanel = document.getElementById('splitLog');
        const logToggle = document.getElementById('logToggle');
        const logContent = document.getElementById('log');
        const mainContent = document.querySelector('.split-main');
        
        if (!divider || !logPanel) return;
        
        // Restore saved state
        const savedState = storage.get(this.storageKey) || {};
        let logHeight = savedState.height || this.defaultLogHeight;
        let isCollapsed = savedState.collapsed || false;
        
        // Apply initial state
        if (isCollapsed) {
            logPanel.classList.add('collapsed');
            logToggle.textContent = '‚ñ≤';
            logPanel.style.height = ''; // Let CSS handle collapsed height
        } else {
            logPanel.style.height = logHeight + 'px';
        }
        
        // Toggle collapse
        logToggle.addEventListener('click', () => {
            isCollapsed = !isCollapsed;
            logPanel.classList.toggle('collapsed', isCollapsed);
            logToggle.textContent = isCollapsed ? '‚ñ≤' : '‚ñº';
            if (isCollapsed) {
                // Clear inline height so CSS auto-height takes over
                logPanel.style.height = '';
            } else {
                logPanel.style.height = logHeight + 'px';
            }
            this.saveState(logHeight, isCollapsed);
        });
        
        // Draggable divider
        let isDragging = false;
        let startY = 0;
        let startHeight = 0;
        
        divider.addEventListener('mousedown', (e) => {
            if (isCollapsed) return;
            isDragging = true;
            startY = e.clientY;
            startHeight = logPanel.offsetHeight;
            divider.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const deltaY = startY - e.clientY;
            logHeight = Math.max(this.minLogHeight, Math.min(this.maxLogHeight, startHeight + deltaY));
            logPanel.style.height = logHeight + 'px';
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                divider.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                this.saveState(logHeight, isCollapsed);
            }
        });
        
        // Touch support for mobile
        divider.addEventListener('touchstart', (e) => {
            if (isCollapsed) return;
            isDragging = true;
            startY = e.touches[0].clientY;
            startHeight = logPanel.offsetHeight;
            divider.classList.add('dragging');
        }, { passive: true });
        
        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const deltaY = startY - e.touches[0].clientY;
            logHeight = Math.max(this.minLogHeight, Math.min(this.maxLogHeight, startHeight + deltaY));
            logPanel.style.height = logHeight + 'px';
        }, { passive: true });
        
        document.addEventListener('touchend', () => {
            if (isDragging) {
                isDragging = false;
                divider.classList.remove('dragging');
                this.saveState(logHeight, isCollapsed);
            }
        });
        
        // Initialize log search
        const logSearchInput = document.getElementById('logSearchInput');
        if (logSearchInput && logContent) {
            logSearchInput.addEventListener('input', () => {
                this.filterLog(logSearchInput.value);
            });
            document.getElementById('logSearchClear')?.addEventListener('click', () => {
                logSearchInput.value = '';
                this.filterLog('');
                logSearchInput.focus();
            });
        }
    },
    
    filterLog(query) {
        const logEl = document.getElementById('log');
        if (!logEl) return;
        
        const entries = logEl.querySelectorAll('.log-entry');
        const q = query.toLowerCase().trim();
        
        entries.forEach(entry => {
            // Remove old highlights
            entry.querySelectorAll('.search-highlight').forEach(h => {
                h.replaceWith(h.textContent);
            });
            
            if (!q) {
                entry.classList.remove('search-hidden');
                return;
            }
            
            const text = entry.textContent.toLowerCase();
            if (text.includes(q)) {
                entry.classList.remove('search-hidden');
                // Highlight matching text
                const textEl = entry.querySelector('.log-entry__text');
                if (textEl) {
                    const regex = new RegExp(`(${q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                    textEl.innerHTML = textEl.textContent.replace(regex, '<span class="search-highlight">$1</span>');
                }
            } else {
                entry.classList.add('search-hidden');
            }
        });
    },
    
    saveState(height, collapsed) {
        storage.set(this.storageKey, { height, collapsed });
    }
};

// ============ WebSocket Module ============
// WebSocket/OBS connection functionality is now in assets/js/websocket.js
// All functions (connect, disconnect, toggleConnection, saveCredentials, etc.)
// and state variables (ws, connected, currentScene, sources, etc.) are global from that file

// ============ UI State Persistence ============
const UI_FIELDS = [
    'swapStyle', 'swapDuration', 'swapEasing', 'swapTempOverride',
    'textSource', 'textLines', 'textDuration', 'textTransition', 'transDuration',
    'swapSourceA', 'swapSourceB', 'swapNewSourceA', 'swapNewSourceB',
    'visAnimType', 'visAnimDuration', 'visAnimEasing',
    'layoutDuration', 'layoutEasing', 'layoutStagger'
];

// Checkbox fields need special handling
const UI_CHECKBOXES = ['swapPreserveAspect', 'swapDebugLogging', 'layoutApplyVisibility'];

function saveUIState() {
    const state = {};
    for (const id of UI_FIELDS) {
        const el = document.getElementById(id);
        if (el) state[id] = el.value;
    }
    // Also save checkbox states
    for (const id of UI_CHECKBOXES) {
        const el = document.getElementById(id);
        if (el) state[id] = el.checked;
    }
    storage.set('ui_state', state);
}

function loadUIState() {
    try {
        const state = storage.get('ui_state') || {};
        for (const id of UI_FIELDS) {
            const el = document.getElementById(id);
            if (el && state[id] !== undefined && state[id] !== '') {
                el.value = state[id];
            }
        }
        // Also load checkbox states
        for (const id of UI_CHECKBOXES) {
            const el = document.getElementById(id);
            if (el && state[id] !== undefined) {
                el.checked = state[id];
            }
        }
    } catch (e) {
        console.error('Error loading UI state:', e);
    }
}

function setupUIStatePersistence() {
    // Save on any input change - multiple events for robustness
    for (const id of UI_FIELDS) {
        const el = document.getElementById(id);
        if (el) {
            el.addEventListener('change', saveUIState);
            el.addEventListener('input', saveUIState);
            el.addEventListener('blur', saveUIState);
        }
    }
    // Also listen to checkbox changes
    for (const id of UI_CHECKBOXES) {
        const el = document.getElementById(id);
        if (el) {
            el.addEventListener('change', saveUIState);
        }
    }
}

// ============ Initialization ============
document.addEventListener('DOMContentLoaded', async () => {
    // CRITICAL: Initialize storage system FIRST before anything else
    console.log('[Init] Starting storage initialization...');
    try {
        await initIndexedDB();
        await loadStorageCache();
        console.log('[Init] Storage system ready');
    } catch (e) {
        console.error('[Init] Storage init error (using fallback):', e);
    }
    
    // NOW load configs from storage into memory
    // Initialize Source Swaps module
    if (window.SourceSwaps) {
        SourceSwaps.init({
            storage,
            log,
            get connected() { return connected; },
            get currentScene() { return currentScene; },
            get sources() { return sources; },
            request,
            isOBSDock,
            showPage,
            initSearchForList
        });
        SourceSwaps.loadConfigs();
    }
    
    // Compatibility: expose swapConfigs as global variable
    let swapConfigs = [];
    Object.defineProperty(window, 'swapConfigs', {
        get: () => window.SourceSwaps ? window.SourceSwaps.getConfigs() : [],
        set: (val) => { if (window.SourceSwaps) window.SourceSwaps.setConfigs(val); },
        configurable: true,
        enumerable: true
    });
    
    loadSourceOpacityConfigs();
    
    // Initialize Text Cycler module
    if (window.TextCycler) {
        TextCycler.init({
            storage,
            log,
            get connected() { return connected; },
            get ws() { return ws; },
            get msgId() { return msgId; },
            isOBSDock,
            request,
            get sources() { return sources; },
            get storageSyncTimer() { return window.StorageSync ? window.StorageSync.storageSyncTimer : null; },
            set storageSyncTimer(val) { if (window.StorageSync) window.StorageSync.storageSyncTimer = val; },
            broadcastStorage: () => { if (window.StorageSync) window.StorageSync.scheduleBroadcast(); },
            STORAGE_SYNC_DEBOUNCE: window.StorageSync ? window.StorageSync.STORAGE_SYNC_DEBOUNCE : 500
        });
        TextCycler.loadConfigs();
        
        // Compatibility: expose textCyclerConfigs and currentTextConfigIndex as global variables
        Object.defineProperty(window, 'textCyclerConfigs', {
            get: () => TextCycler.getConfigs(),
            configurable: true,
            enumerable: true
        });
        Object.defineProperty(window, 'currentTextConfigIndex', {
            get: () => TextCycler.getCurrentIndex(),
            set: (val) => TextCycler.setCurrentIndex(val),
            configurable: true,
            enumerable: true
        });
    }
    
    // Get textCyclerConfigs from module for compatibility (local const for init code)
    const textCyclerConfigs = window.TextCycler ? window.TextCycler.getConfigs() : (storage.get('textCyclerConfigs') || []);
    
    const swapConfigsCount = window.SourceSwaps ? window.SourceSwaps.getConfigs().length : 0;
    console.log('[Init] Loaded configs - Swaps:', swapConfigsCount, 
                'TextCycler:', textCyclerConfigs.length, 
                'Opacity:', Object.keys(sourceOpacityConfigs).length);
    
    // Check for recovery if configs are empty
    const totalConfigs = swapConfigsCount + textCyclerConfigs.length;
    if (totalConfigs === 0) {
        const recovered = await offerRecovery();
        if (recovered) {
            console.log('[Init] Configs restored from recovery snapshot');
        }
    }
    
    // Start auto-backup system
    startAutoBackup();
    
    // Initialize UI modules
    console.log('[Init] Initializing UI modules...');
    SplitPanel.init();
    CollapsibleCards.init();
    
    // Set dock URL
    const url = window.location.href;
    document.getElementById('dockUrl').value = url;
    
    // Render loaded configs
    if (window.SourceSwaps) {
        SourceSwaps.renderSavedSwaps();
    }
    renderTextCyclerConfigs();
    initLayouts();
    // Initialize installer (function is global from installer.js module)
    if (typeof initScriptsAndInstaller === 'function') {
        initScriptsAndInstaller();
    }
    loadUIState();
    restoreActiveTab();
    updateConnectionState();
    setupUIStatePersistence();
    
    // Initialize script status (will show "not connected" banner)
    renderStartupBanner();
    updateTabStates();
    
    // Restore running text cyclers
    setTimeout(restoreRunningTextCyclers, 1000);
    updateTransitionMode();
    updateStorageStatus();
    initVersionDisplay();
    
    // Initialize Storage Sync module
    if (window.StorageSync) {
        StorageSync.init({
            storage,
            log,
            get connected() { return connected; },
            isOBSDock,
            request,
            // Callbacks for getting/setting configs
            getSwapConfigs: () => window.SourceSwaps ? window.SourceSwaps.getConfigs() : [],
            setSwapConfigs: (val) => { if (window.SourceSwaps) window.SourceSwaps.setConfigs(val); },
            getTextCyclerConfigs: () => window.TextCycler ? window.TextCycler.getConfigs() : [],
            setTextCyclerConfigs: (val) => { if (window.TextCycler) window.TextCycler.setConfigs(val); },
            getLayoutPresets: () => layoutPresets || [],
            setLayoutPresets: (val) => { layoutPresets = val; },
            // Render callbacks
            renderSavedSwaps: () => { if (window.SourceSwaps) window.SourceSwaps.renderSavedSwaps(); },
            renderTextCyclerConfigs: () => { if (window.TextCycler) window.TextCycler.renderConfigs(); },
            renderSavedLayouts,
            updateStorageStatus
        });
        StorageSync.loadAutoSyncPref();
    }
    
    loadTwitchSettings();
    
    // Setup credential UI listeners
    document.getElementById('rememberCreds').addEventListener('change', updateSecurityWarning);
    document.getElementById('password').addEventListener('input', updateSecurityWarning);
    
    // Load saved credentials and auto-connect
    try {
        const hasCreds = await loadCredentials();
        if (hasCreds && document.getElementById('password').value) {
            log('Credentials unlocked. Auto-connecting...', 'info');
            setTimeout(connect, 500);
        } else if (hasCreds) {
            log('Host/port loaded. Enter password to connect.', 'info');
        } else {
            log('Ready. Connect to OBS to begin.', 'info');
        }
    } catch (e) {
        console.error('Credential load error:', e);
        log('Ready. Connect to OBS to begin.', 'info');
    }
});

// ============ UI ============
function showPage(id, save = true) {
    // Check if tab is disabled (requires connection)
    const featurePages = ['sources', 'text', 'swaps', 'layouts'];
    if (featurePages.includes(id) && !scriptStatus.connected) {
        // Don't switch to disabled page, redirect to setup
        log('Connect to OBS first to use this feature', 'error');
        showPage('setup', false);
        return;
    }
    
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    
    const pageElement = document.getElementById('page-' + id);
    if (!pageElement) {
        console.warn(`[showPage] Page element 'page-${id}' not found, defaulting to dashboard`);
        showPage('dashboard', save);
        return;
    }
    pageElement.classList.add('active');
    
    // Find and activate the corresponding tab - must match order in HTML nav.tabs
    const tabs = document.querySelectorAll('.tab');
    const tabIds = ['dashboard', 'sources', 'text', 'swaps', 'layouts', 'scripts', 'install', 'setup'];
    const tabIndex = tabIds.indexOf(id);
    if (tabIndex >= 0 && tabs[tabIndex]) {
        tabs[tabIndex].classList.add('active');
    }
    
    // Render feature notices for pages that require scripts
    const pageFeatureMap = {
        'sources': { id: 'page-sources', feature: 'sources', script: 'Source Animations' },
        'text': { id: 'page-text', feature: 'text', script: 'Text Cycler' },
        'swaps': { id: 'page-swaps', feature: 'swap', script: 'Source Swap' },
        'layouts': { id: 'page-layouts', feature: 'layouts', script: 'Source Layouts' }
    };
    
    const pageInfo = pageFeatureMap[id];
    if (pageInfo) {
        renderFeatureNotice(pageInfo.id, pageInfo.feature, pageInfo.script);
    }
    
    // Save active tab
    if (save) {
        storage.setRaw('active_tab', id);
    }
}

function restoreActiveTab() {
    const savedTab = storage.getRaw('active_tab');
    if (savedTab) {
        showPage(savedTab, false);
    }
}

function log(msg, type = '') {
    const el = document.getElementById('log');
    if (!el) return;
    
    const entry = document.createElement('div');
    entry.className = 'log-entry ' + type;
    
    const time = document.createElement('span');
    time.className = 'log-entry__time';
    time.textContent = `[${new Date().toLocaleTimeString()}]`;
    
    const text = document.createElement('span');
    text.className = 'log-entry__text';
    text.textContent = msg;
    
    entry.appendChild(time);
    entry.appendChild(text);
    
    el.insertBefore(entry, el.firstChild);
    if (el.children.length > 100) el.removeChild(el.lastChild);
}

function clearLog() {
    const el = document.getElementById('log');
    if (el) el.innerHTML = '';
    log('Log cleared', 'info');
}

function copyUrl() {
    const url = document.getElementById('dockUrl');
    url.select();
    document.execCommand('copy');
    document.getElementById('copyStatus').textContent = '‚úì Copied to clipboard!';
    setTimeout(() => document.getElementById('copyStatus').textContent = '', 2000);
}

function renderDashSwaps() {
    if (window.SourceSwaps) {
        window.SourceSwaps.renderDashSwaps();
        return;
    }
    const grid = document.getElementById('dashSwapGrid');
    const swapConfigs = window.SourceSwaps ? window.SourceSwaps.getConfigs() : [];
    if (swapConfigs.length === 0) {
        grid.innerHTML = '<div class="empty-state" style="padding:10px;grid-column:1/-1">No saved swaps. Go to üîÑ tab to create one.</div>';
        return;
    }
    grid.innerHTML = swapConfigs.map((c, i) => 
        `<button class="source-btn" onclick="loadSwapConfig(${i})">${c.name}</button>`
    ).join('');
}

// updateConnectionUI is now in assets/js/websocket.js (global function)

// ============ Source Management Module ============
// Source management functionality is now in assets/js/modules/sources.js
// All functions (refreshScenes, refreshSources, toggleSource, setSourceOpacity, etc.)
// and state variables (allScenes, selectedScene, sourceOpacityConfigs, textSources) are global from that file

// ============ Source Swap (Direct via WebSocket) ============
// Functions moved to assets/js/source-swaps.js module
// Wrapper functions for backward compatibility:

function updateSwapDropdowns() {
    if (window.SourceSwaps) {
        window.SourceSwaps.updateSwapDropdowns();
    }
}

async function executeSwap(sourceAOverride, sourceBOverride) {
    if (window.SourceSwaps) {
        return window.SourceSwaps.executeSwap(sourceAOverride, sourceBOverride);
    }
}

function saveCurrentSwap() {
    if (window.SourceSwaps) {
        window.SourceSwaps.saveCurrentSwap();
    }
}

function addSwapConfig() {
    if (window.SourceSwaps) {
        window.SourceSwaps.addSwapConfig();
    }
}

function refreshSwapSources() {
    if (window.SourceSwaps) {
        window.SourceSwaps.refreshSwapSources();
    }
}

function renderSavedSwaps() {
    if (window.SourceSwaps) {
        window.SourceSwaps.renderSavedSwaps();
    }
}

function loadSwapConfig(index) {
    if (window.SourceSwaps) {
        window.SourceSwaps.loadSwapConfig(index);
    }
}

function deleteSwapConfig(index) {
    if (window.SourceSwaps) {
        window.SourceSwaps.deleteSwapConfig(index);
    }
}

function exportConfigs() {
    if (window.SourceSwaps) {
        window.SourceSwaps.exportConfigs();
    }
}

function importConfigs() {
    if (window.SourceSwaps) {
        window.SourceSwaps.importConfigs();
    }
}

// Note: getSceneItemId, getTransform, setTransform, easeFunc, lerp, and animation functions
// are now internal to the SourceSwaps module and not exposed globally.
// If other code needs these, they should be accessed via the module or refactored.

// ============ Source Layouts (Presets) ============
let layoutPresets = []; // Loaded async from storage on init
let isApplyingLayout = false;

/**
 * Capture the current scene state as a layout preset
 */
async function captureLayout() {
    if (!connected) {
        log('Connect to OBS first', 'error');
        showPage('setup');
        return;
    }
    
    const layoutName = document.getElementById('layoutName').value.trim();
    if (!layoutName) {
        log('Enter a layout name first!', 'error');
        return;
    }
    
    try {
        // Get current scene
        const sceneData = await request('GetCurrentProgramScene', {});
        const sceneName = sceneData.currentProgramSceneName;
        
        // Get all scene items
        const itemsData = await request('GetSceneItemList', { sceneName });
        const items = itemsData.sceneItems || [];
        
        if (items.length === 0) {
            log('No sources found in scene', 'error');
            return;
        }
        
        // Capture transform for each source
        const sources = {};
        for (const item of items) {
            const sourceName = item.sourceName;
            const sceneItemId = item.sceneItemId;
            
            try {
                // Get transform
                const transformData = await request('GetSceneItemTransform', {
                    sceneName,
                    sceneItemId
                });
                const t = transformData.sceneItemTransform;
                
                // Get visibility
                const enabledData = await request('GetSceneItemEnabled', {
                    sceneName,
                    sceneItemId
                });
                
                sources[sourceName] = {
                    sourceName,
                    sceneItemId,
                    visible: enabledData.sceneItemEnabled,
                    positionX: t.positionX,
                    positionY: t.positionY,
                    scaleX: t.scaleX,
                    scaleY: t.scaleY,
                    boundsType: t.boundsType,
                    boundsWidth: t.boundsWidth,
                    boundsHeight: t.boundsHeight,
                    sourceWidth: t.sourceWidth,
                    sourceHeight: t.sourceHeight,
                    rotation: t.rotation || 0,
                    alignment: t.alignment
                };
            } catch (e) {
                console.warn('Could not capture transform for:', sourceName, e);
            }
        }
        
        // Get animation settings
        const duration = parseInt(document.getElementById('layoutDuration').value) || 500;
        const easing = document.getElementById('layoutEasing').value || 'ease_out';
        const stagger = parseInt(document.getElementById('layoutStagger').value) || 0;
        const applyVisibility = document.getElementById('layoutApplyVisibility').checked;
        
        // Create the preset
        const now = new Date().toISOString();
        const existingIndex = layoutPresets.findIndex(p => p.name === layoutName && p.sceneName === sceneName);
        
        const preset = {
            id: existingIndex >= 0 ? layoutPresets[existingIndex].id : generateLayoutId(),
            name: layoutName,
            sceneName,
            createdAt: existingIndex >= 0 ? layoutPresets[existingIndex].createdAt : now,
            updatedAt: now,
            animation: { duration, easing, stagger },
            options: { applyVisibility, warnOnMissing: true, ignoreNewSources: true },
            sources,
            sourceCount: Object.keys(sources).length
        };
        
        if (existingIndex >= 0) {
            layoutPresets[existingIndex] = preset;
            log(`Updated layout: ${layoutName} (${preset.sourceCount} sources)`, 'success');
        } else {
            layoutPresets.push(preset);
            log(`Saved layout: ${layoutName} (${preset.sourceCount} sources)`, 'success');
        }
        
        // Save and refresh
        storage.set('layoutPresets', layoutPresets);
        document.getElementById('layoutName').value = '';
        renderSavedLayouts();
        
        // OBS dock: debounced save to persistent storage
        if (isOBSDock() && connected) {
            if (window.StorageSync) {
                window.StorageSync.scheduleBroadcast();
            }
        }
        
    } catch (e) {
        log('Failed to capture layout: ' + e, 'error');
        console.error('Capture layout error:', e);
    }
}

function generateLayoutId() {
    return 'layout_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// Note: easeFunc and lerp are used by other code (opacity animations, layout animations), so we keep them here
// They're also in SourceSwaps module, but we need them globally for now
function easeFunc(t, type) {
    switch(type) {
        case 'easeIn': return t * t * t;
        case 'easeOut': return 1 - Math.pow(1 - t, 3);
        case 'ease': return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
        case 'back': {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return t < 0.5
                ? (Math.pow(2*t, 2) * ((c3 + 1) * 2*t - c3)) / 2
                : (Math.pow(2*t - 2, 2) * ((c3 + 1) * (t*2 - 2) + c3) + 2) / 2;
        }
        case 'bounce': {
            const n1 = 7.5625, d1 = 2.75;
            let x = t;
            if (x < 1/d1) return n1 * x * x;
            if (x < 2/d1) return n1 * (x -= 1.5/d1) * x + 0.75;
            if (x < 2.5/d1) return n1 * (x -= 2.25/d1) * x + 0.9375;
            return n1 * (x -= 2.625/d1) * x + 0.984375;
        }
        case 'elastic': {
            const c4 = (2 * Math.PI) / 3;
            return t === 0 ? 0 : t === 1 ? 1 :
                t < 0.5
                    ? -(Math.pow(2, 20*t - 10) * Math.sin((20*t - 11.125) * c4)) / 2
                    : (Math.pow(2, -20*t + 10) * Math.sin((20*t - 11.125) * c4)) / 2 + 1;
        }
        default: return t; // linear
    }
}

function lerp(a, b, t) { return a + (b - a) * t; }

/**
 * Apply a saved layout preset with animation
 */
async function applyLayout(index) {
    if (!connected) {
        log('Connect to OBS first', 'error');
        return;
    }
    
    if (isApplyingLayout) {
        log('Layout animation in progress', 'error');
        return;
    }
    
    const preset = layoutPresets[index];
    if (!preset) {
        log('Layout not found', 'error');
        return;
    }
    
    // Verify we're on the right scene (or warn)
    const sceneData = await request('GetCurrentProgramScene', {});
    const currentSceneName = sceneData.currentProgramSceneName;
    
    if (currentSceneName !== preset.sceneName) {
        log(`Warning: Layout was saved for "${preset.sceneName}" but you're on "${currentSceneName}"`, 'error');
        // Continue anyway - user might want to apply cross-scene
    }
    
    isApplyingLayout = true;
    log(`Applying layout: ${preset.name}...`, 'info');
    
    try {
        // Get current scene items
        const itemsData = await request('GetSceneItemList', { sceneName: currentSceneName });
        const currentItems = itemsData.sceneItems || [];
        
        // Build animation plan
        const animations = [];
        const missingFromScene = [];
        const missingFromPreset = [];
        
        // Create map of current items for quick lookup
        const currentItemsMap = {};
        for (const item of currentItems) {
            currentItemsMap[item.sourceName] = item;
        }
        
        // Check each source in preset
        for (const [sourceName, targetState] of Object.entries(preset.sources)) {
            const currentItem = currentItemsMap[sourceName];
            
            if (!currentItem) {
                missingFromScene.push(sourceName);
                continue;
            }
            
            // Get current transform
            const transformData = await request('GetSceneItemTransform', {
                sceneName: currentSceneName,
                sceneItemId: currentItem.sceneItemId
            });
            const currentTransform = transformData.sceneItemTransform;
            
            // Get current visibility
            const enabledData = await request('GetSceneItemEnabled', {
                sceneName: currentSceneName,
                sceneItemId: currentItem.sceneItemId
            });
            
            animations.push({
                sourceName,
                sceneItemId: currentItem.sceneItemId,
                from: {
                    positionX: currentTransform.positionX,
                    positionY: currentTransform.positionY,
                    scaleX: currentTransform.scaleX,
                    scaleY: currentTransform.scaleY,
                    boundsWidth: currentTransform.boundsWidth,
                    boundsHeight: currentTransform.boundsHeight,
                    rotation: currentTransform.rotation || 0
                },
                to: {
                    positionX: targetState.positionX,
                    positionY: targetState.positionY,
                    scaleX: targetState.scaleX,
                    scaleY: targetState.scaleY,
                    boundsWidth: targetState.boundsWidth,
                    boundsHeight: targetState.boundsHeight,
                    boundsType: targetState.boundsType,
                    rotation: targetState.rotation || 0
                },
                currentVisible: enabledData.sceneItemEnabled,
                targetVisible: targetState.visible
            });
        }
        
        // Find sources in scene but not in preset
        for (const item of currentItems) {
            if (!preset.sources[item.sourceName]) {
                missingFromPreset.push(item.sourceName);
            }
        }
        
        // Log warnings
        if (missingFromScene.length > 0) {
            log(`Missing sources: ${missingFromScene.join(', ')}`, 'error');
        }
        if (missingFromPreset.length > 0) {
            console.log('[Layouts] Sources not in preset (leaving alone):', missingFromPreset);
        }
        
        if (animations.length === 0) {
            log('No sources to animate', 'error');
            isApplyingLayout = false;
            return;
        }
        
        // Animation settings
        const duration = preset.animation.duration || 500;
        const easingType = preset.animation.easing || 'ease_out';
        const stagger = preset.animation.stagger || 0;
        const applyVisibility = preset.options.applyVisibility !== false;
        
        // Hide sources that need hiding (before animation)
        if (applyVisibility) {
            for (const anim of animations) {
                if (anim.currentVisible && !anim.targetVisible) {
                    // Will hide after animation
                }
            }
        }
        
        // Animate!
        const startTime = performance.now();
        
        await new Promise((resolve) => {
            function animate() {
                const elapsed = performance.now() - startTime;
                const maxDuration = duration + (stagger * animations.length);
                
                if (elapsed >= maxDuration) {
                    // Final frame - apply exact end values
                    for (const anim of animations) {
                        setLayoutTransform(currentSceneName, anim.sceneItemId, anim.to);
                        
                        // Apply visibility
                        if (applyVisibility && anim.currentVisible !== anim.targetVisible) {
                            setSceneItemEnabled(currentSceneName, anim.sceneItemId, anim.targetVisible);
                        }
                    }
                    resolve();
                    return;
                }
                
                // Animate each source (with stagger)
                for (let i = 0; i < animations.length; i++) {
                    const anim = animations[i];
                    const sourceDelay = i * stagger;
                    const sourceElapsed = elapsed - sourceDelay;
                    
                    if (sourceElapsed < 0) continue; // Not started yet
                    
                    const rawT = Math.min(sourceElapsed / duration, 1);
                    const t = easeFunc(rawT, easingType);
                    
                    const current = {
                        positionX: lerp(anim.from.positionX, anim.to.positionX, t),
                        positionY: lerp(anim.from.positionY, anim.to.positionY, t),
                        rotation: lerp(anim.from.rotation, anim.to.rotation, t)
                    };
                    
                    // Handle bounds vs scale
                    if (anim.to.boundsType && anim.to.boundsType !== 'OBS_BOUNDS_NONE') {
                        current.boundsWidth = lerp(anim.from.boundsWidth || anim.from.scaleX * 1920, anim.to.boundsWidth, t);
                        current.boundsHeight = lerp(anim.from.boundsHeight || anim.from.scaleY * 1080, anim.to.boundsHeight, t);
                        current.boundsType = anim.to.boundsType;
                    } else {
                        current.scaleX = lerp(anim.from.scaleX, anim.to.scaleX, t);
                        current.scaleY = lerp(anim.from.scaleY, anim.to.scaleY, t);
                    }
                    
                    setLayoutTransform(currentSceneName, anim.sceneItemId, current);
                }
                
                requestAnimationFrame(animate);
            }
            
            requestAnimationFrame(animate);
        });
        
        log(`Layout applied: ${preset.name}`, 'success');
        
    } catch (e) {
        log('Failed to apply layout: ' + e, 'error');
        console.error('Apply layout error:', e);
    } finally {
        isApplyingLayout = false;
    }
}

async function setLayoutTransform(sceneName, sceneItemId, transform) {
    try {
        await request('SetSceneItemTransform', {
            sceneName,
            sceneItemId,
            sceneItemTransform: transform
        });
    } catch (e) {
        console.warn('Failed to set transform:', sceneItemId, e);
    }
}

async function setSceneItemEnabled(sceneName, sceneItemId, enabled) {
    try {
        await request('SetSceneItemEnabled', {
            sceneName,
            sceneItemId,
            sceneItemEnabled: enabled
        });
    } catch (e) {
        console.warn('Failed to set visibility:', sceneItemId, e);
    }
}

function deleteLayout(index) {
    const preset = layoutPresets[index];
    if (!preset) return;
    
    if (confirm(`Delete layout "${preset.name}"?`)) {
        layoutPresets.splice(index, 1);
        storage.set('layoutPresets', layoutPresets);
        renderSavedLayouts();
        log(`Deleted layout: ${preset.name}`, 'info');
        
        // OBS dock: debounced save to persistent storage
        if (isOBSDock() && connected) {
            if (window.StorageSync) {
                window.StorageSync.scheduleBroadcast();
            }
        }
    }
}

function renderSavedLayouts() {
    const container = document.getElementById('savedLayouts');
    const searchInput = document.getElementById('layoutSearchInput');
    const searchTerm = searchInput?.value?.toLowerCase() || '';
    
    // Update current scene display
    const sceneEl = document.getElementById('layoutCurrentScene');
    if (sceneEl) {
        sceneEl.textContent = currentScene || '-';
    }
    
    // Filter by current scene and search term
    const filteredLayouts = layoutPresets.filter((p, i) => {
        const matchesScene = !currentScene || p.sceneName === currentScene;
        const matchesSearch = !searchTerm || p.name.toLowerCase().includes(searchTerm);
        return matchesScene && matchesSearch;
    });
    
    if (filteredLayouts.length === 0) {
        container.innerHTML = '<div class="empty-state">No layouts saved for this scene</div>';
        return;
    }
    
    container.innerHTML = filteredLayouts.map((preset) => {
        const originalIndex = layoutPresets.indexOf(preset);
        const sourceCount = preset.sourceCount || Object.keys(preset.sources || {}).length;
        const age = getRelativeTime(preset.updatedAt);
        
        return `
            <div class="config-item">
                <div class="config-item__header">
                    <span class="config-item__name">üìê ${preset.name.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>
                    <span class="config-item__meta">${sourceCount} sources ‚Ä¢ ${age}</span>
                </div>
                <div class="config-item__actions">
                    <button onclick="applyLayout(${originalIndex})" class="btn-primary btn-sm">‚ñ∂Ô∏è Apply</button>
                    <button onclick="previewLayout(${originalIndex})" class="btn-secondary btn-sm">üëÅÔ∏è</button>
                    <button onclick="deleteLayout(${originalIndex})" class="btn-danger btn-sm">üóëÔ∏è</button>
                </div>
            </div>
        `;
    }).join('');
}

function previewLayout(index) {
    const preset = layoutPresets[index];
    if (!preset) return;
    
    // Log the layout details
    log(`=== Layout: ${preset.name} ===`, 'info');
    log(`Scene: ${preset.sceneName}`, 'info');
    log(`Sources: ${Object.keys(preset.sources).length}`, 'info');
    log(`Animation: ${preset.animation.duration}ms, ${preset.animation.easing}`, 'info');
    
    const sourceNames = Object.keys(preset.sources);
    for (const name of sourceNames.slice(0, 5)) {
        const s = preset.sources[name];
        log(`  ‚Ä¢ ${name}: (${Math.round(s.positionX)}, ${Math.round(s.positionY)}) ${s.visible ? 'üëÅÔ∏è' : 'üö´'}`, 'info');
    }
    if (sourceNames.length > 5) {
        log(`  ... and ${sourceNames.length - 5} more`, 'info');
    }
}

function refreshLayouts() {
    renderSavedLayouts();
    log('Layouts refreshed', 'info');
}

function getRelativeTime(isoString) {
    if (!isoString) return 'unknown';
    
    const date = new Date(isoString);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    return date.toLocaleDateString();
}

// Initialize layouts on page load
function initLayouts() {
    layoutPresets = storage.get('layoutPresets') || [];
    renderSavedLayouts();
    
    // Setup search
    const searchInput = document.getElementById('layoutSearchInput');
    if (searchInput) {
        searchInput.addEventListener('input', renderSavedLayouts);
    }
}

// ============ Text Cycler (Multi-Config) ============
// Text Cycler functionality has been moved to assets/js/text-cycler.js
// Wrapper functions below maintain backward compatibility
// Global compatibility variables are defined during module initialization

function renderTextCyclerConfigs() {
    if (window.TextCycler) {
        TextCycler.renderTextCyclerConfigs();
    }
}

function newTextConfig() {
    if (window.TextCycler) {
        TextCycler.newTextConfig();
    }
}

function loadTextConfig(index) {
    if (window.TextCycler) {
        TextCycler.loadConfig(index);
    }
}

function saveCurrentTextConfig() {
    if (window.TextCycler) {
        TextCycler.saveCurrentTextConfig();
    }
}

function deleteCurrentTextConfig() {
    if (window.TextCycler) {
        TextCycler.deleteCurrentTextConfig();
    }
}

function saveTextCyclerConfigs() {
    if (window.TextCycler) {
        TextCycler.saveTextCyclerConfigs();
    }
}

function exportTextConfigs() {
    if (window.TextCycler) {
        TextCycler.exportTextConfigs();
    }
}

function importTextConfigs() {
    if (window.TextCycler) {
        TextCycler.importTextConfigs();
    }
}

function updateTextCyclerMode() {
    const mode = document.getElementById('textCyclerMode').value;
    const modeInfo = document.getElementById('modeInfo');
    
    document.getElementById('browserModeSettings').style.display = mode === 'browser' ? 'block' : 'none';
    document.getElementById('legacyModeSettings').style.display = mode === 'legacy' ? 'block' : 'none';
    document.getElementById('textStyleCard').style.display = mode === 'browser' ? 'block' : 'none';
    
    if (mode === 'browser') {
        modeInfo.textContent = 'Uses a Browser Source in OBS with smooth CSS animations. Create a Browser Source pointing to text_cycler_display.html';
    } else {
        modeInfo.textContent = 'Updates an existing OBS text source directly. Limited to text scramble animations.';
    }
}

function updateConfigIdPreview() {
    const configId = document.getElementById('textConfigId').value || 'config1';
    document.getElementById('configIdPreview').textContent = configId;
}

// URL preview updated via oninput attribute on textConfigId field

// Color picker sync
document.getElementById('textColorPicker')?.addEventListener('input', (e) => {
    document.getElementById('textColor').value = e.target.value;
});
document.getElementById('textColor')?.addEventListener('input', (e) => {
    const picker = document.getElementById('textColorPicker');
    if (picker && /^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
        picker.value = e.target.value;
    }
});
document.getElementById('textStrokeColorPicker')?.addEventListener('input', (e) => {
    document.getElementById('textStrokeColor').value = e.target.value;
});
document.getElementById('textStrokeColor')?.addEventListener('input', (e) => {
    const picker = document.getElementById('textStrokeColorPicker');
    if (picker && /^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
        picker.value = e.target.value;
    }
});

function getBrowserSourceUrl(configId) {
    const currentPath = window.location.pathname;
    const displayPath = currentPath.replace('control_panel.html', 'text_cycler_display.html');
    return `file://${displayPath}?id=${configId || 'config1'}`;
}

function updateBrowserSourceUrlPreview() {
    const configId = document.getElementById('textConfigId').value || 'config1';
    const preview = document.getElementById('browserSourceUrlPreview');
    if (preview) {
        preview.textContent = getBrowserSourceUrl(configId);
    }
}

function copyBrowserSourceUrl() {
    const configId = document.getElementById('textConfigId').value || 'config1';
    const url = getBrowserSourceUrl(configId);
    
    navigator.clipboard.writeText(url).then(() => {
        log('URL copied! Add as Browser Source in OBS', 'success');
    }).catch(() => {
        prompt('Copy this URL:', url);
    });
}

function updateTransitionMode() {
    const val = document.getElementById('textTransition').value;
    const info = document.getElementById('transitionInfo');
    const descriptions = {
        'none': 'Instant text change',
        'fade': 'Smooth fade in/out',
        'obfuscate': 'Minecraft enchant table scramble, reveal left-to-right',
        'typewriter': 'Type out one character at a time',
        'glitch': 'Random glitch characters that settle',
        'scramble': 'Full scramble, then snap to final',
        'wave': 'Characters appear in a wave pattern',
        'slide_left': 'Slide out left, slide in from right',
        'slide_right': 'Slide out right, slide in from left',
        'slide_up': 'Slide up transition',
        'slide_down': 'Slide down transition',
        'pop': 'Pop in with scale bounce'
    };
    info.textContent = descriptions[val] || '';
}

function updateTextSourceDropdown() {
    const select = document.getElementById('textSource');
    if (!select) return;
    
    const savedState = storage.get('ui_state') || {};
    const current = select.value || savedState.textSource || '';
    
    textSources = sources.filter(s => 
        s.inputKind && (s.inputKind.includes('text') || s.inputKind === 'text_gdiplus_v2' || s.inputKind === 'text_ft2_source_v2')
    );
    
    select.innerHTML = '<option value="">-- Select Text Source --</option>' +
        textSources.map(s => `<option value="${s.sourceName}">${s.sourceName}</option>`).join('');
    
    if (current && textSources.find(s => s.sourceName === current)) {
        select.value = current;
    }
}

async function loadTextSource() {
    const name = document.getElementById('textSource').value;
    if (!name) {
        document.getElementById('textPreview').textContent = 'Select a source';
        return;
    }
    
    try {
        const data = await request('GetInputSettings', { inputName: name });
        const text = data.inputSettings.text || '';
        document.getElementById('textPreview').textContent = text || '(empty)';
    } catch (e) {
        log('Error loading text: ' + e, 'error');
    }
}

// ============ Text Cycler Engine ============
// Engine functions moved to assets/js/text-cycler.js module

function startTextCycler() {
    if (window.TextCycler) {
        TextCycler.startTextCycler();
    }
}

// Engine functions (startConfigCycling, showConfigText, etc.) moved to module

function stopTextCycler() {
    if (window.TextCycler) {
        TextCycler.stopTextCycler();
    }
}

// stopConfigCycling moved to module

function quickStartConfig(index) {
    if (window.TextCycler) {
        TextCycler.quickStart(index);
    }
}

// Restore running configs on load
function restoreRunningTextCyclers() {
    if (window.TextCycler) {
        TextCycler.restoreRunningTextCyclers();
    }
}


// ============ Twitch API Configuration ============
// These values are loaded from storage - configure in Setup ‚Üí Twitch API Settings

// Get Twitch Client ID (auto-configured from deployment or manual override)
function getTwitchClientId() {
    // Priority 1: Manual override
    const manual = storage.get('twitch_client_id');
    if (manual) return manual;
    
    // Priority 2: Auto-injected from deployment
    if (typeof window.STRIXUN_CONFIG !== 'undefined' && window.STRIXUN_CONFIG.TWITCH_CLIENT_ID) {
        const injected = window.STRIXUN_CONFIG.TWITCH_CLIENT_ID;
        if (injected && !injected.startsWith('%%')) {
            return injected;
        }
    }
    
    return '';
}


// OAuth callback URL - hardcoded to our GitHub Pages hosted service
function getTwitchOAuthCallback() {
    return DEFAULT_OAUTH_CALLBACK;
}

// Generate dynamic OAuth URL using configured values
function getTwitchAuthUrl() {
    const clientId = getTwitchClientId();
    const callback = getTwitchOAuthCallback();
    
    if (!clientId || !callback) {
        return null; // Configuration required
    }
    
    const scopes = 'chat:read+chat:edit+user:read:follows+moderator:read:followers';
    return `https://id.twitch.tv/oauth2/authorize?response_type=token&client_id=${clientId}&redirect_uri=${encodeURIComponent(callback)}&scope=${scopes}&force_verify=true`;
}

// Save Twitch settings to storage
function saveTwitchSettings() {
    const clientId = document.getElementById('twitchClientId').value.trim();
    const apiServer = document.getElementById('twitchApiServer').value.trim();
    
    storage.set('twitch_client_id', clientId);
    storage.set('twitch_api_server', apiServer);
    
    const statusEl = document.getElementById('twitchApiStatus');
    if (statusEl) {
        statusEl.innerHTML = '<span style="color:var(--success)">‚úÖ Settings saved!</span>';
        setTimeout(() => { statusEl.textContent = ''; }, 3000);
    }
    
    log('Twitch API settings saved', 'success');
}

// Load Twitch settings into form
function loadTwitchSettings() {
    const clientIdEl = document.getElementById('twitchClientId');
    const apiServerEl = document.getElementById('twitchApiServer');
    const autoDetectedApiEl = document.getElementById('autoDetectedApiUrl');
    const autoDetectedClientEl = document.getElementById('autoDetectedClientId');
    
    // Show manual Client ID override only (if set)
    const manualClientId = storage.get('twitch_client_id') || '';
    if (clientIdEl) clientIdEl.value = manualClientId;
    
    // Show auto-detected Client ID
    if (autoDetectedClientEl) {
        const autoClientId = window.STRIXUN_CONFIG?.TWITCH_CLIENT_ID;
        if (autoClientId && !autoClientId.startsWith('%%') && !manualClientId) {
            const masked = autoClientId.substring(0, 8) + '...' + autoClientId.substring(autoClientId.length - 4);
            autoDetectedClientEl.innerHTML = `‚úÖ Auto-configured: <code style="background:var(--bg);padding:2px 6px;border-radius:3px">${masked}</code>`;
        } else if (autoClientId && !autoClientId.startsWith('%%') && manualClientId) {
            autoDetectedClientEl.innerHTML = `‚ÑπÔ∏è Auto-configured but overridden with manual value`;
        } else {
            autoDetectedClientEl.innerHTML = `‚ö†Ô∏è Not auto-configured. Add TWITCH_CLIENT_ID to GitHub Secrets.`;
        }
    }
    
    // Show manual API Server override only (if set)
    const manualOverride = storage.get('twitch_api_server') || '';
    if (apiServerEl) apiServerEl.value = manualOverride;
    
    // Show auto-detected API URL
    if (autoDetectedApiEl && typeof window.getWorkerApiUrl === 'function') {
        const autoUrl = window.getWorkerApiUrl();
        if (autoUrl && !manualOverride) {
            autoDetectedApiEl.innerHTML = `‚úÖ Auto-detected: <code style="background:var(--bg);padding:2px 6px;border-radius:3px">${autoUrl}</code>`;
        } else if (autoUrl && manualOverride) {
            autoDetectedApiEl.innerHTML = `‚ÑπÔ∏è Auto-detected: <code style="background:var(--bg);padding:2px 6px;border-radius:3px">${autoUrl}</code> (overridden)`;
        } else {
            autoDetectedApiEl.innerHTML = `‚ö†Ô∏è No auto-detected URL. Deploy via GitHub Actions or configure manually.`;
        }
    }
}

// Test Twitch API connection
async function testTwitchApi() {
    // Get API server URL
    let apiServer = '';
    if (typeof window.getWorkerApiUrl === 'function') {
        apiServer = window.getWorkerApiUrl() || '';
    }
    if (!apiServer) {
        apiServer = storage.get('twitch_api_server') || '';
    }
    
    const statusEl = document.getElementById('twitchApiStatus');
    
    if (!apiServer) {
        if (statusEl) statusEl.innerHTML = '<span style="color:var(--danger)">‚ùå API Server URL not configured</span>';
        return;
    }
    
    if (statusEl) statusEl.innerHTML = '<span style="color:var(--muted)">‚è≥ Testing connection...</span>';
    
    try {
        const response = await fetch(`${apiServer}/health`, { 
            method: 'GET',
            cache: 'no-store'
        });
        
        if (response.ok) {
            const data = await response.json();
            if (statusEl) statusEl.innerHTML = `<span style="color:var(--success)">‚úÖ Connected! ${data.message || 'API is healthy'}</span>`;
            log('Twitch API test: Connected successfully', 'success');
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    } catch (err) {
        if (statusEl) statusEl.innerHTML = `<span style="color:var(--danger)">‚ùå Failed: ${err.message}</span>`;
        log(`Twitch API test failed: ${err.message}`, 'error');
    }
}

// ============ Script Manager & Installer ============

// Script status tracking - which scripts are detected as installed
const scriptStatus = {
    initialized: false,
    connected: false,  // Whether we've successfully connected to OBS
    scripts: {},       // { scriptId: { installed: bool, version: string|null } }
    features: {        // Which features are available based on scripts
        sources: false,
        swap: false,
        text: false,
        animations: false
    }
};


// Detect if running in OBS dock (embedded CEF browser)
function isOBSDock() {
    // OBS docks have limited capabilities:
    // 1. window.open usually fails or returns null
    // 2. File downloads don't work properly
    // 3. Some APIs are restricted
    // We detect by checking the URL protocol and user agent hints
    const isFileProtocol = window.location.protocol === 'file:';
    const isEmbedded = !window.opener && window.parent === window;
    
    // If loaded via file:// and appears embedded, likely OBS dock
    return isFileProtocol && isEmbedded;
}

// Update UI based on dock context
function updateDockContextUI() {
    const isDock = isOBSDock();
    const downloadBtn = document.getElementById('downloadScriptBtn');
    const dockWarning = document.getElementById('dockDownloadWarning');
    const browserInstructions = document.getElementById('browserInstructions');
    const dockInstructions = document.getElementById('dockInstructions');
    
    if (downloadBtn) {
        if (isDock) {
            downloadBtn.classList.add('btn-warning');
            downloadBtn.classList.remove('btn-primary');
            downloadBtn.title = 'May not work in OBS dock - use Copy instead';
        } else {
            downloadBtn.classList.add('btn-primary');
            downloadBtn.classList.remove('btn-warning');
            downloadBtn.title = 'Download install script';
        }
    }
    
    if (dockWarning) dockWarning.style.display = isDock ? 'block' : 'none';
    if (browserInstructions) browserInstructions.style.display = isDock ? 'none' : 'block';
    if (dockInstructions) dockInstructions.style.display = isDock ? 'block' : 'none';
}

// Helper for opening URLs - handles OBS dock limitations
function openUrlOrCopy(url, description = 'URL') {
    // Try to open in new window/tab
    const win = window.open(url, '_blank');
    
    // If failed (OBS dock), copy to clipboard instead
    if (!win || win.closed || typeof win.closed === 'undefined') {
        navigator.clipboard.writeText(url).then(() => {
            log(description + ' copied to clipboard! OBS docks cannot open external windows.', 'info');
        }).catch(() => {
            prompt('Copy this URL:', url);
        });
        return false;
    }
    return true;
}


// Twitch auth URL (OBS dock compatible)
// Twitch auth - dynamically generated from configured values (no hardcoded external services!)

function openTwitchAuth() {
    const authUrl = getTwitchAuthUrl();
    
    if (!authUrl) {
        log('‚ö†Ô∏è Twitch Client ID not available. Deploy via GitHub Actions or check GitHub Secrets.', 'error');
        alert('Twitch Client ID not available!\n\nIf deployed via GitHub Pages, ensure TWITCH_CLIENT_ID is added to GitHub Secrets.\n\nOtherwise, you can manually add it in Setup ‚Üí Twitch API Settings.');
        return;
    }
    
    // Try to open - this works in regular browsers but not OBS docks
    const win = window.open(authUrl, '_blank');
    
    // If it failed or we're in OBS dock, copy to clipboard instead
    if (!win || win.closed || typeof win.closed === 'undefined') {
        copyTwitchAuthUrl();
    }
}

function copyTwitchAuthUrl() {
    const authUrl = getTwitchAuthUrl();
    
    if (!authUrl) {
        log('‚ö†Ô∏è Twitch Client ID not available. Deploy via GitHub Actions or check GitHub Secrets.', 'error');
        alert('Twitch Client ID not available!\n\nIf deployed via GitHub Pages, ensure TWITCH_CLIENT_ID is added to GitHub Secrets.\n\nOtherwise, you can manually add it in Setup ‚Üí Twitch API Settings.');
        return;
    }
    
    navigator.clipboard.writeText(authUrl).then(() => {
        // Show the hint about OBS dock limitation
        const hint = document.getElementById('twitchAuthHint');
        if (hint) {
            hint.style.display = 'block';
            // Auto-hide after 10 seconds
            setTimeout(() => { hint.style.display = 'none'; }, 10000);
        }
        log('Auth URL copied to clipboard! Paste in your browser.', 'success');
    }).catch(err => {
        log('Failed to copy: ' + err, 'error');
        // Fallback: show the URL in a prompt for manual copy
        prompt('Copy this URL and paste in your browser:', authUrl);
    });
}

// ============ Script Manager & Installer ============

// Map scripts to features they enable
const SCRIPT_FEATURE_MAP = {
    'source_animations': ['sources', 'animations'],
    'source_swap': ['swap'],
    'text_cycler': ['text'],
    'quick_controls': [],  // Utility script, no UI features
    'script_manager': []   // Meta script, no UI features
};

// Initialize script status from OBS connection
async function checkScriptStatus() {
    scriptStatus.initialized = true;
    
    // Use the global 'connected' variable which is the source of truth
    if (!connected) {
        scriptStatus.connected = false;
        updateFeatureAvailability();
        renderStartupBanner();
        return;
    }
    
    // We're connected!
    scriptStatus.connected = true;
    
    // Try to verify OBS version (optional - won't block if fails)
    try {
        const version = await sendRequest('GetVersion');
        if (version && version.obsVersion) {
            log('OBS ' + version.obsVersion + ' - All features enabled', 'success');
        }
    } catch (err) {
        // Non-critical - we're still connected
        console.warn('Version check failed:', err);
    }
    
    updateFeatureAvailability();
    renderStartupBanner();
}

// Try to detect which scripts are installed by checking OBS state
// Mark all scripts as available when connected
// (We can't reliably detect individual Lua scripts from WebSocket)
function markScriptsAsAvailable() {
    const scripts = window.Installer ? window.Installer.getAvailableScripts() : [];
    scripts.forEach(script => {
        scriptStatus.scripts[script.id] = { installed: true, version: script.version };
    });
}

// Update which features are available based on detected scripts
function updateFeatureAvailability() {
    // Simple logic: if connected, all features are available
    // We can't reliably detect individual Lua scripts from WebSocket
    const allEnabled = scriptStatus.connected;
    
    Object.keys(scriptStatus.features).forEach(f => {
        scriptStatus.features[f] = allEnabled;
    });
    
    // Also mark scripts as available when connected
    if (allEnabled) {
        markScriptsAsAvailable();
    }
    
    updateTabStates();
    updateDashboardStatus();
}

// Update tab visual states based on feature availability
function updateTabStates() {
    const tabs = document.querySelectorAll('.tab');
    const tabFeatures = {
        1: 'sources',   // Sources tab (index 1)
        2: 'text',      // Text tab (index 2)
        4: 'swap'       // Swaps tab (index 4)
    };
    
    tabs.forEach((tab, index) => {
        const feature = tabFeatures[index];
        if (feature && !scriptStatus.connected) {
            tab.classList.add('disabled');
            tab.title = 'Connect to OBS first';
        } else {
            tab.classList.remove('disabled');
        }
    });
    
    // Update dashboard status card
    updateDashboardStatus();
}

// Update the dashboard status card
function updateDashboardStatus() {
    const container = document.getElementById('dashboardScriptStatus');
    if (!container) return;
    
    if (scriptStatus.connected) {
        // Connected - show all features as available
        container.innerHTML = `
            <div class="script-status-grid">
                <div class="script-status-item installed">
                    <span class="script-status-item__icon">üîå</span>
                    <span class="script-status-item__name">OBS Connection</span>
                    <span class="script-status-item__badge">Online</span>
                </div>
                <div class="script-status-item installed">
                    <span class="script-status-item__icon">‚ú®</span>
                    <span class="script-status-item__name">Animations</span>
                    <span class="script-status-item__badge">Ready</span>
                </div>
                <div class="script-status-item installed">
                    <span class="script-status-item__icon">üîÑ</span>
                    <span class="script-status-item__name">Source Swap</span>
                    <span class="script-status-item__badge">Ready</span>
                </div>
                <div class="script-status-item installed">
                    <span class="script-status-item__icon">üìù</span>
                    <span class="script-status-item__name">Text Cycler</span>
                    <span class="script-status-item__badge">Ready</span>
                </div>
            </div>
            <p class="hint" style="margin-top:8px">
                ‚úÖ All features available! Use the tabs above to access each feature.
            </p>
        `;
    } else {
        // Not connected - show warning
        container.innerHTML = `
            <div class="script-status-grid">
                <div class="script-status-item missing">
                    <span class="script-status-item__icon">üîå</span>
                    <span class="script-status-item__name">OBS Connection</span>
                    <span class="script-status-item__badge">Offline</span>
                </div>
            </div>
            <p class="hint" style="margin-top:8px">
                <button onclick="showPage('setup')" class="btn-link">‚öôÔ∏è Go to Setup</button> to connect to OBS WebSocket
            </p>
            <p class="hint" style="margin-top:4px">
                <button onclick="showPage('install')" class="btn-link">üì• Install Scripts</button> if you haven't already
            </p>
        `;
    }
}

// Render startup banner based on current state
function renderStartupBanner() {
    // Remove existing banner
    const existingBanner = document.getElementById('startupBanner');
    if (existingBanner) existingBanner.remove();
    
    // Determine banner state
    let bannerHTML = '';
    
    if (!scriptStatus.connected) {
        bannerHTML = `
            <div id="startupBanner" class="startup-banner">
                <span class="startup-banner__icon">üîå</span>
                <div class="startup-banner__content">
                    <div class="startup-banner__title">Not Connected to OBS</div>
                    <div class="startup-banner__text">Connect to OBS WebSocket to enable all features. Some features require Lua scripts to be installed.</div>
                </div>
                <button class="startup-banner__action" onclick="showPage('setup')">‚öôÔ∏è Setup</button>
            </div>
        `;
    } else {
        // Connected - show success briefly then fade
        bannerHTML = `
            <div id="startupBanner" class="startup-banner success">
                <span class="startup-banner__icon">‚úÖ</span>
                <div class="startup-banner__content">
                    <div class="startup-banner__title">Connected to OBS</div>
                    <div class="startup-banner__text">All features are available. Scripts detected and ready.</div>
                </div>
            </div>
        `;
    }
    
    // Insert banner at top of content area
    const content = document.querySelector('.content');
    if (content && bannerHTML) {
        content.insertAdjacentHTML('afterbegin', bannerHTML);
        
        // Auto-hide success banner after 5 seconds
        if (scriptStatus.connected) {
            setTimeout(() => {
                const banner = document.getElementById('startupBanner');
                if (banner) {
                    banner.style.transition = 'opacity 0.3s, height 0.3s, margin 0.3s, padding 0.3s';
                    banner.style.opacity = '0';
                    banner.style.height = '0';
                    banner.style.margin = '0';
                    banner.style.padding = '0';
                    banner.style.overflow = 'hidden';
                    setTimeout(() => banner.remove(), 300);
                }
            }, 5000);
        }
    }
}

// Render feature notice for a specific page
function renderFeatureNotice(containerId, featureId, scriptName) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Remove existing notice
    const existing = container.querySelector('.feature-notice');
    if (existing) existing.remove();
    
    if (!scriptStatus.connected) {
        const notice = document.createElement('div');
        notice.className = 'feature-notice error';
        notice.innerHTML = `
            <div class="feature-notice__title">‚ö†Ô∏è Connection Required</div>
            <div class="feature-notice__text">
                Connect to OBS WebSocket to use this feature. 
                <button onclick="showPage('setup')" class="btn-link">Go to Setup ‚Üí</button>
            </div>
        `;
        container.insertBefore(notice, container.firstChild);
    } else if (!scriptStatus.features[featureId]) {
        const notice = document.createElement('div');
        notice.className = 'feature-notice';
        notice.innerHTML = `
            <div class="feature-notice__title">üìú Script Required: ${scriptName}</div>
            <div class="feature-notice__text">
                This feature requires the ${scriptName} Lua script. 
                <button onclick="showPage('install')" class="btn-link">Go to Installer ‚Üí</button>
            </div>
        `;
        container.insertBefore(notice, container.firstChild);
    }
}

// ============ Installer Module ============
// Installer functionality is now in assets/js/modules/installer.js
// The initScriptsAndInstaller() function is already available globally from that file
// No alias needed - use it directly!


// ============ Version Management ============
const APP_VERSION = {
    // Component versions - update these when releasing
    controlPanel: '1.3.0',
    sourceAnimations: '2.8.1',
    sourceSwap: '3.1.0',
    sourceLayouts: '1.0.0',
    textCycler: '1.0.0',
    quickControls: '1.0.0',
    scriptManager: '1.3.0'
};

// GitHub repository configuration
const GITHUB_REPO = 'Underwood-Inc/strixun-stream-suite';
const GITHUB_RAW_BASE = `https://raw.githubusercontent.com/${GITHUB_REPO}/main`;
const GITHUB_REPO_URL = `https://github.com/${GITHUB_REPO}`;
const GITHUB_PAGES_URL = 'https://underwood-inc.github.io/strixun-stream-suite';

// Default OAuth callback URL (GitHub Pages hosted)
const DEFAULT_OAUTH_CALLBACK = `${GITHUB_PAGES_URL}/twitch_auth_callback.html`;

// Get the main display version (control panel version)
function getLocalVersion() {
    return APP_VERSION.controlPanel;
}

// Parse version string to comparable array
function parseVersion(versionStr) {
    if (!versionStr || typeof versionStr !== 'string') return [0, 0, 0];
    const match = versionStr.match(/(\d+)\.(\d+)\.(\d+)/);
    if (!match) return [0, 0, 0];
    return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
}

// Compare two versions: returns -1 if a < b, 0 if a == b, 1 if a > b
function compareVersions(a, b) {
    const vA = parseVersion(a);
    const vB = parseVersion(b);
    for (let i = 0; i < 3; i++) {
        if (vA[i] < vB[i]) return -1;
        if (vA[i] > vB[i]) return 1;
    }
    return 0;
}

// Update local version display
function updateLocalVersionDisplay() {
    const el = document.getElementById('localVersion');
    if (el) el.textContent = `v${getLocalVersion()}`;
}

// Check for updates from GitHub
async function checkForUpdates() {
    const statusEl = document.getElementById('versionStatus');
    const remoteEl = document.getElementById('remoteVersion');
    const lastCheckEl = document.getElementById('lastVersionCheck');
    
    if (statusEl) {
        statusEl.style.background = 'rgba(255,255,255,0.05)';
        statusEl.innerHTML = '<span style="color:var(--muted)">‚è≥ Checking for updates...</span>';
    }
    
    try {
        // Fetch package.json from GitHub main branch
        const response = await fetch(`${GITHUB_RAW_BASE}/package.json?t=${Date.now()}`, {
            cache: 'no-store'
        });
        
        if (!response.ok) {
            throw new Error(`GitHub fetch failed: ${response.status}`);
        }
        
        const packageJson = await response.json();
        const remoteVersion = packageJson.version || '0.0.0';
        
        if (remoteEl) remoteEl.textContent = `v${remoteVersion}`;
        
        const localVersion = getLocalVersion();
        const comparison = compareVersions(localVersion, remoteVersion);
        
        if (statusEl) {
            if (comparison < 0) {
                // Local is behind remote - update available!
                statusEl.style.background = 'rgba(255,200,0,0.15)';
                statusEl.style.borderLeft = '3px solid var(--warning)';
                statusEl.innerHTML = `
                    <span style="color:var(--warning);font-weight:600">‚ö†Ô∏è Update Available!</span><br>
                    <span style="font-size:0.9em;color:var(--muted)">
                        ${localVersion} ‚Üí ${remoteVersion}
                    </span>
                `;
            } else if (comparison > 0) {
                // Local is ahead (development version)
                statusEl.style.background = 'rgba(100,200,255,0.15)';
                statusEl.style.borderLeft = '3px solid var(--accent)';
                statusEl.innerHTML = '<span style="color:var(--accent)">üîß Development Version</span>';
            } else {
                // Up to date
                statusEl.style.background = 'rgba(0,255,100,0.1)';
                statusEl.style.borderLeft = '3px solid var(--success)';
                statusEl.innerHTML = '<span style="color:var(--success)">‚úÖ Up to Date</span>';
            }
        }
        
        // Store last check time
        const now = new Date();
        storage.set('lastVersionCheck', now.toISOString());
        storage.set('lastRemoteVersion', remoteVersion);
        
        if (lastCheckEl) {
            lastCheckEl.textContent = `Last checked: ${now.toLocaleTimeString()}`;
        }
        
        log(`Version check: local v${localVersion}, remote v${remoteVersion}`, comparison < 0 ? 'warning' : 'success');
        
    } catch (err) {
        console.error('[Version] Check failed:', err);
        
        // Try to show cached version if available
        const cachedVersion = storage.get('lastRemoteVersion');
        if (remoteEl && cachedVersion) {
            remoteEl.textContent = `v${cachedVersion} (cached)`;
        } else if (remoteEl) {
            remoteEl.textContent = '(unavailable)';
        }
        
        if (statusEl) {
            statusEl.style.background = 'rgba(255,100,100,0.1)';
            statusEl.style.borderLeft = '3px solid var(--danger)';
            statusEl.innerHTML = `
                <span style="color:var(--danger)">‚ùå Check Failed</span><br>
                <span style="font-size:0.85em;color:var(--muted)">${err.message}</span>
            `;
        }
        
        log(`Version check failed: ${err.message}`, 'error');
    }
}

// Open GitHub repository
function openGitHubRepo() {
    openUrlOrCopy(GITHUB_REPO_URL, 'GitHub Repository');
}

// Initialize version display on load
function initVersionDisplay() {
    updateLocalVersionDisplay();
    
    // Show cached data if available
    const lastCheck = storage.get('lastVersionCheck');
    const cachedVersion = storage.get('lastRemoteVersion');
    const lastCheckEl = document.getElementById('lastVersionCheck');
    const remoteEl = document.getElementById('remoteVersion');
    
    if (lastCheck && lastCheckEl) {
        const date = new Date(lastCheck);
        lastCheckEl.textContent = `Last checked: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
    }
    
    if (cachedVersion && remoteEl) {
        remoteEl.textContent = `v${cachedVersion} (cached)`;
        
        // Show cached comparison
        const comparison = compareVersions(getLocalVersion(), cachedVersion);
        const statusEl = document.getElementById('versionStatus');
        if (statusEl && comparison < 0) {
            statusEl.style.background = 'rgba(255,200,0,0.15)';
            statusEl.style.borderLeft = '3px solid var(--warning)';
            statusEl.innerHTML = `
                <span style="color:var(--warning);font-weight:600">‚ö†Ô∏è Update May Be Available</span><br>
                <span style="font-size:0.85em;color:var(--muted)">(cached - click to refresh)</span>
            `;
        }
    }
}


// ============ Keyboard Shortcuts ============
document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    // 1-9 triggers saved swap configs
    if (e.key >= '1' && e.key <= '9') {
        const idx = parseInt(e.key) - 1;
        const swapConfigs = window.SourceSwaps ? window.SourceSwaps.getConfigs() : [];
        if (idx < swapConfigs.length) loadSwapConfig(idx);
    }
    // Space toggles text cycler
    if (e.key === ' ') {
        e.preventDefault();
        cycleInterval ? stopTextCycle() : startTextCycle();
    }
});
</script>
</body>
</html>

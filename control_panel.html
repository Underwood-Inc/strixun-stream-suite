<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBS Animation Suite</title>
    <link rel="stylesheet" href="assets/css/control-panel.css">
</head>
<body>
    <div class="app">
        <header class="header">
            <h1><span class="status-dot" id="statusDot"></span><span class="title-text">Animation Suite</span></h1>
            <div style="display:flex;gap:4px">
                <button onclick="location.reload()" title="Reload Panel">üîÑ</button>
                <button onclick="showPage('setup')" id="connectHeaderBtn">Connect</button>
            </div>
        </header>
        
        <nav class="tabs">
            <button class="tab active" onclick="showPage('dashboard')" title="Dashboard">üè†</button>
            <button class="tab" onclick="showPage('sources')" title="Sources">üì¶</button>
            <button class="tab" onclick="showPage('text')" title="Text Cycler">üìù</button>
            <button class="tab" onclick="showPage('clips')" title="Clips Player">üé¨</button>
            <button class="tab" onclick="showPage('swaps')" title="Swaps">üîÑ</button>
            <button class="tab" onclick="showPage('scripts')" title="Script Manager">üìú</button>
            <button class="tab" onclick="showPage('install')" title="Installer">üì•</button>
            <button class="tab" onclick="showPage('setup')" title="Setup">‚öôÔ∏è</button>
        </nav>
        
        <div class="split-container">
            <main class="split-main content">
                <!-- Dashboard -->
                <div id="page-dashboard" class="page active">
                <!-- Script Status Card -->
                <div class="card" id="dashboardStatusCard">
                    <h3>üìä System Status</h3>
                    <div id="dashboardScriptStatus">
                        <div class="script-status-grid">
                            <div class="script-status-item missing">
                                <span class="script-status-item__icon">üîå</span>
                                <span class="script-status-item__name">OBS Connection</span>
                                <span class="script-status-item__badge">Offline</span>
                            </div>
                        </div>
                        <p class="hint" style="margin-top:8px">
                            <button onclick="showPage('setup')" class="btn-link">‚öôÔ∏è Go to Setup</button> to connect to OBS WebSocket
                        </p>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Quick Actions</h3>
                    <div class="grid">
                        <button class="source-btn requires-connection" onclick="cycleAspect()">üîÑ Cycle Aspect</button>
                        <button class="source-btn requires-connection" onclick="refreshScenes()">üîÉ Refresh</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Current Scene</h3>
                    <div id="currentScene" class="empty-state">Connect to OBS first</div>
                </div>
                
                <div class="card">
                    <h3>Quick Swaps</h3>
                    <div class="grid" id="dashSwapGrid"></div>
                </div>
            </div>
            
            <!-- Sources -->
            <div id="page-sources" class="page">
                <div class="card">
                    <h3>Visibility Animation</h3>
                    <label>Animation Type</label>
                    <select id="visAnimType">
                        <option value="none">None (instant)</option>
                        <option value="fade" selected>Fade</option>
                        <option value="slide_left">Slide Left</option>
                        <option value="slide_right">Slide Right</option>
                        <option value="slide_up">Slide Up</option>
                        <option value="slide_down">Slide Down</option>
                        <option value="zoom">Zoom</option>
                        <option value="pop">Pop (overshoot)</option>
                    </select>
                    <div class="row" style="margin-top:8px">
                        <div>
                            <label>Duration (ms)</label>
                            <input type="number" id="visAnimDuration" value="300" min="50" max="2000" step="50">
                        </div>
                        <div>
                            <label>Easing</label>
                            <select id="visAnimEasing">
                                <option value="ease">Ease</option>
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut" selected>Ease Out</option>
                                <option value="bounce">Bounce</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Scene Sources</h3>
                    <button onclick="refreshSources()" class="btn-secondary" style="width:100%;margin-bottom:12px">üîÉ Refresh</button>
                    <div class="search-box">
                        <input type="text" class="search-box__input" id="sourcesSearchInput" placeholder="Search sources...">
                        <span class="search-box__icon">üîç</span>
                        <button class="search-box__clear" title="Clear">‚úï</button>
                    </div>
                    <div id="sourcesList"></div>
                </div>
            </div>
            
            <!-- Text Cycler -->
            <div id="page-text" class="page">
                <!-- Saved Configs -->
                <div class="card">
                    <h3>üíæ Saved Configs</h3>
                    <div class="search-box">
                        <input type="text" class="search-box__input" id="textConfigsSearchInput" placeholder="Search configs...">
                        <span class="search-box__icon">üîç</span>
                        <button class="search-box__clear" title="Clear">‚úï</button>
                    </div>
                    <div id="textCyclerConfigs" class="config-list"></div>
                    <div class="row" style="margin-top:8px">
                        <button onclick="newTextConfig()">‚ûï New Config</button>
                        <button onclick="exportTextConfigs()">üì§ Export</button>
                        <button onclick="importTextConfigs()">üì• Import</button>
                    </div>
                </div>

                <!-- Config Editor -->
                <div class="card" id="textConfigEditor" style="display:none">
                    <h3>‚úèÔ∏è Edit Config</h3>
                    <label>Config Name</label>
                    <input type="text" id="textConfigName" placeholder="My Text Cycler">
                    
                    <label>Mode</label>
                    <select id="textCyclerMode" onchange="updateTextCyclerMode()">
                        <option value="browser">Browser Source (smooth CSS animations)</option>
                        <option value="legacy">Legacy (OBS text source)</option>
                    </select>
                    <p id="modeInfo" style="font-size:0.75em;color:var(--muted);margin:4px 0 8px"></p>
                    
                    <div id="browserModeSettings">
                        <label>Config ID (for browser source URL)</label>
                        <div class="url-box">
                            <input type="text" id="textConfigId" placeholder="config1" style="flex:1" oninput="updateBrowserSourceUrlPreview()">
                            <button onclick="copyBrowserSourceUrl()">üìã Copy URL</button>
                        </div>
                        <p style="font-size:0.7em;color:var(--muted);margin-top:4px">
                            Add as OBS Browser Source: <code id="browserSourceUrlPreview"></code>
                        </p>
                    </div>
                    
                    <div id="legacyModeSettings" style="display:none">
                        <label>Text Source</label>
                        <select id="textSource" onchange="loadTextSource()">
                            <option value="">-- Select Text Source --</option>
                        </select>
                    </div>
                </div>

                <!-- Text Lines -->
                <div class="card" id="textLinesCard" style="display:none">
                    <h3>üìù Text Lines</h3>
                    <textarea id="textLines" placeholder="Enter text lines (one per line)&#10;Line 1&#10;Line 2&#10;Line 3" rows="5"></textarea>
                </div>
                
                <!-- Animation Settings -->
                <div class="card" id="textAnimationCard" style="display:none">
                    <h3>üé¨ Animation</h3>
                    <label>Transition Effect</label>
                    <select id="textTransition" onchange="updateTransitionMode()">
                        <option value="none">None (instant)</option>
                        <option value="fade">Fade</option>
                        <option value="obfuscate">Obfuscate (Minecraft enchant)</option>
                        <option value="typewriter">Typewriter</option>
                        <option value="glitch">Glitch</option>
                        <option value="scramble">Scramble ‚Üí Snap</option>
                        <option value="wave">Wave Reveal</option>
                        <option value="slide_left">Slide Left</option>
                        <option value="slide_right">Slide Right</option>
                        <option value="slide_up">Slide Up</option>
                        <option value="slide_down">Slide Down</option>
                        <option value="pop">Pop</option>
                    </select>
                    <p id="transitionInfo" style="font-size:0.75em;color:var(--muted);margin:4px 0 12px"></p>
                    <div class="row">
                        <div>
                            <label>Transition (ms)</label>
                            <input type="number" id="transDuration" value="500" min="100" max="3000" step="50">
                        </div>
                        <div>
                            <label>Cycle (ms)</label>
                            <input type="number" id="textDuration" value="3000" min="500" step="100">
                        </div>
                    </div>
                </div>

                <!-- Style Settings (Browser Mode Only) -->
                <div class="card" id="textStyleCard" style="display:none">
                    <h3>üé® Style (Browser Mode)</h3>
                    
                    <label>Font Family</label>
                    <select id="textFontFamily">
                        <option value="'Segoe UI', system-ui, sans-serif">Segoe UI (Default)</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="'Helvetica Neue', Helvetica, sans-serif">Helvetica</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="'Times New Roman', serif">Times New Roman</option>
                        <option value="'Courier New', monospace">Courier New</option>
                        <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                        <option value="Impact, sans-serif">Impact</option>
                        <option value="'Comic Sans MS', cursive">Comic Sans</option>
                    </select>
                    <input type="text" id="textFontFamilyCustom" placeholder="Or enter custom font: 'Font Name', fallback" style="margin-top:4px">
                    
                    <div class="row" style="margin-top:12px">
                        <div>
                            <label>Font Size</label>
                            <input type="text" id="textFontSize" value="48px" placeholder="48px">
                        </div>
                        <div>
                            <label>Font Weight</label>
                            <select id="textFontWeight">
                                <option value="100">Thin</option>
                                <option value="300">Light</option>
                                <option value="400">Normal</option>
                                <option value="500">Medium</option>
                                <option value="600">Semi-Bold</option>
                                <option value="700" selected>Bold</option>
                                <option value="800">Extra Bold</option>
                                <option value="900">Black</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="row">
                        <div>
                            <label>Text Color</label>
                            <div style="display:flex;gap:4px">
                                <input type="color" id="textColorPicker" value="#ffffff" style="width:40px;height:32px;padding:0;border:none;cursor:pointer">
                                <input type="text" id="textColor" value="#ffffff" placeholder="#ffffff" style="flex:1">
                            </div>
                        </div>
                        <div>
                            <label>Text Align</label>
                            <select id="textAlign">
                                <option value="center" selected>Center</option>
                                <option value="left">Left</option>
                                <option value="right">Right</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="row">
                        <div>
                            <label>Letter Spacing</label>
                            <input type="text" id="textLetterSpacing" value="normal" placeholder="normal, 2px, 0.1em">
                        </div>
                        <div>
                            <label>Line Height</label>
                            <input type="text" id="textLineHeight" value="1.2" placeholder="1.2, 1.5, 2">
                        </div>
                    </div>
                    
                    <div class="row">
                        <div>
                            <label>Text Transform</label>
                            <select id="textTransform">
                                <option value="none" selected>None</option>
                                <option value="uppercase">UPPERCASE</option>
                                <option value="lowercase">lowercase</option>
                                <option value="capitalize">Capitalize</option>
                            </select>
                        </div>
                        <div>
                            <label>Font Style</label>
                            <select id="textFontStyle">
                                <option value="normal" selected>Normal</option>
                                <option value="italic">Italic</option>
                            </select>
                        </div>
                    </div>
                    
                    <label>Text Shadow</label>
                    <input type="text" id="textShadow" value="2px 2px 4px rgba(0,0,0,0.5)" placeholder="2px 2px 4px rgba(0,0,0,0.5)">
                    
                    <label style="margin-top:8px">Text Stroke (Outline)</label>
                    <div class="row">
                        <div>
                            <input type="text" id="textStrokeWidth" value="0" placeholder="Width: 0, 1px, 2px">
                        </div>
                        <div>
                            <div style="display:flex;gap:4px">
                                <input type="color" id="textStrokeColorPicker" value="#000000" style="width:40px;height:32px;padding:0;border:none;cursor:pointer">
                                <input type="text" id="textStrokeColor" value="#000000" placeholder="#000000" style="flex:1">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Preview -->
                <div class="card" id="textPreviewCard" style="display:none">
                    <h3>üëÅÔ∏è Preview</h3>
                    <div class="text-preview" id="textPreview">Select or create a config</div>
                </div>
                
                <!-- Controls -->
                <div id="textControls" style="display:none">
                    <div class="row">
                        <button class="btn-success btn-lg" id="startCycleBtn" onclick="startTextCycler()">‚ñ∂ Start</button>
                        <button class="btn-danger btn-lg" id="stopCycleBtn" onclick="stopTextCycler()" disabled>‚ñ† Stop</button>
                    </div>
                    <div class="row" style="margin-top:8px">
                        <button onclick="saveCurrentTextConfig()">üíæ Save Config</button>
                        <button onclick="deleteCurrentTextConfig()" style="background:var(--danger);border-color:var(--danger)">üóëÔ∏è Delete</button>
                    </div>
                </div>
            </div>
            
            <!-- Clips Player -->
            <div id="page-clips" class="page">
                <!-- Saved Clip Configs -->
                <div class="card">
                    <h3>üé¨ Twitch Clips Player</h3>
                    <p style="color:var(--muted);font-size:0.85em;margin-bottom:8px">
                        Auto-play Twitch clips during BRB/Starting screens. Based on 
                        <button onclick="openUrlOrCopy('https://github.com/teklynk/twitch_clips_player', 'GitHub URL')" class="btn-link">teklynk/twitch_clips_player</button>
                    </p>
                    <div id="clipsConfigs" class="config-list"></div>
                    <div class="row" style="margin-top:8px">
                        <button onclick="newClipsConfig()">‚ûï New Config</button>
                        <button onclick="exportClipsConfigs()">üì§ Export</button>
                        <button onclick="importClipsConfigs()">üì• Import</button>
                    </div>
                </div>

                <!-- Config Editor -->
                <div class="card" id="clipsConfigEditor" style="display:none">
                    <h3>‚úèÔ∏è Edit Config</h3>
                    
                    <label>Config Name</label>
                    <input type="text" id="clipsConfigName" placeholder="BRB Screen Clips">
                    
                    <label>Main Twitch Channel</label>
                    <input type="text" id="clipsMainChannel" placeholder="YourChannel">
                    <p class="hint">Your channel name for chat commands</p>
                    
                    <label>Channels to Pull Clips From</label>
                    <textarea id="clipsChannels" rows="3" placeholder="Channel1, Channel2, Channel3&#10;Leave empty if using 'Show Following'"></textarea>
                    <p class="hint">Comma separated. Leave empty to use followed channels</p>
                    
                    <div class="row">
                        <div class="form-check">
                            <input type="checkbox" id="clipsShowFollowing">
                            <label for="clipsShowFollowing">Show clips from followed channels</label>
                        </div>
                    </div>
                    
                    <div id="clipsExcludeSection" style="display:none">
                        <label>Exclude Channels</label>
                        <textarea id="clipsExclude" rows="2" placeholder="Channel1, Channel2"></textarea>
                    </div>
                </div>

                <!-- Clip Settings -->
                <div class="card" id="clipsSettingsCard" style="display:none">
                    <h3>üìã Clip Settings</h3>
                    
                    <div class="row">
                        <div>
                            <label>Max Clips</label>
                            <input type="range" id="clipsLimit" min="10" max="100" step="10" value="20">
                            <span id="clipsLimitValue" class="range-value">20</span>
                        </div>
                        <div>
                            <label>Date Range (days)</label>
                            <input type="range" id="clipsDateRange" min="0" max="360" step="10" value="0">
                            <span id="clipsDateRangeValue" class="range-value">0 (all)</span>
                        </div>
                    </div>
                    
                    <div class="row">
                        <div class="form-check">
                            <input type="checkbox" id="clipsPreferFeatured">
                            <label for="clipsPreferFeatured">Prefer featured clips</label>
                        </div>
                    </div>
                </div>

                <!-- Display Settings -->
                <div class="card" id="clipsDisplayCard" style="display:none">
                    <h3>üé® Display Settings</h3>
                    
                    <div class="row">
                        <div class="form-check">
                            <input type="checkbox" id="clipsShowText" checked>
                            <label for="clipsShowText">Show channel name overlay</label>
                        </div>
                    </div>
                    
                    <div id="clipsCustomTextSection">
                        <label>Custom Overlay Text</label>
                        <input type="text" id="clipsCustomText" placeholder="Go check out {channel}">
                        <p class="hint">Use {channel} for channel name</p>
                    </div>
                    
                    <div class="row">
                        <div class="form-check">
                            <input type="checkbox" id="clipsShowDetails" checked>
                            <label for="clipsShowDetails">Show clip details panel</label>
                        </div>
                    </div>
                    
                    <div id="clipsDetailsSection">
                        <label>Details Panel Text</label>
                        <textarea id="clipsDetailsText" rows="3" placeholder="{title}&#10;While streaming {game}&#10;Clipped by {creator_name} {created_at}"></textarea>
                        <p class="hint">Variables: {title}, {channel}, {game}, {creator_name}, {created_at}</p>
                    </div>
                    
                    <label>Theme</label>
                    <select id="clipsTheme">
                        <option value="0">None</option>
                        <option value="1">Slide in fancy skewed</option>
                        <option value="2" selected>Slide in basic</option>
                        <option value="3">Outside the box</option>
                    </select>
                </div>

                <!-- Chat Commands -->
                <div class="card" id="clipsChatCard" style="display:none">
                    <h3>üí¨ Chat Commands</h3>
                    
                    <label>Custom Start Command (optional)</label>
                    <input type="text" id="clipsCommand" placeholder="playclips">
                    <p class="hint">If set, clips only play when !command is used. Leave empty to auto-play</p>
                    
                    <div class="info-box" style="margin-top:12px">
                        <strong>Built-in Commands (Mods only):</strong>
                        <ul style="margin:4px 0 0 16px;font-size:0.85em">
                            <li>!clipskip - Skip current clip</li>
                            <li>!clippause - Pause playback</li>
                            <li>!clipplay - Resume playback</li>
                            <li>!clipreload - Reload player</li>
                        </ul>
                    </div>
                </div>

                <!-- Auth -->
                <div class="card" id="clipsAuthCard" style="display:none">
                    <h3>üîê Twitch Auth</h3>
                    <p class="hint" style="margin-bottom:8px">Required for "Show Following" and chat messages</p>
                    
                    <label>Access Token</label>
                    <div class="url-box">
                        <input type="password" id="clipsAccessToken" placeholder="oauth:xxxxxxxxxx">
                        <button onclick="toggleClipsTokenVisibility()">üëÅÔ∏è</button>
                    </div>
                    <div class="hint" style="margin-top:8px">
                        <button onclick="openTwitchAuth()" class="btn-link">üîó Get Access Token from Twitch</button>
                        <button onclick="copyTwitchAuthUrl()" style="margin-left:4px" title="Copy auth URL to clipboard">üìã</button>
                    </div>
                    <p class="hint" id="twitchAuthHint" style="display:none;margin-top:4px;padding:6px;background:var(--bg);border-radius:4px">
                        ‚ö†Ô∏è OBS docks can't open external browsers. URL copied to clipboard - paste it in your browser!
                    </p>
                </div>

                <!-- Preview & Actions -->
                <div class="card" id="clipsPreviewCard" style="display:none">
                    <h3>üîó Browser Source URL</h3>
                    <div class="url-box">
                        <input type="text" id="clipsGeneratedUrl" readonly placeholder="Configure settings above...">
                        <button onclick="copyClipsUrl()">üìã Copy</button>
                    </div>
                    <p class="hint">Add this as a Browser Source in OBS. Never share this URL!</p>
                    
                    <div class="row" style="margin-top:12px">
                        <button onclick="generateClipsUrl()">üîÑ Generate URL</button>
                        <button onclick="testClipsPlayer()" style="background:var(--success);border-color:var(--success)">‚ñ∂ Test in Browser</button>
                    </div>
                </div>

                <!-- Controls -->
                <div id="clipsControls" style="display:none">
                    <div class="row">
                        <button onclick="saveCurrentClipsConfig()">üíæ Save Config</button>
                        <button onclick="deleteCurrentClipsConfig()" style="background:var(--danger);border-color:var(--danger)">üóëÔ∏è Delete</button>
                    </div>
                </div>
            </div>
            
            <!-- Swaps -->
            <div id="page-swaps" class="page">
                <div class="card">
                    <h3>Quick Swap</h3>
                    <p style="color:var(--muted);margin-bottom:12px;font-size:0.85em">Select two sources and swap their position/size</p>
                    <label>Source A</label>
                    <select id="swapSourceA"></select>
                    <label>Source B</label>
                    <select id="swapSourceB"></select>
                    <div class="row" style="margin-top:8px">
                        <button class="btn-primary btn-lg" onclick="executeSwap()">üîÑ Swap Now</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Animation</h3>
                    <label>Style</label>
                    <select id="swapStyle">
                        <option value="slide" selected>Slide (smooth move)</option>
                        <option value="teleport">Teleport (instant)</option>
                        <option value="scale">Scale (shrink/grow)</option>
                        <option value="bounce">Bounce (overshoot)</option>
                        <option value="elastic">Elastic (springy)</option>
                        <option value="arc">Arc (curved path)</option>
                    </select>
                    <div class="row">
                        <div>
                            <label>Duration (ms)</label>
                            <input type="number" id="swapDuration" value="400" min="0" max="3000" step="50">
                        </div>
                        <div>
                            <label>Easing</label>
                            <select id="swapEasing">
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut">Ease Out</option>
                                <option value="ease" selected>Ease In-Out</option>
                                <option value="back">Back (overshoot)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div style="margin-top:12px">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                            <input type="checkbox" id="swapPreserveAspect" checked>
                            <span>Preserve Aspect Ratio (default)</span>
                        </label>
                    </div>
                    
                    <div style="margin-top:8px">
                        <label>‚ö° Temporary Override</label>
                        <select id="swapTempOverride">
                            <option value="off" selected>Off (use config/global)</option>
                            <option value="preserve">Preserve</option>
                            <option value="stretch">Stretch</option>
                        </select>
                        <p style="font-size:0.75em;color:var(--muted);margin:4px 0 0">Force Preserve or Stretch for ALL swaps until set back to Off</p>
                    </div>
                    
                    <div style="margin-top:8px">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                            <input type="checkbox" id="swapDebugLogging">
                            <span>Debug Logging</span>
                        </label>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Add Swap Config</h3>
                    <label>Config Name</label>
                    <input type="text" id="swapConfigName" placeholder="e.g. Camera ‚Üî Gameplay">
                    <div class="row" style="margin-top:8px">
                        <div style="flex:1">
                            <label>Source A</label>
                            <select id="swapNewSourceA"></select>
                        </div>
                        <div style="flex:1">
                            <label>Source B</label>
                            <select id="swapNewSourceB"></select>
                        </div>
                    </div>
                    <button class="btn-primary" style="margin-top:12px;width:100%" onclick="addSwapConfig()">‚ûï Add Config</button>
                </div>
                
                <div class="card">
                    <h3>Saved Configs</h3>
                    <div class="search-box">
                        <input type="text" class="search-box__input" id="swapConfigsSearchInput" placeholder="Search configs...">
                        <span class="search-box__icon">üîç</span>
                        <button class="search-box__clear" title="Clear">‚úï</button>
                    </div>
                    <div id="savedSwaps"></div>
                    <div class="row" style="margin-top:8px">
                        <button onclick="refreshSwapSources()">üîÑ Refresh Sources</button>
                        <button onclick="exportConfigs()">üì§ Export</button>
                        <button onclick="importConfigs()">üì• Import</button>
                    </div>
                </div>
            </div>
            
            <!-- Script Manager -->
            <div id="page-scripts" class="page">
                <div class="card">
                    <h3>üìú OBS Animation Suite Scripts</h3>
                    <p class="hint" style="margin-bottom:12px">Lua scripts that run inside OBS Studio. Install via the Installer tab.</p>
                    
                    <div id="scriptsList" class="scripts-grid"></div>
                </div>
                
                <div class="card">
                    <h3>üåê Browser Sources</h3>
                    <p class="hint" style="margin-bottom:12px">HTML files to add as Browser Sources in OBS.</p>
                    
                    <div class="scripts-grid">
                        <div class="script-card">
                            <div class="script-header">
                                <span class="script-icon">üé¨</span>
                                <div>
                                    <div class="script-name">Text Cycler Display</div>
                                    <div class="script-version">Browser Source</div>
                                </div>
                            </div>
                            <p class="script-desc">Beautiful CSS-animated text display. Receives messages from the control panel for smooth text cycling effects.</p>
                            <div class="script-file">text_cycler_display.html</div>
                        </div>
                        
                        <div class="script-card">
                            <div class="script-header">
                                <span class="script-icon">üì∫</span>
                                <div>
                                    <div class="script-name">Twitch Clips Player</div>
                                    <div class="script-version">Browser Source</div>
                                </div>
                            </div>
                            <p class="script-desc">Auto-plays Twitch clips during BRB/Starting scenes. Configurable channels, themes, and chat commands.</p>
                            <div class="script-file">twitch_clips_player/clips.html</div>
                        </div>
                        
                        <div class="script-card">
                            <div class="script-header">
                                <span class="script-icon">üéõÔ∏è</span>
                                <div>
                                    <div class="script-name">Control Panel Dock</div>
                                    <div class="script-version">Custom Dock</div>
                                </div>
                            </div>
                            <p class="script-desc">This control panel! Add as a Custom Browser Dock in OBS for quick access to all features.</p>
                            <div class="script-file">control_panel.html</div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>üìñ Quick Reference</h3>
                    <div class="info-box">
                        <strong>Adding Scripts to OBS:</strong>
                        <ol style="margin:8px 0 0 16px;font-size:0.85em">
                            <li>Tools ‚Üí Scripts</li>
                            <li>Click + (Add Scripts)</li>
                            <li>Navigate to your script folder</li>
                            <li>Select the .lua files</li>
                        </ol>
                    </div>
                    <div class="info-box" style="margin-top:8px">
                        <strong>Adding Custom Browser Dock:</strong>
                        <ol style="margin:8px 0 0 16px;font-size:0.85em">
                            <li>View ‚Üí Docks ‚Üí Custom Browser Docks</li>
                            <li>Name: "Animation Suite"</li>
                            <li>URL: file:///path/to/control_panel.html</li>
                        </ol>
                    </div>
                </div>
            </div>
            
            <!-- Installer Wizard -->
            <div id="page-install" class="page">
                <div class="card">
                    <h3>üì• Installation Wizard</h3>
                    <p class="hint">Automatically install Lua scripts to your OBS scripts folder.</p>
                    
                    <!-- Step 1: Detect/Select Paths -->
                    <div id="installStep1" class="install-step active">
                        <h4>Step 1: Configure Paths</h4>
                        
                        <label>Source Files Location</label>
                        <div class="url-box">
                            <input type="text" id="installSourcePath" readonly>
                            <button onclick="detectSourcePath()">üîç Detect</button>
                        </div>
                        <p class="hint">Where the script files are located (this folder)</p>
                        
                        <label>OBS Scripts Folder</label>
                        <div class="url-box">
                            <input type="text" id="installTargetPath" placeholder="C:\Users\YourName\AppData\Roaming\obs-studio\scripts">
                            <button onclick="browseTargetPath()">üìÅ Browse</button>
                            <button onclick="detectOBSPath()">üîç Auto-Detect</button>
                        </div>
                        <p class="hint">Where scripts will be installed. Common locations:</p>
                        <div class="path-suggestions" id="pathSuggestions"></div>
                        
                        <div class="row" style="margin-top:12px">
                            <button onclick="goToInstallStep(2)" class="btn-primary">Next: Select Scripts ‚Üí</button>
                        </div>
                    </div>
                    
                    <!-- Step 2: Select Scripts -->
                    <div id="installStep2" class="install-step">
                        <h4>Step 2: Select Scripts to Install</h4>
                        
                        <div id="installScriptsList" class="install-scripts-list"></div>
                        
                        <div class="row" style="margin-top:12px">
                            <button onclick="goToInstallStep(1)">‚Üê Back</button>
                            <button onclick="goToInstallStep(3)" class="btn-primary">Next: Review ‚Üí</button>
                        </div>
                    </div>
                    
                    <!-- Step 3: Review & Install -->
                    <div id="installStep3" class="install-step">
                        <h4>Step 3: Review & Install</h4>
                        
                        <div id="installReview" class="install-review"></div>
                        
                        <div class="install-method-select" style="margin-top:12px">
                            <label>Installation Method</label>
                            <select id="installMethod">
                                <option value="powershell">PowerShell Script (Windows)</option>
                                <option value="batch">Batch File (Windows)</option>
                                <option value="bash">Bash Script (Linux/Mac)</option>
                                <option value="manual">Manual Instructions</option>
                            </select>
                        </div>
                        
                        <div class="row" style="margin-top:12px">
                            <button onclick="goToInstallStep(2)">‚Üê Back</button>
                            <button onclick="generateInstallScript()" class="btn-primary">Generate Install Script</button>
                        </div>
                    </div>
                    
                    <!-- Step 4: Execute/Copy Script -->
                    <div id="installStep4" class="install-step">
                        <h4>Step 4: Run Installation</h4>
                        
                        <div id="installOutput" class="install-output"></div>
                        
                        <!-- Dock Warning -->
                        <div id="dockDownloadWarning" class="feature-notice" style="display:none;margin-bottom:12px">
                            <div class="feature-notice__title">‚ö†Ô∏è OBS Dock Detected</div>
                            <div class="feature-notice__text">
                                File downloads don't work in OBS docks. Use <strong>Copy Script</strong> instead, 
                                then paste into a text editor and save manually.
                            </div>
                        </div>
                        
                        <div class="row" style="margin-top:12px">
                            <button onclick="goToInstallStep(3)">‚Üê Back</button>
                            <button onclick="copyInstallScript()" class="btn-success">üìã Copy Script</button>
                            <button onclick="downloadInstallScript()" id="downloadScriptBtn" class="btn-primary" title="Download install script">üíæ Download</button>
                        </div>
                        
                        <!-- Browser Instructions (shown when NOT in dock) -->
                        <div id="browserInstructions" class="info-box" style="margin-top:12px">
                            <strong>After downloading:</strong>
                            <ol style="margin:4px 0 0 16px;font-size:0.85em">
                                <li>Right-click the downloaded script</li>
                                <li>Run as Administrator (Windows) or chmod +x && run (Linux/Mac)</li>
                                <li>Restart OBS Studio</li>
                                <li>Go to Tools ‚Üí Scripts to configure</li>
                            </ol>
                        </div>
                        
                        <!-- Dock Instructions (shown when IN dock) -->
                        <div id="dockInstructions" class="info-box" style="display:none;margin-top:12px">
                            <strong>üìã After copying the script:</strong>
                            <ol style="margin:4px 0 0 16px;font-size:0.85em">
                                <li>Open Notepad, VS Code, or any text editor</li>
                                <li>Paste the script (Ctrl+V)</li>
                                <li>Save as <code>.ps1</code> (PowerShell), <code>.bat</code> (Batch), or <code>.sh</code> (Bash)</li>
                                <li>Run the saved file as Administrator</li>
                                <li>Restart OBS Studio</li>
                            </ol>
                            <p style="margin-top:8px;font-size:0.85em;color:var(--muted)">
                                üí° <strong>Tip:</strong> Open this control panel in your regular browser for easier downloading!
                            </p>
                        </div>
                    </div>
                </div>
                
                <!-- Existing Installation Detection -->
                <div class="card" id="existingInstallCard" style="display:none">
                    <h3>‚ö†Ô∏è Existing Installation Detected</h3>
                    <div id="existingInstallInfo"></div>
                    <div class="row" style="margin-top:12px">
                        <button onclick="handleExistingInstall('skip')">Skip Existing</button>
                        <button onclick="handleExistingInstall('backup')" class="btn-warning">Backup & Replace</button>
                        <button onclick="handleExistingInstall('replace')" class="btn-danger">Replace All</button>
                    </div>
                </div>
                
            </div>
            
            <!-- Setup -->
            <div id="page-setup" class="page">
                <div class="card">
                    <h3>Connection</h3>
                    <div class="row">
                        <div>
                            <label>Host</label>
                            <input type="text" id="host" value="localhost">
                        </div>
                        <div>
                            <label>Port</label>
                            <input type="text" id="port" value="4455">
                        </div>
                    </div>
                    <label>Password</label>
                    <input type="password" id="password" placeholder="Leave empty if not set">
                    <div style="margin:8px 0">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                            <input type="checkbox" id="rememberCreds" style="width:auto;margin:0">
                            <span>Remember credentials</span>
                        </label>
                        <p style="font-size:0.75em;color:var(--warning);margin-top:4px" id="securityWarning"></p>
                        <button type="button" onclick="clearSavedCredentials()" style="font-size:0.75em;padding:4px 8px;margin-top:4px;background:var(--danger);border:none;color:#fff;border-radius:4px;cursor:pointer">Clear Saved Credentials</button>
                    </div>
                    <button class="btn-primary btn-block" id="connectBtn" onclick="toggleConnection()">Connect</button>
                </div>
                
                <div class="card">
                    <h3>Add as OBS Dock</h3>
                    <p style="color:var(--muted);margin-bottom:12px;font-size:0.9em">
                        In OBS: <strong>View ‚Üí Docks ‚Üí Custom Browser Docks</strong><br>
                        Click + and paste this URL:
                    </p>
                    <div class="url-box">
                        <input type="text" id="dockUrl" readonly>
                        <button onclick="copyUrl()">üìã Copy</button>
                    </div>
                    <p style="color:var(--muted);margin-top:8px;font-size:0.85em" id="copyStatus"></p>
                </div>
                
                <div class="card">
                    <h3>OBS WebSocket Setup</h3>
                    <ol style="color:var(--muted);padding-left:20px;font-size:0.9em;line-height:2">
                        <li>In OBS: <strong>Tools ‚Üí WebSocket Server Settings</strong></li>
                        <li>Check "Enable WebSocket server"</li>
                        <li>Note the port (default: 4455)</li>
                        <li>Set password if desired</li>
                        <li>Click Apply, then connect here</li>
                    </ol>
                </div>
                
                <div class="card">
                    <h3>Keyboard Shortcuts</h3>
                    <p style="color:var(--muted);font-size:0.9em">When this panel is focused:</p>
                    <ul style="color:var(--muted);padding-left:20px;font-size:0.9em;line-height:2">
                        <li><strong>1-9</strong> - Trigger saved swap configs</li>
                        <li><strong>Space</strong> - Start/stop text cycler</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h3>üíæ Data & Backup</h3>
                    
                    <!-- Storage Engine Status -->
                    <div id="storageEngineStatus" style="display:flex;gap:12px;margin-bottom:12px;padding:8px;background:rgba(0,0,0,0.2);border-radius:6px;font-size:0.85em">
                        <span id="idbStatus">‚è≥ IndexedDB</span>
                        <span id="lsStatus">‚è≥ localStorage</span>
                    </div>
                    
                    <!-- Data Categories -->
                    <div style="margin-bottom:12px">
                        <div style="font-size:0.8em;color:var(--muted);margin-bottom:6px;font-weight:600">SELECT DATA TO EXPORT:</div>
                        <div style="display:grid;gap:6px">
                            <label style="display:flex;align-items:center;gap:8px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:4px;cursor:pointer;font-size:0.85em">
                                <input type="checkbox" id="exportSwaps" checked style="width:auto;margin:0">
                                <span>üîÑ Swap Configs</span>
                                <span id="swapCount" style="margin-left:auto;color:var(--muted);font-size:0.9em">(0)</span>
                            </label>
                            <label style="display:flex;align-items:center;gap:8px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:4px;cursor:pointer;font-size:0.85em">
                                <input type="checkbox" id="exportTextCyclers" checked style="width:auto;margin:0">
                                <span>üìù Text Cycler Configs</span>
                                <span id="textCyclerCount" style="margin-left:auto;color:var(--muted);font-size:0.9em">(0)</span>
                            </label>
                            <label style="display:flex;align-items:center;gap:8px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:4px;cursor:pointer;font-size:0.85em">
                                <input type="checkbox" id="exportClips" checked style="width:auto;margin:0">
                                <span>üé¨ Clips Player Configs</span>
                                <span id="clipsCount" style="margin-left:auto;color:var(--muted);font-size:0.9em">(0)</span>
                            </label>
                            <label style="display:flex;align-items:center;gap:8px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:4px;cursor:pointer;font-size:0.85em">
                                <input type="checkbox" id="exportUIState" checked style="width:auto;margin:0">
                                <span>‚öôÔ∏è UI Preferences</span>
                                <span style="margin-left:auto;color:var(--muted);font-size:0.9em">(dropdowns, settings)</span>
                            </label>
                            <label style="display:flex;align-items:center;gap:8px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:4px;cursor:pointer;font-size:0.85em">
                                <input type="checkbox" id="exportCredentials" style="width:auto;margin:0">
                                <span>üîê Connection Settings</span>
                                <span style="margin-left:auto;color:var(--warning);font-size:0.8em">(host/port only)</span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px">
                        <button onclick="exportSelectedData()" style="padding:10px;background:var(--primary);border:none;color:#fff;border-radius:6px;cursor:pointer;font-weight:500">üì§ Export Selected</button>
                        <button onclick="importDataWithOptions()" style="padding:10px;background:var(--accent);border:none;color:#000;border-radius:6px;cursor:pointer;font-weight:500">üì• Import Backup</button>
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                        <button onclick="forceStorageSync()" style="padding:8px;background:rgba(255,255,255,0.1);border:none;color:#fff;border-radius:6px;cursor:pointer;font-size:0.85em">üîÑ Force Sync</button>
                        <button onclick="copyBackupToClipboard()" style="padding:8px;background:rgba(255,255,255,0.1);border:none;color:#fff;border-radius:6px;cursor:pointer;font-size:0.85em">üìã Copy as JSON</button>
                    </div>
                    
                    <!-- Info -->
                    <div style="margin-top:10px;padding:8px;background:rgba(255,200,0,0.1);border-radius:6px;border-left:3px solid var(--warning)">
                        <p style="font-size:0.75em;color:var(--warning);margin:0">‚ö†Ô∏è <strong>OBS browser docks can lose data</strong> when cache is cleared. Export backups regularly!</p>
                    </div>
                    
                    <!-- Last backup info -->
                    <div id="lastBackupInfo" style="margin-top:8px;font-size:0.75em;color:var(--muted);text-align:center"></div>
                </div>
            </div>
            </main>
            
            <!-- Draggable Divider -->
            <div class="split-divider" id="splitDivider" title="Drag to resize"></div>
            
            <!-- Persistent Activity Log Panel -->
            <div class="split-log" id="splitLog">
                <div class="split-log__header">
                    <button class="split-log__toggle" id="logToggle" title="Toggle Log">‚ñº</button>
                    <span class="split-log__title">Activity Log</span>
                    <div class="search-box split-log__search">
                        <input type="text" class="search-box__input" id="logSearchInput" placeholder="Search log...">
                        <span class="search-box__icon">üîç</span>
                        <button class="search-box__clear" id="logSearchClear" title="Clear search">‚úï</button>
                    </div>
                    <button class="split-log__clear btn-link" onclick="clearLog()">Clear</button>
                </div>
                <div class="split-log__content" id="log"></div>
            </div>
        </div>
    </div>

<script>
// ============ Storage System (OBS Dock Compatible) ============
// Uses IndexedDB as PRIMARY storage (survives OBS cache clears better)
// Falls back to localStorage, syncs both for redundancy
const STORAGE_PREFIX = 'sss_'; // Strixun Stream Suite prefix
const IDB_NAME = 'StrixunStreamSuite';
const IDB_STORE = 'settings';
const IDB_VERSION = 1;

// In-memory cache for synchronous access after init
let storageCache = {};
let idbReady = false;
let idbInstance = null;

// Initialize IndexedDB
function initIndexedDB() {
    return new Promise((resolve, reject) => {
        if (!window.indexedDB) {
            console.warn('[Storage] IndexedDB not available, using localStorage only');
            resolve(null);
            return;
        }
        
        const request = indexedDB.open(IDB_NAME, IDB_VERSION);
        
        request.onerror = (e) => {
            console.error('[Storage] IndexedDB open error:', e.target.error);
            resolve(null); // Fall back to localStorage
        };
        
        request.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains(IDB_STORE)) {
                db.createObjectStore(IDB_STORE, { keyPath: 'key' });
            }
        };
        
        request.onsuccess = (e) => {
            idbInstance = e.target.result;
            idbReady = true;
            console.log('[Storage] IndexedDB ready');
            resolve(idbInstance);
        };
    });
}

// Load all data from IndexedDB into memory cache
async function loadStorageCache() {
    // First, try to load from IndexedDB (primary)
    if (idbInstance) {
        try {
            const tx = idbInstance.transaction(IDB_STORE, 'readonly');
            const store = tx.objectStore(IDB_STORE);
            const request = store.getAll();
            
            await new Promise((resolve, reject) => {
                request.onsuccess = () => {
                    const items = request.result || [];
                    items.forEach(item => {
                        storageCache[item.key] = item.value;
                    });
                    console.log('[Storage] Loaded', items.length, 'items from IndexedDB');
                    resolve();
                };
                request.onerror = () => {
                    console.error('[Storage] Failed to load from IndexedDB');
                    reject(request.error);
                };
            });
        } catch (e) {
            console.error('[Storage] IndexedDB load error:', e);
        }
    }
    
    // Then merge with localStorage (fallback/sync)
    // localStorage values fill in any gaps from IndexedDB
    try {
        for (let i = 0; i < localStorage.length; i++) {
            const fullKey = localStorage.key(i);
            if (fullKey && fullKey.startsWith(STORAGE_PREFIX)) {
                const key = fullKey.substring(STORAGE_PREFIX.length);
                // Only use localStorage value if not already in cache from IDB
                if (storageCache[key] === undefined) {
                    try {
                        const raw = localStorage.getItem(fullKey);
                        if (raw) {
                            storageCache[key] = JSON.parse(raw);
                            console.log('[Storage] Recovered from localStorage:', key);
                            // Sync back to IndexedDB
                            if (idbInstance) {
                                saveToIDB(key, storageCache[key]);
                            }
                        }
                    } catch (e) {
                        // Raw string value (credentials etc)
                        storageCache[key] = localStorage.getItem(fullKey);
                    }
                }
            }
        }
    } catch (e) {
        console.error('[Storage] localStorage scan error:', e);
    }
    
    console.log('[Storage] Cache ready with keys:', Object.keys(storageCache));
}

// Save to IndexedDB (async, fire-and-forget)
function saveToIDB(key, value) {
    if (!idbInstance) return;
    try {
        const tx = idbInstance.transaction(IDB_STORE, 'readwrite');
        const store = tx.objectStore(IDB_STORE);
        store.put({ key, value });
    } catch (e) {
        console.error('[Storage] IDB write error:', key, e);
    }
}

// Delete from IndexedDB
function deleteFromIDB(key) {
    if (!idbInstance) return;
    try {
        const tx = idbInstance.transaction(IDB_STORE, 'readwrite');
        const store = tx.objectStore(IDB_STORE);
        store.delete(key);
    } catch (e) {
        console.error('[Storage] IDB delete error:', key, e);
    }
}

// Storage wrapper - uses memory cache for reads, writes to both IDB and localStorage
const storage = {
    get(key) {
        // Read from memory cache (populated on init from IDB + localStorage)
        const value = storageCache[key];
        return value !== undefined ? value : null;
    },
    
    set(key, value) {
        try {
            // Update memory cache
            storageCache[key] = value;
            
            // Write to IndexedDB (primary, async)
            saveToIDB(key, value);
            
            // Write to localStorage (backup, sync)
            try {
                localStorage.setItem(STORAGE_PREFIX + key, JSON.stringify(value));
            } catch (e) {
                console.warn('[Storage] localStorage write failed:', key, e);
            }
            
            // Trigger auto-backup snapshot for config keys (debounced)
            if (['swapConfigs', 'textCyclerConfigs', 'clipsConfigs'].includes(key)) {
                if (typeof createRecoverySnapshot === 'function') {
                    // Debounce: wait 2 seconds after last change before snapshotting
                    clearTimeout(this._snapshotDebounce);
                    this._snapshotDebounce = setTimeout(createRecoverySnapshot, 2000);
                }
            }
            
            return true;
        } catch (e) {
            console.error('[Storage] Write error:', key, e);
            return false;
        }
    },
    
    remove(key) {
        try {
            delete storageCache[key];
            deleteFromIDB(key);
            localStorage.removeItem(STORAGE_PREFIX + key);
        } catch (e) {
            console.error('[Storage] Remove error:', key, e);
        }
    },
    
    // Raw string get/set for credentials (stored as-is, not JSON)
    getRaw(key) {
        const value = storageCache[key];
        // If it was stored raw, it's already a string in cache
        return value !== undefined ? value : null;
    },
    
    setRaw(key, value) {
        try {
            storageCache[key] = value;
            saveToIDB(key, value);
            try {
                localStorage.setItem(STORAGE_PREFIX + key, value);
            } catch (e) {}
        } catch (e) {}
    },
    
    // Force sync all cache to both storages (call after bulk operations)
    async flush() {
        for (const [key, value] of Object.entries(storageCache)) {
            saveToIDB(key, value);
            try {
                const jsonValue = typeof value === 'string' ? value : JSON.stringify(value);
                localStorage.setItem(STORAGE_PREFIX + key, jsonValue);
            } catch (e) {}
        }
    },
    
    // Check if storage system is ready
    isReady() {
        return true; // Always ready after init, just may be using fallback
    }
};

// ============ Storage Backup & Status Functions ============
function updateStorageStatus() {
    // Update engine status indicators
    const idbEl = document.getElementById('idbStatus');
    const lsEl = document.getElementById('lsStatus');
    
    if (idbEl) {
        idbEl.textContent = idbReady ? '‚úÖ IndexedDB' : '‚ùå IndexedDB';
        idbEl.style.color = idbReady ? 'var(--success)' : 'var(--danger)';
    }
    
    if (lsEl) {
        const lsWorks = (() => {
            try {
                localStorage.setItem('_test', '1');
                localStorage.removeItem('_test');
                return true;
            } catch (e) { return false; }
        })();
        lsEl.textContent = lsWorks ? '‚úÖ localStorage' : '‚ùå localStorage';
        lsEl.style.color = lsWorks ? 'var(--success)' : 'var(--danger)';
    }
    
    // Update config counts
    const swapCountEl = document.getElementById('swapCount');
    const textCyclerCountEl = document.getElementById('textCyclerCount');
    const clipsCountEl = document.getElementById('clipsCount');
    
    if (swapCountEl) swapCountEl.textContent = `(${swapConfigs?.length || 0})`;
    if (textCyclerCountEl) textCyclerCountEl.textContent = `(${textCyclerConfigs?.length || 0})`;
    if (clipsCountEl) clipsCountEl.textContent = `(${clipsConfigs?.length || 0})`;
    
    // Update last backup info
    const lastBackupEl = document.getElementById('lastBackupInfo');
    if (lastBackupEl) {
        const lastBackup = storage.get('lastBackupTimestamp');
        if (lastBackup) {
            const date = new Date(lastBackup);
            lastBackupEl.textContent = `Last backup: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
        } else {
            lastBackupEl.textContent = 'No backup yet - consider exporting!';
        }
    }
}

function getSelectedExportData() {
    const backup = {
        version: 2,
        timestamp: new Date().toISOString(),
        exportedCategories: []
    };
    
    if (document.getElementById('exportSwaps')?.checked && swapConfigs?.length) {
        backup.swapConfigs = swapConfigs;
        backup.exportedCategories.push('swaps');
    }
    
    if (document.getElementById('exportTextCyclers')?.checked && textCyclerConfigs?.length) {
        backup.textCyclerConfigs = textCyclerConfigs;
        backup.exportedCategories.push('textCyclers');
    }
    
    if (document.getElementById('exportClips')?.checked && clipsConfigs?.length) {
        backup.clipsConfigs = clipsConfigs;
        backup.exportedCategories.push('clips');
    }
    
    if (document.getElementById('exportUIState')?.checked) {
        backup.ui_state = storage.get('ui_state') || {};
        backup.exportedCategories.push('uiState');
    }
    
    if (document.getElementById('exportCredentials')?.checked) {
        // Only export non-sensitive connection info
        backup.connectionSettings = {
            host: storage.getRaw('obs_host'),
            port: storage.getRaw('obs_port')
            // Note: password is NOT exported for security
        };
        backup.exportedCategories.push('connection');
    }
    
    return backup;
}

function exportSelectedData() {
    const backup = getSelectedExportData();
    
    if (backup.exportedCategories.length === 0) {
        log('Nothing to export! Select at least one category or add some configs.', 'error');
        return;
    }
    
    const json = JSON.stringify(backup, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `strixun-backup-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Record backup timestamp
    storage.set('lastBackupTimestamp', new Date().toISOString());
    updateStorageStatus();
    
    log(`Exported: ${backup.exportedCategories.join(', ')}`, 'success');
}

function copyBackupToClipboard() {
    const backup = getSelectedExportData();
    
    if (backup.exportedCategories.length === 0) {
        log('Nothing to copy! Select at least one category.', 'error');
        return;
    }
    
    const json = JSON.stringify(backup, null, 2);
    navigator.clipboard.writeText(json).then(() => {
        log('Backup JSON copied to clipboard!', 'success');
    }).catch(() => {
        // Fallback
        prompt('Copy this JSON:', json);
    });
}

function importDataWithOptions() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
            const text = await file.text();
            const backup = JSON.parse(text);
            
            if (!backup.version) {
                log('Invalid backup file format', 'error');
                return;
            }
            
            // Build import summary
            const categories = [];
            if (backup.swapConfigs?.length) categories.push(`${backup.swapConfigs.length} swap configs`);
            if (backup.textCyclerConfigs?.length) categories.push(`${backup.textCyclerConfigs.length} text cycler configs`);
            if (backup.clipsConfigs?.length) categories.push(`${backup.clipsConfigs.length} clips configs`);
            if (backup.ui_state) categories.push('UI preferences');
            if (backup.connectionSettings) categories.push('connection settings');
            
            if (categories.length === 0) {
                log('Backup file is empty!', 'error');
                return;
            }
            
            // Build import options dialog
            const importChoices = await showImportDialog(backup, categories);
            if (!importChoices) return; // Cancelled
            
            let imported = [];
            
            // Restore selected configs
            if (importChoices.swaps && backup.swapConfigs) {
                if (importChoices.merge) {
                    // Merge: add new, skip duplicates
                    const existingNames = new Set(swapConfigs.map(c => c.name));
                    const newConfigs = backup.swapConfigs.filter(c => !existingNames.has(c.name));
                    swapConfigs = [...swapConfigs, ...newConfigs];
                    imported.push(`${newConfigs.length} new swaps (merged)`);
                } else {
                    swapConfigs = backup.swapConfigs;
                    imported.push(`${backup.swapConfigs.length} swaps (replaced)`);
                }
                storage.set('swapConfigs', swapConfigs);
            }
            
            if (importChoices.textCyclers && backup.textCyclerConfigs) {
                if (importChoices.merge) {
                    const existingIds = new Set(textCyclerConfigs.map(c => c.id));
                    const newConfigs = backup.textCyclerConfigs.filter(c => !existingIds.has(c.id));
                    textCyclerConfigs = [...textCyclerConfigs, ...newConfigs];
                    imported.push(`${newConfigs.length} new text cyclers (merged)`);
                } else {
                    textCyclerConfigs = backup.textCyclerConfigs;
                    imported.push(`${backup.textCyclerConfigs.length} text cyclers (replaced)`);
                }
                storage.set('textCyclerConfigs', textCyclerConfigs);
            }
            
            if (importChoices.clips && backup.clipsConfigs) {
                if (importChoices.merge) {
                    const existingIds = new Set(clipsConfigs.map(c => c.id));
                    const newConfigs = backup.clipsConfigs.filter(c => !existingIds.has(c.id));
                    clipsConfigs = [...clipsConfigs, ...newConfigs];
                    imported.push(`${newConfigs.length} new clips configs (merged)`);
                } else {
                    clipsConfigs = backup.clipsConfigs;
                    imported.push(`${backup.clipsConfigs.length} clips configs (replaced)`);
                }
                storage.set('clipsConfigs', clipsConfigs);
            }
            
            if (importChoices.uiState && backup.ui_state) {
                storage.set('ui_state', backup.ui_state);
                imported.push('UI preferences');
            }
            
            if (importChoices.connection && backup.connectionSettings) {
                if (backup.connectionSettings.host) storage.setRaw('obs_host', backup.connectionSettings.host);
                if (backup.connectionSettings.port) storage.setRaw('obs_port', backup.connectionSettings.port);
                imported.push('connection settings');
            }
            
            // Re-render everything
            renderSavedSwaps();
            renderTextCyclerConfigs();
            renderClipsConfigs();
            loadUIState();
            updateStorageStatus();
            
            log(`Imported: ${imported.join(', ')}`, 'success');
        } catch (err) {
            log('Import failed: ' + err.message, 'error');
        }
    };
    
    input.click();
}

async function showImportDialog(backup, categories) {
    return new Promise((resolve) => {
        // Simple confirm-based dialog (could be replaced with modal later)
        const hasSwaps = backup.swapConfigs?.length > 0;
        const hasTextCyclers = backup.textCyclerConfigs?.length > 0;
        const hasClips = backup.clipsConfigs?.length > 0;
        const hasUI = !!backup.ui_state;
        const hasConnection = !!backup.connectionSettings;
        
        const msg = `Import backup from ${backup.timestamp ? new Date(backup.timestamp).toLocaleString() : 'unknown date'}?

Found:
${categories.map(c => '‚Ä¢ ' + c).join('\n')}

Import mode:
‚Ä¢ OK = REPLACE existing (overwrite)
‚Ä¢ Cancel = abort

(Hold Shift + OK to MERGE instead of replace)`;
        
        const result = confirm(msg);
        if (!result) {
            resolve(null);
            return;
        }
        
        // Check if shift was held (merge mode) - using a simple approach
        const mergeMode = false; // For now, always replace. Could enhance with modal later.
        
        resolve({
            swaps: hasSwaps,
            textCyclers: hasTextCyclers,
            clips: hasClips,
            uiState: hasUI,
            connection: hasConnection,
            merge: mergeMode
        });
    });
}

async function forceStorageSync() {
    log('Forcing storage sync...', 'info');
    
    // Re-save all configs to both storages
    storage.set('swapConfigs', swapConfigs);
    storage.set('textCyclerConfigs', textCyclerConfigs);
    storage.set('clipsConfigs', clipsConfigs);
    
    // Flush to ensure everything is written
    await storage.flush();
    
    updateStorageStatus();
    log('Storage synced to IndexedDB + localStorage', 'success');
}

// Legacy export function (for backwards compatibility)
function exportAllData() {
    // Check all boxes and export
    ['exportSwaps', 'exportTextCyclers', 'exportClips', 'exportUIState'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.checked = true;
    });
    exportSelectedData();
}

// Legacy import function (for backwards compatibility)
function importAllData() {
    importDataWithOptions();
}

// ============ Auto-Backup System ============
// Creates periodic recovery snapshots that survive even if main storage fails
const AUTO_BACKUP_KEY = 'sss_recovery_snapshot';
const AUTO_BACKUP_INTERVAL = 60000; // Every minute when changes detected
let autoBackupTimer = null;
let lastDataHash = '';

function getDataHash() {
    // Simple hash to detect changes
    const data = JSON.stringify({
        s: swapConfigs?.length || 0,
        t: textCyclerConfigs?.length || 0,
        c: clipsConfigs?.length || 0
    });
    return data;
}

function createRecoverySnapshot() {
    const currentHash = getDataHash();
    if (currentHash === lastDataHash) return; // No changes
    
    const snapshot = {
        version: 2,
        timestamp: new Date().toISOString(),
        type: 'auto-recovery',
        swapConfigs: swapConfigs || [],
        textCyclerConfigs: textCyclerConfigs || [],
        clipsConfigs: clipsConfigs || []
    };
    
    try {
        // Save directly to localStorage (bypasses our wrapper for redundancy)
        localStorage.setItem(AUTO_BACKUP_KEY, JSON.stringify(snapshot));
        lastDataHash = currentHash;
        console.log('[AutoBackup] Recovery snapshot saved');
    } catch (e) {
        console.warn('[AutoBackup] Failed to save recovery snapshot:', e);
    }
}

function checkForRecoverySnapshot() {
    try {
        const snapshot = localStorage.getItem(AUTO_BACKUP_KEY);
        if (!snapshot) return null;
        
        const data = JSON.parse(snapshot);
        if (!data.version || !data.timestamp) return null;
        
        // Check if we have empty configs but recovery has data
        const currentTotal = (swapConfigs?.length || 0) + (textCyclerConfigs?.length || 0) + (clipsConfigs?.length || 0);
        const recoveryTotal = (data.swapConfigs?.length || 0) + (data.textCyclerConfigs?.length || 0) + (data.clipsConfigs?.length || 0);
        
        if (currentTotal === 0 && recoveryTotal > 0) {
            return data; // Recovery available!
        }
        
        return null;
    } catch (e) {
        return null;
    }
}

async function offerRecovery() {
    const recovery = checkForRecoverySnapshot();
    if (!recovery) return false;
    
    const age = new Date() - new Date(recovery.timestamp);
    const ageStr = age < 3600000 ? `${Math.round(age/60000)} minutes` : `${Math.round(age/3600000)} hours`;
    
    const msg = `üîÑ Recovery Data Found!

Your configs appear empty, but we found a backup from ${ageStr} ago:
‚Ä¢ ${recovery.swapConfigs?.length || 0} swap configs
‚Ä¢ ${recovery.textCyclerConfigs?.length || 0} text cycler configs  
‚Ä¢ ${recovery.clipsConfigs?.length || 0} clips configs

Restore this backup?`;
    
    if (confirm(msg)) {
        if (recovery.swapConfigs) {
            swapConfigs = recovery.swapConfigs;
            storage.set('swapConfigs', swapConfigs);
        }
        if (recovery.textCyclerConfigs) {
            textCyclerConfigs = recovery.textCyclerConfigs;
            storage.set('textCyclerConfigs', textCyclerConfigs);
        }
        if (recovery.clipsConfigs) {
            clipsConfigs = recovery.clipsConfigs;
            storage.set('clipsConfigs', clipsConfigs);
        }
        
        renderSavedSwaps();
        renderTextCyclerConfigs();
        renderClipsConfigs();
        updateStorageStatus();
        
        log('Configs restored from recovery backup!', 'success');
        return true;
    }
    return false;
}

function startAutoBackup() {
    if (autoBackupTimer) clearInterval(autoBackupTimer);
    
    // Initial snapshot
    createRecoverySnapshot();
    
    // Periodic snapshots
    autoBackupTimer = setInterval(createRecoverySnapshot, AUTO_BACKUP_INTERVAL);
    console.log('[AutoBackup] Auto-backup system started');
}

// ============ Smart Search Module ============
const SmartSearch = {
    instances: new Map(),
    
    /**
     * Create a search instance for a container
     * @param {string} id - Unique identifier for this search
     * @param {HTMLElement} inputEl - The search input element
     * @param {HTMLElement} containerEl - The container with searchable items
     * @param {Object} options - Configuration options
     */
    create(id, inputEl, containerEl, options = {}) {
        const config = {
            itemSelector: options.itemSelector || '.source-item, .config-item, .script-card',
            textSelector: options.textSelector || '.name, .script-name, h3, h4',
            minChars: options.minChars || 1,
            debounceMs: options.debounceMs || 150,
            onFilter: options.onFilter || null,
            showCount: options.showCount !== false
        };
        
        let debounceTimer = null;
        
        const doSearch = () => {
            const query = inputEl.value.toLowerCase().trim();
            const items = containerEl.querySelectorAll(config.itemSelector);
            let visibleCount = 0;
            let totalCount = items.length;
            
            items.forEach(item => {
                // Get text content from multiple possible selectors
                let text = '';
                if (config.textSelector) {
                    const textEls = item.querySelectorAll(config.textSelector);
                    textEls.forEach(el => text += ' ' + el.textContent);
                }
                text = text || item.textContent;
                text = text.toLowerCase();
                
                // Remove old highlights
                item.querySelectorAll('.search-highlight').forEach(h => {
                    h.replaceWith(h.textContent);
                });
                
                if (!query || query.length < config.minChars) {
                    item.classList.remove('search-hidden');
                    visibleCount++;
                    return;
                }
                
                if (text.includes(query)) {
                    item.classList.remove('search-hidden');
                    visibleCount++;
                    // Add highlights
                    SmartSearch.highlightText(item, query, config.textSelector);
                } else {
                    item.classList.add('search-hidden');
                }
            });
            
            // Update count badge if enabled
            if (config.showCount && query.length >= config.minChars) {
                SmartSearch.updateCountBadge(inputEl, visibleCount, totalCount);
            } else {
                SmartSearch.removeCountBadge(inputEl);
            }
            
            // Show/hide no results message
            SmartSearch.updateNoResults(containerEl, visibleCount, query.length >= config.minChars);
            
            if (config.onFilter) config.onFilter(query, visibleCount, totalCount);
        };
        
        // Debounced search
        const onInput = () => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(doSearch, config.debounceMs);
        };
        
        inputEl.addEventListener('input', onInput);
        
        // Clear button support
        const clearBtn = inputEl.parentElement?.querySelector('.search-box__clear');
        if (clearBtn) {
            clearBtn.addEventListener('click', () => {
                inputEl.value = '';
                doSearch();
                inputEl.focus();
            });
        }
        
        this.instances.set(id, { inputEl, containerEl, config, doSearch });
        return { doSearch, clear: () => { inputEl.value = ''; doSearch(); } };
    },
    
    highlightText(element, query, textSelector) {
        const textEls = textSelector ? element.querySelectorAll(textSelector) : [element];
        textEls.forEach(el => {
            if (el.children.length > 0) return; // Skip elements with children
            const text = el.textContent;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            if (regex.test(text)) {
                el.innerHTML = text.replace(regex, '<span class="search-highlight">$1</span>');
            }
        });
    },
    
    updateCountBadge(inputEl, visible, total) {
        let badge = inputEl.parentElement?.querySelector('.search-box__count');
        if (!badge) {
            badge = document.createElement('span');
            badge.className = 'search-box__count';
            inputEl.parentElement?.insertBefore(badge, inputEl.nextSibling?.nextSibling);
        }
        badge.textContent = `${visible}/${total}`;
    },
    
    removeCountBadge(inputEl) {
        inputEl.parentElement?.querySelector('.search-box__count')?.remove();
    },
    
    updateNoResults(container, count, isSearching) {
        let msg = container.querySelector('.search-no-results');
        if (isSearching && count === 0) {
            if (!msg) {
                msg = document.createElement('div');
                msg.className = 'search-no-results';
                msg.textContent = 'No results found';
                container.appendChild(msg);
            }
        } else if (msg) {
            msg.remove();
        }
    },
    
    refresh(id) {
        const instance = this.instances.get(id);
        if (instance) instance.doSearch();
    }
};

/**
 * Helper to initialize search for a list container
 * Always initializes, but hides search box when < 3 items
 */
function initSearchForList(id, inputId, containerEl, itemCount) {
    const searchInput = document.getElementById(inputId);
    if (!searchInput) return;
    
    const searchBox = searchInput.closest('.search-box');
    
    // Show/hide search box based on item count
    if (searchBox) {
        searchBox.style.display = itemCount >= 3 ? '' : 'none';
    }
    
    // Always initialize if not already done
    if (!SmartSearch.instances.has(id)) {
        SmartSearch.create(id, searchInput, containerEl, { 
            itemSelector: '.source-item, .config-item, .script-card' 
        });
        console.log(`[Search] Initialized search for: ${id}`);
    } else {
        // Refresh to re-scan items
        SmartSearch.refresh(id);
    }
}

// ============ Collapsible Cards Module ============
const CollapsibleCards = {
    storageKey: 'ui_collapsed_cards',
    
    init() {
        // Get saved state
        const savedState = storage.get(this.storageKey) || {};
        
        // Find all cards with h3 and make them collapsible
        document.querySelectorAll('.card > h3').forEach((h3, index) => {
            const card = h3.parentElement;
            const cardId = card.id || `card-${index}`;
            card.dataset.cardId = cardId;
            
            // Wrap content after h3 in card-body div
            const cardBody = document.createElement('div');
            cardBody.className = 'card-body';
            while (h3.nextSibling) {
                cardBody.appendChild(h3.nextSibling);
            }
            card.appendChild(cardBody);
            
            // Add collapsible class
            card.classList.add('collapsible');
            
            // Restore saved state
            if (savedState[cardId]) {
                card.classList.add('collapsed');
            }
            
            // Add click handler
            h3.addEventListener('click', (e) => {
                // Don't toggle if clicking a button inside h3
                if (e.target.tagName === 'BUTTON') return;
                
                card.classList.toggle('collapsed');
                this.saveState();
            });
        });
    },
    
    saveState() {
        const state = {};
        document.querySelectorAll('.card.collapsible').forEach(card => {
            if (card.classList.contains('collapsed')) {
                state[card.dataset.cardId] = true;
            }
        });
        storage.set(this.storageKey, state);
    },
    
    expandAll() {
        document.querySelectorAll('.card.collapsible.collapsed').forEach(card => {
            card.classList.remove('collapsed');
        });
        this.saveState();
    },
    
    collapseAll() {
        document.querySelectorAll('.card.collapsible').forEach(card => {
            card.classList.add('collapsed');
        });
        this.saveState();
    }
};

// ============ Split Panel Module ============
const SplitPanel = {
    storageKey: 'ui_split_panel',
    minLogHeight: 40,
    maxLogHeight: 500,
    defaultLogHeight: 150,
    
    init() {
        const divider = document.getElementById('splitDivider');
        const logPanel = document.getElementById('splitLog');
        const logToggle = document.getElementById('logToggle');
        const logContent = document.getElementById('log');
        const mainContent = document.querySelector('.split-main');
        
        if (!divider || !logPanel) return;
        
        // Restore saved state
        const savedState = storage.get(this.storageKey) || {};
        let logHeight = savedState.height || this.defaultLogHeight;
        let isCollapsed = savedState.collapsed || false;
        
        // Apply initial state
        if (isCollapsed) {
            logPanel.classList.add('collapsed');
            logToggle.textContent = '‚ñ≤';
            logPanel.style.height = ''; // Let CSS handle collapsed height
        } else {
            logPanel.style.height = logHeight + 'px';
        }
        
        // Toggle collapse
        logToggle.addEventListener('click', () => {
            isCollapsed = !isCollapsed;
            logPanel.classList.toggle('collapsed', isCollapsed);
            logToggle.textContent = isCollapsed ? '‚ñ≤' : '‚ñº';
            if (isCollapsed) {
                // Clear inline height so CSS auto-height takes over
                logPanel.style.height = '';
            } else {
                logPanel.style.height = logHeight + 'px';
            }
            this.saveState(logHeight, isCollapsed);
        });
        
        // Draggable divider
        let isDragging = false;
        let startY = 0;
        let startHeight = 0;
        
        divider.addEventListener('mousedown', (e) => {
            if (isCollapsed) return;
            isDragging = true;
            startY = e.clientY;
            startHeight = logPanel.offsetHeight;
            divider.classList.add('dragging');
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const deltaY = startY - e.clientY;
            logHeight = Math.max(this.minLogHeight, Math.min(this.maxLogHeight, startHeight + deltaY));
            logPanel.style.height = logHeight + 'px';
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                divider.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                this.saveState(logHeight, isCollapsed);
            }
        });
        
        // Touch support for mobile
        divider.addEventListener('touchstart', (e) => {
            if (isCollapsed) return;
            isDragging = true;
            startY = e.touches[0].clientY;
            startHeight = logPanel.offsetHeight;
            divider.classList.add('dragging');
        }, { passive: true });
        
        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const deltaY = startY - e.touches[0].clientY;
            logHeight = Math.max(this.minLogHeight, Math.min(this.maxLogHeight, startHeight + deltaY));
            logPanel.style.height = logHeight + 'px';
        }, { passive: true });
        
        document.addEventListener('touchend', () => {
            if (isDragging) {
                isDragging = false;
                divider.classList.remove('dragging');
                this.saveState(logHeight, isCollapsed);
            }
        });
        
        // Initialize log search
        const logSearchInput = document.getElementById('logSearchInput');
        if (logSearchInput && logContent) {
            logSearchInput.addEventListener('input', () => {
                this.filterLog(logSearchInput.value);
            });
            document.getElementById('logSearchClear')?.addEventListener('click', () => {
                logSearchInput.value = '';
                this.filterLog('');
                logSearchInput.focus();
            });
        }
    },
    
    filterLog(query) {
        const logEl = document.getElementById('log');
        if (!logEl) return;
        
        const entries = logEl.querySelectorAll('.log-entry');
        const q = query.toLowerCase().trim();
        
        entries.forEach(entry => {
            // Remove old highlights
            entry.querySelectorAll('.search-highlight').forEach(h => {
                h.replaceWith(h.textContent);
            });
            
            if (!q) {
                entry.classList.remove('search-hidden');
                return;
            }
            
            const text = entry.textContent.toLowerCase();
            if (text.includes(q)) {
                entry.classList.remove('search-hidden');
                // Highlight matching text
                const textEl = entry.querySelector('.log-entry__text');
                if (textEl) {
                    const regex = new RegExp(`(${q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                    textEl.innerHTML = textEl.textContent.replace(regex, '<span class="search-highlight">$1</span>');
                }
            } else {
                entry.classList.add('search-hidden');
            }
        });
    },
    
    saveState(height, collapsed) {
        storage.set(this.storageKey, { height, collapsed });
    }
};

// ============ State ============
let ws = null;
let connected = false;
let msgId = 1;
let pendingRequests = {};
let currentScene = '';
let sources = [];
let textSources = [];
let aspectMode = 0;
let reconnectAttempts = 0;
const MAX_RECONNECT = 3;


// ============ Secure Credential Storage (AES-GCM) ============
let encryptionKey = null; // Derived from PIN, kept in memory only

async function deriveKey(pin, salt) {
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
        'raw', encoder.encode(pin), 'PBKDF2', false, ['deriveKey']
    );
    return crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt: salt, iterations: 100000, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
    );
}

async function encryptPassword(password, pin) {
    const encoder = new TextEncoder();
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await deriveKey(pin, salt);
    
    const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encoder.encode(password)
    );
    
    // Combine salt + iv + encrypted data and encode as base64
    const combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
    combined.set(salt, 0);
    combined.set(iv, salt.length);
    combined.set(new Uint8Array(encrypted), salt.length + iv.length);
    
    return btoa(String.fromCharCode(...combined));
}

async function decryptPassword(encryptedData, pin) {
    try {
        const combined = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
        const salt = combined.slice(0, 16);
        const iv = combined.slice(16, 28);
        const data = combined.slice(28);
        
        const key = await deriveKey(pin, salt);
        const decrypted = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv: iv },
            key,
            data
        );
        
        return new TextDecoder().decode(decrypted);
    } catch (e) {
        return null; // Wrong PIN or corrupted data
    }
}

async function saveCredentials() {
    const remember = document.getElementById('rememberCreds').checked;
    const host = document.getElementById('host').value;
    const port = document.getElementById('port').value;
    const password = document.getElementById('password').value;
    
    if (remember) {
        storage.setRaw('obs_host', host);
        storage.setRaw('obs_port', port);
        
        if (password) {
            // Check if crypto is available
            if (!crypto || !crypto.subtle) {
                log('ERROR: Encryption not available (file:// mode). Use localhost or HTTPS.', 'error');
                return;
            }
            
            // Get or create PIN for encryption
            let pin = sessionStorage.getItem('obs_pin');
            if (!pin) {
                pin = prompt('Create a PIN to encrypt your password (4+ characters):');
                if (!pin || pin.length < 4) {
                    log('PIN must be 4+ characters. Password not saved.', 'error');
                    storage.remove('obs_pw');
                    return;
                }
                sessionStorage.setItem('obs_pin', pin); // Keep in session only
            }
            
            try {
                const encrypted = await encryptPassword(password, pin);
                storage.setRaw('obs_pw', encrypted);
                storage.setRaw('obs_pw_encrypted', 'true');
                log('Credentials saved securely', 'success');
            } catch (e) {
                log('Encryption failed: ' + e.message, 'error');
                storage.remove('obs_pw');
                storage.remove('obs_pw_encrypted');
            }
        } else {
            storage.remove('obs_pw');
            storage.remove('obs_pw_encrypted');
        }
        storage.setRaw('obs_remember', 'true');
    } else {
        storage.remove('obs_host');
        storage.remove('obs_port');
        storage.remove('obs_pw');
        storage.remove('obs_pw_encrypted');
        storage.remove('obs_remember');
        sessionStorage.removeItem('obs_pin');
    }
}

async function loadCredentials() {
    const remembered = storage.getRaw('obs_remember') === 'true';
    document.getElementById('rememberCreds').checked = remembered;
    
    if (remembered) {
        const host = storage.getRaw('obs_host');
        const port = storage.getRaw('obs_port');
        const encryptedPw = storage.getRaw('obs_pw');
        const isEncrypted = storage.getRaw('obs_pw_encrypted') === 'true';
        
        if (host) document.getElementById('host').value = host;
        if (port) document.getElementById('port').value = port;
        
        if (encryptedPw && isEncrypted) {
            // Check if crypto is available
            if (!crypto || !crypto.subtle) {
                log('ERROR: Decryption not available (file:// mode). Clear credentials.', 'error');
                updateSecurityWarning();
                return false;
            }
            
            // Need PIN to decrypt
            let pin = sessionStorage.getItem('obs_pin');
            if (!pin) {
                pin = prompt('Enter PIN to unlock saved password:');
                if (!pin) {
                    log('PIN required to use saved password', 'error');
                    updateSecurityWarning();
                    return false;
                }
            }
            
            try {
                const password = await decryptPassword(encryptedPw, pin);
                if (password) {
                    document.getElementById('password').value = password;
                    sessionStorage.setItem('obs_pin', pin); // Remember for session
                    updateSecurityWarning();
                    return true;
                } else {
                    log('Wrong PIN or corrupted data', 'error');
                    sessionStorage.removeItem('obs_pin');
                    updateSecurityWarning();
                    return false;
                }
            } catch (e) {
                log('Decryption failed: ' + e.message, 'error');
                sessionStorage.removeItem('obs_pin');
                updateSecurityWarning();
                return false;
            }
        }
        
        updateSecurityWarning();
        return true; // Has host/port at least
    }
    return false;
}

function clearSavedCredentials() {
    storage.remove('obs_host');
    storage.remove('obs_port');
    storage.remove('obs_pw');
    storage.remove('obs_pw_encrypted');
    storage.remove('obs_remember');
    sessionStorage.removeItem('obs_pin');
    document.getElementById('host').value = 'localhost';
    document.getElementById('port').value = '4455';
    document.getElementById('password').value = '';
    document.getElementById('rememberCreds').checked = false;
    updateSecurityWarning();
    log('Saved credentials cleared', 'info');
}

function updateSecurityWarning() {
    const pw = document.getElementById('password').value;
    const remember = document.getElementById('rememberCreds').checked;
    const isEncrypted = storage.getRaw('obs_pw_encrypted') === 'true';
    const warn = document.getElementById('securityWarning');
    
    if (remember && pw) {
        if (isEncrypted) {
            warn.textContent = 'üîê Password encrypted with AES-256-GCM';
            warn.style.color = 'var(--success)';
        } else {
            warn.textContent = 'üîí Password will be encrypted with your PIN';
            warn.style.color = 'var(--accent)';
        }
    } else {
        warn.textContent = '';
    }
}

// ============ Connection State UI ============
function updateConnectionState() {
    const app = document.querySelector('.app');
    if (connected) {
        app.classList.remove('disconnected');
    } else {
        app.classList.add('disconnected');
    }
    
    // Disable action buttons when disconnected
    document.querySelectorAll('.source-btn, #startCycleBtn').forEach(btn => {
        btn.disabled = !connected;
    });
}

// ============ UI State Persistence ============
const UI_FIELDS = [
    'swapStyle', 'swapDuration', 'swapEasing', 'swapTempOverride',
    'textSource', 'textLines', 'textDuration', 'textTransition', 'transDuration',
    'swapSourceA', 'swapSourceB', 'swapNewSourceA', 'swapNewSourceB',
    'visAnimType', 'visAnimDuration', 'visAnimEasing'
];

// Checkbox fields need special handling
const UI_CHECKBOXES = ['swapPreserveAspect', 'swapDebugLogging'];

function saveUIState() {
    const state = {};
    for (const id of UI_FIELDS) {
        const el = document.getElementById(id);
        if (el) state[id] = el.value;
    }
    // Also save checkbox states
    for (const id of UI_CHECKBOXES) {
        const el = document.getElementById(id);
        if (el) state[id] = el.checked;
    }
    storage.set('ui_state', state);
}

function loadUIState() {
    try {
        const state = storage.get('ui_state') || {};
        for (const id of UI_FIELDS) {
            const el = document.getElementById(id);
            if (el && state[id] !== undefined && state[id] !== '') {
                el.value = state[id];
            }
        }
        // Also load checkbox states
        for (const id of UI_CHECKBOXES) {
            const el = document.getElementById(id);
            if (el && state[id] !== undefined) {
                el.checked = state[id];
            }
        }
    } catch (e) {
        console.error('Error loading UI state:', e);
    }
}

function setupUIStatePersistence() {
    // Save on any input change - multiple events for robustness
    for (const id of UI_FIELDS) {
        const el = document.getElementById(id);
        if (el) {
            el.addEventListener('change', saveUIState);
            el.addEventListener('input', saveUIState);
            el.addEventListener('blur', saveUIState);
        }
    }
    // Also listen to checkbox changes
    for (const id of UI_CHECKBOXES) {
        const el = document.getElementById(id);
        if (el) {
            el.addEventListener('change', saveUIState);
        }
    }
}

// ============ Initialization ============
document.addEventListener('DOMContentLoaded', async () => {
    // CRITICAL: Initialize storage system FIRST before anything else
    console.log('[Init] Starting storage initialization...');
    try {
        await initIndexedDB();
        await loadStorageCache();
        console.log('[Init] Storage system ready');
    } catch (e) {
        console.error('[Init] Storage init error (using fallback):', e);
    }
    
    // NOW load configs from storage into memory
    swapConfigs = storage.get('swapConfigs') || [];
    textCyclerConfigs = storage.get('textCyclerConfigs') || [];
    clipsConfigs = storage.get('clipsConfigs') || [];
    
    console.log('[Init] Loaded configs - Swaps:', swapConfigs.length, 
                'TextCycler:', textCyclerConfigs.length, 
                'Clips:', clipsConfigs.length);
    
    // Check for recovery if configs are empty
    const totalConfigs = swapConfigs.length + textCyclerConfigs.length + clipsConfigs.length;
    if (totalConfigs === 0) {
        const recovered = await offerRecovery();
        if (recovered) {
            console.log('[Init] Configs restored from recovery snapshot');
        }
    }
    
    // Start auto-backup system
    startAutoBackup();
    
    // Initialize UI modules
    console.log('[Init] Initializing UI modules...');
    SplitPanel.init();
    CollapsibleCards.init();
    
    // Set dock URL
    const url = window.location.href;
    document.getElementById('dockUrl').value = url;
    
    // Render loaded configs
    renderSavedSwaps();
    renderTextCyclerConfigs();
    initClipsPlayer();
    initScriptsAndInstaller();
    loadUIState();
    restoreActiveTab();
    updateConnectionState();
    setupUIStatePersistence();
    
    // Initialize script status (will show "not connected" banner)
    renderStartupBanner();
    updateTabStates();
    
    // Restore running text cyclers
    setTimeout(restoreRunningTextCyclers, 1000);
    updateTransitionMode();
    updateStorageStatus();
    
    // Setup credential UI listeners
    document.getElementById('rememberCreds').addEventListener('change', updateSecurityWarning);
    document.getElementById('password').addEventListener('input', updateSecurityWarning);
    
    // Load saved credentials and auto-connect
    try {
        const hasCreds = await loadCredentials();
        if (hasCreds && document.getElementById('password').value) {
            log('Credentials unlocked. Auto-connecting...', 'info');
            setTimeout(connect, 500);
        } else if (hasCreds) {
            log('Host/port loaded. Enter password to connect.', 'info');
        } else {
            log('Ready. Connect to OBS to begin.', 'info');
        }
    } catch (e) {
        console.error('Credential load error:', e);
        log('Ready. Connect to OBS to begin.', 'info');
    }
});

// ============ UI ============
function showPage(id, save = true) {
    // Check if tab is disabled (requires connection)
    const featurePages = ['sources', 'text', 'swaps'];
    if (featurePages.includes(id) && !scriptStatus.connected) {
        // Don't switch to disabled page, redirect to setup
        log('Connect to OBS first to use this feature', 'error');
        showPage('setup', false);
        return;
    }
    
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.getElementById('page-' + id).classList.add('active');
    
    // Find and activate the corresponding tab - must match order in HTML nav.tabs
    const tabs = document.querySelectorAll('.tab');
    const tabIds = ['dashboard', 'sources', 'text', 'clips', 'swaps', 'scripts', 'install', 'setup'];
    const tabIndex = tabIds.indexOf(id);
    if (tabIndex >= 0 && tabs[tabIndex]) {
        tabs[tabIndex].classList.add('active');
    }
    
    // Render feature notices for pages that require scripts
    const pageFeatureMap = {
        'sources': { id: 'page-sources', feature: 'sources', script: 'Source Animations' },
        'text': { id: 'page-text', feature: 'text', script: 'Text Cycler' },
        'swaps': { id: 'page-swaps', feature: 'swap', script: 'Source Swap' }
    };
    
    const pageInfo = pageFeatureMap[id];
    if (pageInfo) {
        renderFeatureNotice(pageInfo.id, pageInfo.feature, pageInfo.script);
    }
    
    // Save active tab
    if (save) {
        storage.setRaw('active_tab', id);
    }
}

function restoreActiveTab() {
    const savedTab = storage.getRaw('active_tab');
    if (savedTab) {
        showPage(savedTab, false);
    }
}

function log(msg, type = '') {
    const el = document.getElementById('log');
    if (!el) return;
    
    const entry = document.createElement('div');
    entry.className = 'log-entry ' + type;
    
    const time = document.createElement('span');
    time.className = 'log-entry__time';
    time.textContent = `[${new Date().toLocaleTimeString()}]`;
    
    const text = document.createElement('span');
    text.className = 'log-entry__text';
    text.textContent = msg;
    
    entry.appendChild(time);
    entry.appendChild(text);
    
    el.insertBefore(entry, el.firstChild);
    if (el.children.length > 100) el.removeChild(el.lastChild);
}

function clearLog() {
    const el = document.getElementById('log');
    if (el) el.innerHTML = '';
    log('Log cleared', 'info');
}

function copyUrl() {
    const url = document.getElementById('dockUrl');
    url.select();
    document.execCommand('copy');
    document.getElementById('copyStatus').textContent = '‚úì Copied to clipboard!';
    setTimeout(() => document.getElementById('copyStatus').textContent = '', 2000);
}

function renderDashSwaps() {
    const grid = document.getElementById('dashSwapGrid');
    if (swapConfigs.length === 0) {
        grid.innerHTML = '<div class="empty-state" style="padding:10px;grid-column:1/-1">No saved swaps. Go to üîÑ tab to create one.</div>';
        return;
    }
    grid.innerHTML = swapConfigs.map((c, i) => 
        `<button class="source-btn" onclick="loadSwapConfig(${i})">${c.name}</button>`
    ).join('');
}

function updateConnectionUI() {
    const dot = document.getElementById('statusDot');
    const btn = document.getElementById('connectBtn');
    const headerBtn = document.getElementById('connectHeaderBtn');
    
    if (connected) {
        dot.className = 'status-dot connected';
        btn.textContent = 'Disconnect';
        btn.className = 'btn-danger btn-block';
        headerBtn.textContent = 'Connected';
        headerBtn.className = 'btn-success';
    } else {
        dot.className = 'status-dot';
        btn.textContent = 'Connect';
        btn.className = 'btn-primary btn-block';
        headerBtn.textContent = 'Connect';
        headerBtn.className = '';
    }
}

// ============ WebSocket ============
function toggleConnection() {
    connected ? disconnect() : connect();
}

function connect() {
    const host = document.getElementById('host').value || 'localhost';
    const port = document.getElementById('port').value || '4455';
    const password = document.getElementById('password').value;
    
    document.getElementById('statusDot').className = 'status-dot connecting';
    log('Connecting...', 'info');
    
    try {
        ws = new WebSocket(`ws://${host}:${port}`);
        ws.onopen = () => {
            log('Socket open, authenticating...');
            reconnectAttempts = 0;
        };
        ws.onmessage = e => handleMessage(JSON.parse(e.data), password);
        ws.onerror = (e) => { 
            log('Connection error', 'error');
            console.log('WebSocket error:', e);
        };
        ws.onclose = (e) => { 
            const wasConnected = connected;
            connected = false;
            updateConnectionUI();
            updateConnectionState();
            
            // Reset script status on disconnect
            scriptStatus.connected = false;
            updateFeatureAvailability();
            renderStartupBanner();
            
            // Log close reason for debugging
            const reason = e.code === 1000 ? 'normal' : e.code === 1006 ? 'abnormal' : `code ${e.code}`;
            log(`Disconnected (${reason})`, wasConnected ? 'error' : 'info');
            console.log('WebSocket closed:', e.code, e.reason);
            
            // Only auto-reconnect on abnormal close, not if user disconnected
            if (wasConnected && e.code !== 1000 && storage.getRaw('obs_remember') === 'true') {
                if (reconnectAttempts < MAX_RECONNECT) {
                    reconnectAttempts++;
                    log(`Reconnecting (${reconnectAttempts}/${MAX_RECONNECT})...`, 'info');
                    setTimeout(connect, 3000); // Longer delay
                }
            }
        };
    } catch (e) {
        log('Failed: ' + e.message, 'error');
        updateConnectionState();
    }
}

function disconnect() {
    reconnectAttempts = MAX_RECONNECT; // Prevent auto-reconnect
    if (ws) ws.close();
    connected = false;
    updateConnectionUI();
    updateConnectionState();
}

async function handleMessage(data, password) {
    if (data.op === 0) { // Hello
        const auth = data.d.authentication;
        if (auth && password) {
            const secret = await sha256(password + auth.salt);
            const authStr = await sha256(secret + auth.challenge);
            send({ op: 1, d: { rpcVersion: 1, authentication: authStr } });
        } else if (!auth) {
            send({ op: 1, d: { rpcVersion: 1 } });
        } else {
            log('Password required', 'error');
            disconnect();
        }
    } else if (data.op === 2) { // Identified
        connected = true;
        updateConnectionUI();
        updateConnectionState();
        await saveCredentials(); // Save on successful connection
        log('Connected to OBS!', 'success');
        refreshScenes();
        
        // Check script status after connection
        setTimeout(checkScriptStatus, 500);
    } else if (data.op === 7) { // Response
        const req = pendingRequests[data.d.requestId];
        if (req) {
            if (data.d.requestStatus.result) {
                req.resolve(data.d.responseData);
            } else {
                req.reject(data.d.requestStatus.comment);
            }
            delete pendingRequests[data.d.requestId];
        }
    } else if (data.op === 5) { // Event
        handleEvent(data.d);
    }
}

function handleEvent(event) {
    if (event.eventType === 'CurrentProgramSceneChanged') {
        currentScene = event.eventData.sceneName;
        document.getElementById('currentScene').textContent = currentScene;
        refreshSources();
    }
}

function send(data) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(data));
    }
}

function request(type, data = {}) {
    return new Promise((resolve, reject) => {
        const id = 'req_' + (msgId++);
        pendingRequests[id] = { resolve, reject };
        send({ op: 6, d: { requestType: type, requestId: id, requestData: data } });
        setTimeout(() => {
            if (pendingRequests[id]) {
                delete pendingRequests[id];
                reject('Timeout');
            }
        }, 5000);
    });
}

async function sha256(msg) {
    const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(msg));
    return btoa(String.fromCharCode(...new Uint8Array(buf)));
}

// ============ OBS Actions ============
async function refreshScenes() {
    if (!connected) return;
    try {
        const data = await request('GetCurrentProgramScene');
        currentScene = data.currentProgramSceneName;
        document.getElementById('currentScene').innerHTML = `<strong>${currentScene}</strong>`;
        refreshSources();
        log('Refreshed scene: ' + currentScene);
    } catch (e) {
        log('Error: ' + e, 'error');
    }
}

async function refreshSources() {
    if (!connected || !currentScene) return;
    try {
        const data = await request('GetSceneItemList', { sceneName: currentScene });
        sources = data.sceneItems || [];
        renderSources();
        updateTextSourceDropdown();
        updateSwapDropdowns();
        log(`Found ${sources.length} sources`);
    } catch (e) {
        log('Error getting sources: ' + e, 'error');
    }
}

function renderSources() {
    const list = document.getElementById('sourcesList');
    if (sources.length === 0) {
        list.innerHTML = '<div class="empty-state">No sources in current scene</div>';
        return;
    }
    
    list.innerHTML = sources.map(s => `
        <div class="source-item">
            <div>
                <div class="name">${s.sourceName}</div>
                <div class="type">${s.inputKind || 'scene'}</div>
            </div>
            <div class="toggle ${s.sceneItemEnabled ? 'on' : ''}" 
                 onclick="toggleSource('${s.sourceName}', ${s.sceneItemId}, ${!s.sceneItemEnabled})"></div>
        </div>
    `).join('');
    
    // Initialize/refresh search for sources list
    initSearchForList('sources', 'sourcesSearchInput', list, sources.length);
}

async function toggleSource(name, id, enabled) {
    const animType = document.getElementById('visAnimType').value;
    const duration = parseInt(document.getElementById('visAnimDuration').value) || 300;
    const easing = document.getElementById('visAnimEasing').value;
    
    try {
        if (animType === 'none') {
            // Instant toggle
            await request('SetSceneItemEnabled', {
                sceneName: currentScene,
                sceneItemId: id,
                sceneItemEnabled: enabled
            });
        } else {
            // Animated toggle
            await animateVisibility(id, enabled, animType, duration, easing);
        }
        log(`${name}: ${enabled ? 'shown' : 'hidden'}`, 'success');
        refreshSources();
    } catch (e) {
        log('Error: ' + e, 'error');
    }
}

async function animateVisibility(itemId, show, animType, duration, easing) {
    // Get current transform
    const data = await request('GetSceneItemTransform', {
        sceneName: currentScene,
        sceneItemId: itemId
    });
    const original = data.sceneItemTransform;
    
    // Calculate start and end states based on animation type
    let startTransform = {...original};
    let endTransform = {...original};
    
    const offscreenX = 200; // Pixels to slide
    const offscreenY = 200;
    
    if (animType === 'fade') {
        // For fade, we'll use scale as a proxy (0.01 to 1)
        if (show) {
            startTransform.scaleX = 0.01;
            startTransform.scaleY = 0.01;
        } else {
            endTransform.scaleX = 0.01;
            endTransform.scaleY = 0.01;
        }
    } else if (animType === 'slide_left') {
        if (show) {
            startTransform.positionX = original.positionX - offscreenX;
        } else {
            endTransform.positionX = original.positionX - offscreenX;
        }
    } else if (animType === 'slide_right') {
        if (show) {
            startTransform.positionX = original.positionX + offscreenX;
        } else {
            endTransform.positionX = original.positionX + offscreenX;
        }
    } else if (animType === 'slide_up') {
        if (show) {
            startTransform.positionY = original.positionY - offscreenY;
        } else {
            endTransform.positionY = original.positionY - offscreenY;
        }
    } else if (animType === 'slide_down') {
        if (show) {
            startTransform.positionY = original.positionY + offscreenY;
        } else {
            endTransform.positionY = original.positionY + offscreenY;
        }
    } else if (animType === 'zoom') {
        if (show) {
            startTransform.scaleX = 0.01;
            startTransform.scaleY = 0.01;
        } else {
            endTransform.scaleX = 0.01;
            endTransform.scaleY = 0.01;
        }
    } else if (animType === 'pop') {
        if (show) {
            startTransform.scaleX = 0.01;
            startTransform.scaleY = 0.01;
        } else {
            endTransform.scaleX = 1.2;
            endTransform.scaleY = 1.2;
        }
    }
    
    // If showing, enable first then animate
    if (show) {
        // Set to start state
        await setTransformAwait(itemId, startTransform);
        // Enable visibility
        await request('SetSceneItemEnabled', {
            sceneName: currentScene,
            sceneItemId: itemId,
            sceneItemEnabled: true
        });
        // Animate to end state
        await animateTransform(itemId, startTransform, endTransform, duration, easing);
        // Restore original
        await setTransformAwait(itemId, original);
    } else {
        // If hiding, animate first then disable
        await animateTransform(itemId, startTransform, endTransform, duration, easing);
        // Disable visibility
        await request('SetSceneItemEnabled', {
            sceneName: currentScene,
            sceneItemId: itemId,
            sceneItemEnabled: false
        });
        // Restore original transform (for next show)
        await setTransformAwait(itemId, original);
    }
}

// Critical transform - waits for confirmation
async function setTransformAwait(itemId, transform) {
    if (!connected) return;
    
    await request('SetSceneItemTransform', {
        sceneName: currentScene,
        sceneItemId: itemId,
        sceneItemTransform: {
            positionX: transform.positionX,
            positionY: transform.positionY,
            scaleX: transform.scaleX,
            scaleY: transform.scaleY
        }
    });
}

// Fast transform for animation loop - fire and forget
function setTransformFireForget(itemId, transform) {
    if (!connected || !ws || ws.readyState !== WebSocket.OPEN) return;
    
    ws.send(JSON.stringify({
        op: 6,
        d: {
            requestType: 'SetSceneItemTransform',
            requestId: 'anim_' + (msgId++),
            requestData: {
                sceneName: currentScene,
                sceneItemId: itemId,
                sceneItemTransform: {
                    positionX: transform.positionX,
                    positionY: transform.positionY,
                    scaleX: transform.scaleX,
                    scaleY: transform.scaleY
                }
            }
        }
    }));
}

async function animateTransform(itemId, start, end, duration, easingType) {
    return new Promise(resolve => {
        const startTime = Date.now();
        const STEP_MS = 50; // 20 updates/sec max
        
        function step() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const t = easeFunc(progress, easingType);
            
            const current = {
                positionX: lerp(start.positionX, end.positionX, t),
                positionY: lerp(start.positionY, end.positionY, t),
                scaleX: lerp(start.scaleX, end.scaleX, t),
                scaleY: lerp(start.scaleY, end.scaleY, t)
            };
            
            setTransformFireForget(itemId, current);
            
            if (progress < 1) {
                setTimeout(step, STEP_MS);
            } else {
                resolve();
            }
        }
        
        step();
    });
}

// ============ Source Swap (Direct via WebSocket) ============
let swapConfigs = []; // Loaded async from storage on init
let isSwapping = false;

function updateSwapDropdowns() {
    const selA = document.getElementById('swapSourceA');
    const selB = document.getElementById('swapSourceB');
    const newSelA = document.getElementById('swapNewSourceA');
    const newSelB = document.getElementById('swapNewSourceB');
    
    // Preserve current selections or load from saved state
    const savedState = storage.get('ui_state') || {};
    const currentA = selA.value || savedState.swapSourceA || '';
    const currentB = selB.value || savedState.swapSourceB || '';
    
    const opts = '<option value="">-- Select --</option>' + 
        sources.map(s => `<option value="${s.sourceName}">${s.sourceName}</option>`).join('');
    selA.innerHTML = opts;
    selB.innerHTML = opts;
    
    // Also populate the "Add Config" dropdowns
    if (newSelA) newSelA.innerHTML = opts;
    if (newSelB) newSelB.innerHTML = opts;
    
    // Restore selections if sources still exist
    if (currentA && sources.find(s => s.sourceName === currentA)) selA.value = currentA;
    if (currentB && sources.find(s => s.sourceName === currentB)) selB.value = currentB;
}

async function getSceneItemId(sourceName) {
    // First try cached sources (fast path)
    const cached = sources.find(s => s.sourceName === sourceName);
    if (cached) return cached.sceneItemId;
    
    // Cache miss - query OBS directly (handles stale cache, scene changes, etc.)
    try {
        const data = await request('GetSceneItemId', {
            sceneName: currentScene,
            sourceName: sourceName
        });
        return data.sceneItemId || null;
    } catch (e) {
        console.warn(`[Swap] Source "${sourceName}" not found in scene "${currentScene}":`, e);
        return null;
    }
}

async function getTransform(sceneItemId) {
    try {
        const data = await request('GetSceneItemTransform', {
            sceneName: currentScene,
            sceneItemId: sceneItemId
        });
        return data.sceneItemTransform;
    } catch (e) {
        console.error(`[Swap] Failed to get transform for item ${sceneItemId}:`, e);
        throw new Error(`Failed to get transform for item ${sceneItemId}: ${e}`);
    }
}

async function setTransform(sceneItemId, transform) {
    try {
        // Sanitize transform values - OBS requires bounds >= 1 and scale > 0
        const sanitized = { ...transform };
        
        // Ensure bounds are at least 1 (or remove if 0/invalid)
        if (sanitized.boundsWidth !== undefined) {
            if (sanitized.boundsWidth < 1) {
                delete sanitized.boundsWidth;
            }
        }
        if (sanitized.boundsHeight !== undefined) {
            if (sanitized.boundsHeight < 1) {
                delete sanitized.boundsHeight;
            }
        }
        
        // Ensure scale is positive
        if (sanitized.scaleX !== undefined && sanitized.scaleX <= 0) {
            sanitized.scaleX = 0.001;
        }
        if (sanitized.scaleY !== undefined && sanitized.scaleY <= 0) {
            sanitized.scaleY = 0.001;
        }
        
        await request('SetSceneItemTransform', {
            sceneName: currentScene,
            sceneItemId: sceneItemId,
            sceneItemTransform: sanitized
        });
    } catch (e) {
        console.error(`[Swap] Failed to set transform for item ${sceneItemId}:`, e);
        throw new Error(`Failed to set transform: ${e}`);
    }
}

// ============ Enhanced Easing Functions ============
function easeFunc(t, type) {
    switch(type) {
        case 'easeIn': return t * t * t;
        case 'easeOut': return 1 - Math.pow(1 - t, 3);
        case 'ease': return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
        case 'back': {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return t < 0.5
                ? (Math.pow(2*t, 2) * ((c3 + 1) * 2*t - c3)) / 2
                : (Math.pow(2*t - 2, 2) * ((c3 + 1) * (t*2 - 2) + c3) + 2) / 2;
        }
        case 'bounce': {
            const n1 = 7.5625, d1 = 2.75;
            let x = t;
            if (x < 1/d1) return n1 * x * x;
            if (x < 2/d1) return n1 * (x -= 1.5/d1) * x + 0.75;
            if (x < 2.5/d1) return n1 * (x -= 2.25/d1) * x + 0.9375;
            return n1 * (x -= 2.625/d1) * x + 0.984375;
        }
        case 'elastic': {
            const c4 = (2 * Math.PI) / 3;
            return t === 0 ? 0 : t === 1 ? 1 :
                t < 0.5
                    ? -(Math.pow(2, 20*t - 10) * Math.sin((20*t - 11.125) * c4)) / 2
                    : (Math.pow(2, -20*t + 10) * Math.sin((20*t - 11.125) * c4)) / 2 + 1;
        }
        default: return t; // linear
    }
}

function lerp(a, b, t) { return a + (b - a) * t; }

// ============ Animation Style Implementations ============
async function animateSlide(idA, idB, startA, startB, endA, endB, duration, easing, propsToSwap) {
    const startTime = performance.now();
    
    await new Promise((resolve, reject) => {
        function animate() {
            const elapsed = performance.now() - startTime;
            const rawT = Math.min(elapsed / duration, 1);
            const t = easeFunc(rawT, easing);
            
            // Lerp each source's own properties (they may differ in mixed bounds/scale case)
            const currentA = {};
            const currentB = {};
            
            for (const p of Object.keys(startA)) {
                if (endA[p] !== undefined) {
                    currentA[p] = lerp(startA[p], endA[p], t);
                }
            }
            for (const p of Object.keys(startB)) {
                if (endB[p] !== undefined) {
                    currentB[p] = lerp(startB[p], endB[p], t);
                }
            }
            
            Promise.all([
                setTransform(idA, currentA),
                setTransform(idB, currentB)
            ]).then(() => {
                if (rawT < 1) requestAnimationFrame(animate);
                else resolve();
            }).catch(err => {
                console.error('[Swap] animateSlide error:', err);
                reject(err);
            });
        }
        requestAnimationFrame(animate);
    });
}

async function animateArc(idA, idB, startA, startB, endA, endB, duration, easing) {
    const startTime = performance.now();
    const arcHeight = 100; // Pixels to arc upward
    
    await new Promise((resolve, reject) => {
        function animate() {
            const elapsed = performance.now() - startTime;
            const rawT = Math.min(elapsed / duration, 1);
            const t = easeFunc(rawT, easing);
            
            // Parabolic arc: peaks at t=0.5
            const arcOffset = -4 * arcHeight * rawT * (rawT - 1);
            
            // Only animate properties that exist in start/end objects
            const currentA = {
                positionX: lerp(startA.positionX, endA.positionX, t),
                positionY: lerp(startA.positionY, endA.positionY, t) - arcOffset
            };
            const currentB = {
                positionX: lerp(startB.positionX, endB.positionX, t),
                positionY: lerp(startB.positionY, endB.positionY, t) - arcOffset
            };
            
            // Add scale if present
            if (startA.scaleX !== undefined) {
                currentA.scaleX = lerp(startA.scaleX, endA.scaleX, t);
                currentA.scaleY = lerp(startA.scaleY, endA.scaleY, t);
            }
            if (startB.scaleX !== undefined) {
                currentB.scaleX = lerp(startB.scaleX, endB.scaleX, t);
                currentB.scaleY = lerp(startB.scaleY, endB.scaleY, t);
            }
            
            // Add bounds if present
            if (startA.boundsWidth !== undefined) {
                currentA.boundsWidth = lerp(startA.boundsWidth, endA.boundsWidth, t);
                currentA.boundsHeight = lerp(startA.boundsHeight, endA.boundsHeight, t);
            }
            if (startB.boundsWidth !== undefined) {
                currentB.boundsWidth = lerp(startB.boundsWidth, endB.boundsWidth, t);
                currentB.boundsHeight = lerp(startB.boundsHeight, endB.boundsHeight, t);
            }
            
            Promise.all([
                setTransform(idA, currentA),
                setTransform(idB, currentB)
            ]).then(() => {
                if (rawT < 1) requestAnimationFrame(animate);
                else resolve();
            }).catch(err => {
                console.error('[Swap] animateArc error:', err);
                reject(err);
            });
        }
        requestAnimationFrame(animate);
    });
}

async function animateScale(idA, idB, startA, startB, endA, endB, duration, easing) {
    const startTime = performance.now();
    
    await new Promise((resolve, reject) => {
        function animate() {
            const elapsed = performance.now() - startTime;
            const rawT = Math.min(elapsed / duration, 1);
            
            // Shrink in first half, grow in second half (shrink to 30%)
            let scaleMod;
            if (rawT < 0.5) {
                scaleMod = 1 - (rawT * 2) * 0.7; // Shrink from 1.0 to 0.3
            } else {
                scaleMod = 0.3 + ((rawT - 0.5) * 2) * 0.7; // Grow from 0.3 back to 1.0
            }
            
            // Position JUMPS at midpoint (not smooth slide!)
            const posT = rawT < 0.5 ? 0 : 1;
            
            const currentA = {
                positionX: lerp(startA.positionX, endA.positionX, posT),
                positionY: lerp(startA.positionY, endA.positionY, posT)
            };
            const currentB = {
                positionX: lerp(startB.positionX, endB.positionX, posT),
                positionY: lerp(startB.positionY, endB.positionY, posT)
            };
            
            // Add scale with modifier if using scale
            if (startA.scaleX !== undefined) {
                currentA.scaleX = (startA.scaleX || 1) * scaleMod;
                currentA.scaleY = (startA.scaleY || 1) * scaleMod;
            }
            if (startB.scaleX !== undefined) {
                currentB.scaleX = (startB.scaleX || 1) * scaleMod;
                currentB.scaleY = (startB.scaleY || 1) * scaleMod;
            }
            
            // Add bounds if present (jump at midpoint, no scale mod)
            if (startA.boundsWidth !== undefined) {
                currentA.boundsWidth = lerp(startA.boundsWidth, endA.boundsWidth, posT);
                currentA.boundsHeight = lerp(startA.boundsHeight, endA.boundsHeight, posT);
            }
            if (startB.boundsWidth !== undefined) {
                currentB.boundsWidth = lerp(startB.boundsWidth, endB.boundsWidth, posT);
                currentB.boundsHeight = lerp(startB.boundsHeight, endB.boundsHeight, posT);
            }
            
            Promise.all([
                setTransform(idA, currentA),
                setTransform(idB, currentB)
            ]).then(() => {
                if (rawT < 1) requestAnimationFrame(animate);
                else resolve();
            }).catch(err => {
                console.error('[Swap] animateScale error:', err);
                reject(err);
            });
        }
        requestAnimationFrame(animate);
    });
}

async function animateCrossfade(idA, idB, nameA, nameB, endA, endB, duration) {
    // Fade out both, swap positions, fade in both
    const halfDur = duration / 2;
    
    // Get source refs for opacity (requires filter manipulation via SetSourceFilterSettings)
    // Simplified: just do instant swap with a brief delay
    // For true crossfade, we'd need color correction filters
    
    // Quick version: scale down, swap, scale up
    const startTime = performance.now();
    
    await new Promise((resolve, reject) => {
        function animate() {
            const elapsed = performance.now() - startTime;
            const rawT = Math.min(elapsed / duration, 1);
            
            // Opacity simulation via scale (0.5 at midpoint)
            let opacityScale;
            if (rawT < 0.5) {
                opacityScale = 1 - rawT; // Fade out
            } else {
                opacityScale = rawT; // Fade in
            }
            
            // Position jumps at midpoint
            const posT = rawT < 0.5 ? 0 : 1;
            
            // Use the IDs passed to function, not stale cache lookup
            Promise.all([
                setTransform(idA, { scaleX: endA.scaleX * opacityScale, scaleY: endA.scaleY * opacityScale }),
                setTransform(idB, { scaleX: endB.scaleX * opacityScale, scaleY: endB.scaleY * opacityScale })
            ]).then(() => {
                if (rawT < 1) requestAnimationFrame(animate);
                else resolve();
            }).catch(err => {
                console.error('[Swap] animateCrossfade error:', err);
                reject(err);
            });
        }
        requestAnimationFrame(animate);
    });
}

async function executeSwap(sourceAOverride, sourceBOverride) {
    if (!connected) { 
        log('Connect to OBS first', 'error'); 
        showPage('setup');
        return; 
    }
    if (isSwapping) { log('Swap in progress', 'error'); return; }
    
    // Use override params if provided (from loadSwapConfig), otherwise read from dropdowns
    const nameA = sourceAOverride || document.getElementById('swapSourceA').value;
    const nameB = sourceBOverride || document.getElementById('swapSourceB').value;
    
    if (!nameA || !nameB) { log('Select both sources', 'error'); return; }
    if (nameA === nameB) { log('Select different sources', 'error'); return; }
    
    const idA = await getSceneItemId(nameA);
    const idB = await getSceneItemId(nameB);
    
    if (!idA) { 
        log(`Source not found: "${nameA}" - not in current scene "${currentScene}"`, 'error'); 
        return; 
    }
    if (!idB) { 
        log(`Source not found: "${nameB}" - not in current scene "${currentScene}"`, 'error'); 
        return; 
    }
    
    isSwapping = true;
    const style = document.getElementById('swapStyle').value;
    log(`Swapping ${nameA} ‚Üî ${nameB} (${style})...`, 'info');
    
    try {
        const tA = await getTransform(idA);
        const tB = await getTransform(idB);
        
        const duration = parseInt(document.getElementById('swapDuration').value) || 400;
        const easing = document.getElementById('swapEasing').value;
        
        // Read control panel settings
        const preserveAspect = document.getElementById('swapPreserveAspect')?.checked ?? true;
        const debugLogging = document.getElementById('swapDebugLogging')?.checked ?? false;
        const tempOverride = document.getElementById('swapTempOverride')?.value || 'off';
        
        if (debugLogging) {
            console.log('[Swap Debug] Transform A:', JSON.stringify(tA, null, 2));
            console.log('[Swap Debug] Transform B:', JSON.stringify(tB, null, 2));
            console.log('[Swap Debug] Settings - preserveAspect:', preserveAspect, 'tempOverride:', tempOverride);
        }
        
        // Calculate visual sizes for each source
        // Bounds mode: visual size = bounds
        // Scale mode: visual size = sourceWidth * scaleX, sourceHeight * scaleY
        const aUsesBounds = tA.boundsWidth >= 1 && tA.boundsHeight >= 1;
        const bUsesBounds = tB.boundsWidth >= 1 && tB.boundsHeight >= 1;
        
        // Get visual sizes
        const sizeA = {
            width: aUsesBounds ? tA.boundsWidth : (tA.sourceWidth * tA.scaleX),
            height: aUsesBounds ? tA.boundsHeight : (tA.sourceHeight * tA.scaleY)
        };
        const sizeB = {
            width: bUsesBounds ? tB.boundsWidth : (tB.sourceWidth * tB.scaleX),
            height: bUsesBounds ? tB.boundsHeight : (tB.sourceHeight * tB.scaleY)
        };
        
        if (debugLogging) {
            console.log('[Swap Debug] A uses bounds:', aUsesBounds, 'size:', sizeA);
            console.log('[Swap Debug] B uses bounds:', bUsesBounds, 'size:', sizeB);
        }
        
        // Build start and end states - swap positions and visual sizes
        const startA = {
            positionX: tA.positionX,
            positionY: tA.positionY
        };
        const startB = {
            positionX: tB.positionX,
            positionY: tB.positionY
        };
        
        // End positions: swap them
        const endA = {
            positionX: tB.positionX,
            positionY: tB.positionY
        };
        const endB = {
            positionX: tA.positionX,
            positionY: tA.positionY
        };
        
        // Handle sizing based on what each source uses
        // A should end up with B's visual size, and vice versa
        if (aUsesBounds) {
            startA.boundsWidth = tA.boundsWidth;
            startA.boundsHeight = tA.boundsHeight;
            endA.boundsWidth = sizeB.width;
            endA.boundsHeight = sizeB.height;
        } else {
            startA.scaleX = tA.scaleX;
            startA.scaleY = tA.scaleY;
            // Convert B's size to scale for A
            endA.scaleX = sizeB.width / (tA.sourceWidth || sizeA.width / tA.scaleX);
            endA.scaleY = sizeB.height / (tA.sourceHeight || sizeA.height / tA.scaleY);
        }
        
        if (bUsesBounds) {
            startB.boundsWidth = tB.boundsWidth;
            startB.boundsHeight = tB.boundsHeight;
            endB.boundsWidth = sizeA.width;
            endB.boundsHeight = sizeA.height;
        } else {
            startB.scaleX = tB.scaleX;
            startB.scaleY = tB.scaleY;
            // Convert A's size to scale for B
            endB.scaleX = sizeA.width / (tB.sourceWidth || sizeB.width / tB.scaleX);
            endB.scaleY = sizeA.height / (tB.sourceHeight || sizeB.height / tB.scaleY);
        }
        
        // Build propsToSwap for animation functions
        const propsToSwap = ['positionX', 'positionY'];
        if (aUsesBounds || bUsesBounds) {
            if (startA.boundsWidth !== undefined) propsToSwap.push('boundsWidth', 'boundsHeight');
            if (startA.scaleX !== undefined) propsToSwap.push('scaleX', 'scaleY');
        } else {
            propsToSwap.push('scaleX', 'scaleY');
        }
        
        if (debugLogging) {
            console.log('[Swap Debug] startA:', startA, 'endA:', endA);
            console.log('[Swap Debug] startB:', startB, 'endB:', endB);
            console.log('[Swap Debug] propsToSwap:', propsToSwap);
        }
        
        if (style === 'teleport' || duration <= 0) {
            // Instant swap
            await setTransform(idA, endA);
            await setTransform(idB, endB);
        } else if (style === 'arc') {
            await animateArc(idA, idB, startA, startB, endA, endB, duration, easing);
            await setTransform(idA, endA);
            await setTransform(idB, endB);
        } else if (style === 'scale') {
            await animateScale(idA, idB, startA, startB, endA, endB, duration, easing);
            await setTransform(idA, endA);
            await setTransform(idB, endB);
        } else if (style === 'bounce') {
            await animateSlide(idA, idB, startA, startB, endA, endB, duration, 'bounce', propsToSwap);
        } else if (style === 'elastic') {
            await animateSlide(idA, idB, startA, startB, endA, endB, duration, 'elastic', propsToSwap);
        } else {
            // Default slide
            const startTime = performance.now();
            
            await new Promise((resolve, reject) => {
                function animate() {
                    const elapsed = performance.now() - startTime;
                    const rawT = Math.min(elapsed / duration, 1);
                    const t = easeFunc(rawT, easing);
                    
                    // Lerp each source's own properties (they may differ)
                    const currentA = {};
                    const currentB = {};
                    
                    for (const p of Object.keys(startA)) {
                        if (endA[p] !== undefined) {
                            currentA[p] = lerp(startA[p], endA[p], t);
                        }
                    }
                    for (const p of Object.keys(startB)) {
                        if (endB[p] !== undefined) {
                            currentB[p] = lerp(startB[p], endB[p], t);
                        }
                    }
                    
                    Promise.all([
                        setTransform(idA, currentA),
                        setTransform(idB, currentB)
                    ]).then(() => {
                        if (rawT < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    }).catch(err => {
                        console.error('[Swap] Default slide error:', err);
                        reject(err);
                    });
                }
                requestAnimationFrame(animate);
            });
        }
        
        // Apply bounds type if using bounds (based on settings)
        if (aUsesBounds) {
            let boundsType = preserveAspect ? 'OBS_BOUNDS_SCALE_INNER' : 'OBS_BOUNDS_STRETCH';
            if (tempOverride === 'preserve') boundsType = 'OBS_BOUNDS_SCALE_INNER';
            else if (tempOverride === 'stretch') boundsType = 'OBS_BOUNDS_STRETCH';
            
            await request('SetSceneItemTransform', {
                sceneName: currentScene,
                sceneItemId: idA,
                sceneItemTransform: { boundsType }
            }).catch(e => console.warn('[Swap] Could not set bounds type for A:', e));
        }
        if (bUsesBounds) {
            let boundsType = preserveAspect ? 'OBS_BOUNDS_SCALE_INNER' : 'OBS_BOUNDS_STRETCH';
            if (tempOverride === 'preserve') boundsType = 'OBS_BOUNDS_SCALE_INNER';
            else if (tempOverride === 'stretch') boundsType = 'OBS_BOUNDS_STRETCH';
            
            await request('SetSceneItemTransform', {
                sceneName: currentScene,
                sceneItemId: idB,
                sceneItemTransform: { boundsType }
            }).catch(e => console.warn('[Swap] Could not set bounds type for B:', e));
        }
        
        log(`Swapped ${nameA} ‚Üî ${nameB}`, 'success');
    } catch (e) {
        log('Swap error: ' + e, 'error');
    }
    
    isSwapping = false;
}

function saveCurrentSwap() {
    const nameA = document.getElementById('swapSourceA').value;
    const nameB = document.getElementById('swapSourceB').value;
    if (!nameA || !nameB) { log('Select both sources first', 'error'); return; }
    
    const name = prompt('Config name:', `${nameA} ‚Üî ${nameB}`);
    if (!name) return;
    
    swapConfigs.push({ name, sourceA: nameA, sourceB: nameB });
    storage.set('swapConfigs', swapConfigs);
    renderSavedSwaps();
    log(`Saved config: ${name}`, 'success');
}

function addSwapConfig() {
    const configName = document.getElementById('swapConfigName').value.trim();
    const sourceA = document.getElementById('swapNewSourceA').value;
    const sourceB = document.getElementById('swapNewSourceB').value;
    
    if (!configName) { log('Enter a config name', 'error'); return; }
    if (!sourceA || !sourceB) { log('Select both sources', 'error'); return; }
    if (sourceA === sourceB) { log('Select different sources', 'error'); return; }
    
    swapConfigs.push({ name: configName, sourceA, sourceB });
    storage.set('swapConfigs', swapConfigs);
    renderSavedSwaps();
    
    // Clear the form
    document.getElementById('swapConfigName').value = '';
    log(`Added config: ${configName}`, 'success');
}

function refreshSwapSources() {
    // Populate the new source dropdowns for adding configs
    const sourceASelect = document.getElementById('swapNewSourceA');
    const sourceBSelect = document.getElementById('swapNewSourceB');
    const quickSourceA = document.getElementById('swapSourceA');
    const quickSourceB = document.getElementById('swapSourceB');
    
    if (quickSourceA && sourceASelect) {
        sourceASelect.innerHTML = quickSourceA.innerHTML;
    }
    if (quickSourceB && sourceBSelect) {
        sourceBSelect.innerHTML = quickSourceB.innerHTML;
    }
    log('Sources refreshed', 'info');
}

function renderSavedSwaps() {
    const container = document.getElementById('savedSwaps');
    if (swapConfigs.length === 0) {
        container.innerHTML = '<div class="empty-state" style="padding:15px">No saved configs</div>';
    } else {
        container.innerHTML = swapConfigs.map((c, i) => `
            <div class="source-item">
                <div>
                    <div class="name">${c.name}</div>
                    <div class="type">${c.sourceA} ‚Üî ${c.sourceB}</div>
                </div>
                <div style="display:flex;gap:4px">
                    <button onclick="loadSwapConfig(${i})">‚ñ∂</button>
                    <button onclick="deleteSwapConfig(${i})">‚úï</button>
                </div>
            </div>
        `).join('');
    }
    renderDashSwaps();
    
    // Initialize/refresh search for swap configs
    initSearchForList('swapConfigs', 'swapConfigsSearchInput', container, swapConfigs.length);
}

function loadSwapConfig(index) {
    const c = swapConfigs[index];
    if (!c) {
        log('Config not found', 'error');
        return;
    }
    // Pass sources directly to executeSwap, bypassing dropdown dependency
    // Also update dropdowns if possible (for visual feedback)
    const selA = document.getElementById('swapSourceA');
    const selB = document.getElementById('swapSourceB');
    if (selA) selA.value = c.sourceA;
    if (selB) selB.value = c.sourceB;
    executeSwap(c.sourceA, c.sourceB);
}

function deleteSwapConfig(index) {
    swapConfigs.splice(index, 1);
    storage.set('swapConfigs', swapConfigs);
    renderSavedSwaps();
}

function exportConfigs() {
    if (swapConfigs.length === 0) {
        log('No configs to export', 'error');
        return;
    }
    const json = JSON.stringify(swapConfigs, null, 2);
    navigator.clipboard.writeText(json).then(() => {
        log('Configs copied to clipboard!', 'success');
    }).catch(() => {
        // Fallback: show in prompt
        prompt('Copy this JSON:', json);
    });
}

function importConfigs() {
    const json = prompt('Paste config JSON:');
    if (!json) return;
    
    try {
        const imported = JSON.parse(json);
        if (!Array.isArray(imported)) throw new Error('Must be array');
        
        // Validate structure
        for (const c of imported) {
            if (!c.name || !c.sourceA || !c.sourceB) {
                throw new Error('Invalid config structure');
            }
        }
        
        // Merge or replace?
        const merge = swapConfigs.length > 0 && confirm('Merge with existing? (Cancel to replace)');
        if (merge) {
            swapConfigs = [...swapConfigs, ...imported];
        } else {
            swapConfigs = imported;
        }
        
        storage.set('swapConfigs', swapConfigs);
        renderSavedSwaps();
        log(`Imported ${imported.length} configs`, 'success');
    } catch (e) {
        log('Invalid JSON: ' + e.message, 'error');
    }
}

// ============ Text Cycler (Multi-Config) ============
let textCyclerConfigs = []; // Loaded async from storage on init
let currentTextConfigIndex = -1;
let cycleInterval = null;
let cycleIndex = 0;
let transitionInterval = null;
let textChannels = {}; // BroadcastChannels for each config

// Character sets for effects
const CHARS_ENCHANT = '·îë·í∑·ìµ‚Ü∏·í∑‚éì‚ä£‚çë‚ïé‚ãÆÍñåÍñé·í≤„É™ùôπ·ëë‚à∑·ì≠‚Ñ∏‚öç‚çä‚à¥‚®Ö';
const CHARS_GLITCH = '‚ñà‚ñì‚ñí‚ñë‚ïî‚ïó‚ïö‚ïù‚ïë‚ïê‚îå‚îê‚îî‚îò‚îÇ‚îÄ‚îº‚ñÄ‚ñÑ‚ñå‚ñê‚ñ†‚ñ°‚ñ™‚ñ´‚óè‚óã';

function renderTextCyclerConfigs() {
    const container = document.getElementById('textCyclerConfigs');
    if (textCyclerConfigs.length === 0) {
        container.innerHTML = '<div class="empty-state">No configs yet. Click "New Config" to create one.</div>';
        return;
    }
    
    container.innerHTML = textCyclerConfigs.map((c, i) => `
        <div class="source-item" style="cursor:pointer" onclick="loadTextConfig(${i})">
            <div>
                <div class="name">${c.name || 'Unnamed'} ${c.isRunning ? '<span class="badge badge-success">Running</span>' : ''}</div>
                <div class="type">${c.mode === 'browser' ? 'üåê Browser' : 'üìù Legacy'} ‚Ä¢ ${(c.textLines || []).length} lines ‚Ä¢ ${c.transition || 'none'}</div>
            </div>
            <div style="display:flex;gap:4px">
                <button onclick="event.stopPropagation(); quickStartConfig(${i})" title="${c.isRunning ? 'Stop' : 'Start'}">${c.isRunning ? '‚èπ' : '‚ñ∂'}</button>
            </div>
        </div>
    `).join('');
    
    // Initialize/refresh search for text configs
    initSearchForList('textConfigs', 'textConfigsSearchInput', container, textCyclerConfigs.length);
}

function newTextConfig() {
    const config = {
        id: 'config_' + Date.now(),
        name: 'Text Cycler ' + (textCyclerConfigs.length + 1),
        mode: 'browser',
        configId: 'text' + (textCyclerConfigs.length + 1),
        textSource: '',
        textLines: ['Welcome to the stream!', 'Don\'t forget to subscribe!', 'Thanks for watching!'],
        transition: 'obfuscate',
        transDuration: 500,
        cycleDuration: 3000,
        styles: {
            fontSize: '48px',
            fontWeight: '700',
            color: '#ffffff',
            align: 'center',
            shadow: '2px 2px 4px rgba(0,0,0,0.5)'
        },
        isRunning: false
    };
    
    textCyclerConfigs.push(config);
    saveTextCyclerConfigs();
    renderTextCyclerConfigs();
    loadTextConfig(textCyclerConfigs.length - 1);
    log('Created new text config', 'success');
}

function loadTextConfig(index) {
    currentTextConfigIndex = index;
    const config = textCyclerConfigs[index];
    if (!config) return;
    
    // Show editor cards
    document.getElementById('textConfigEditor').style.display = 'block';
    document.getElementById('textLinesCard').style.display = 'block';
    document.getElementById('textAnimationCard').style.display = 'block';
    document.getElementById('textPreviewCard').style.display = 'block';
    document.getElementById('textControls').style.display = 'block';
    
    // Load values
    document.getElementById('textConfigName').value = config.name || '';
    document.getElementById('textCyclerMode').value = config.mode || 'browser';
    document.getElementById('textConfigId').value = config.configId || config.id;
    document.getElementById('textSource').value = config.textSource || '';
    document.getElementById('textLines').value = (config.textLines || []).join('\n');
    document.getElementById('textTransition').value = config.transition || 'none';
    document.getElementById('transDuration').value = config.transDuration || 500;
    document.getElementById('textDuration').value = config.cycleDuration || 3000;
    
    // Style settings
    if (config.styles) {
        // Font family - check if it's a preset or custom
        const fontFamily = config.styles.fontFamily || "'Segoe UI', system-ui, sans-serif";
        const fontSelect = document.getElementById('textFontFamily');
        const fontCustom = document.getElementById('textFontFamilyCustom');
        let isPreset = false;
        for (let opt of fontSelect.options) {
            if (opt.value === fontFamily) {
                fontSelect.value = fontFamily;
                fontCustom.value = '';
                isPreset = true;
                break;
            }
        }
        if (!isPreset) {
            fontSelect.selectedIndex = 0;
            fontCustom.value = fontFamily;
        }
        
        document.getElementById('textFontSize').value = config.styles.fontSize || '48px';
        document.getElementById('textFontWeight').value = config.styles.fontWeight || '700';
        document.getElementById('textFontStyle').value = config.styles.fontStyle || 'normal';
        document.getElementById('textColor').value = config.styles.color || '#ffffff';
        document.getElementById('textColorPicker').value = config.styles.color || '#ffffff';
        document.getElementById('textAlign').value = config.styles.align || 'center';
        document.getElementById('textLetterSpacing').value = config.styles.letterSpacing || 'normal';
        document.getElementById('textLineHeight').value = config.styles.lineHeight || '1.2';
        document.getElementById('textTransform').value = config.styles.textTransform || 'none';
        document.getElementById('textShadow').value = config.styles.shadow || '';
        document.getElementById('textStrokeWidth').value = config.styles.strokeWidth || '0';
        document.getElementById('textStrokeColor').value = config.styles.strokeColor || '#000000';
        document.getElementById('textStrokeColorPicker').value = config.styles.strokeColor || '#000000';
    }
    
    updateTextCyclerMode();
    updateTransitionMode();
    updateBrowserSourceUrlPreview();
    
    // Reset preview to show current config's first line or current cycling text
    const preview = document.getElementById('textPreview');
    if (config.isRunning && config.textLines && config.textLines.length > 0) {
        const currentIndex = config.cycleIndex || 0;
        preview.textContent = config.textLines[currentIndex] || config.textLines[0];
    } else if (config.textLines && config.textLines.length > 0) {
        preview.textContent = config.textLines[0];
    } else {
        preview.textContent = '(no text lines)';
    }
    
    // Update button states
    document.getElementById('startCycleBtn').disabled = config.isRunning;
    document.getElementById('stopCycleBtn').disabled = !config.isRunning;
    
    log('Loaded config: ' + config.name, 'info');
}

function saveCurrentTextConfig() {
    if (currentTextConfigIndex < 0) return;
    
    const config = textCyclerConfigs[currentTextConfigIndex];
    config.name = document.getElementById('textConfigName').value || 'Unnamed';
    config.mode = document.getElementById('textCyclerMode').value;
    config.configId = document.getElementById('textConfigId').value || config.id;
    config.textSource = document.getElementById('textSource').value;
    config.textLines = document.getElementById('textLines').value.split('\n').map(l => l.trim()).filter(l => l);
    config.transition = document.getElementById('textTransition').value;
    config.transDuration = parseInt(document.getElementById('transDuration').value) || 500;
    config.cycleDuration = parseInt(document.getElementById('textDuration').value) || 3000;
    config.styles = {
        fontFamily: document.getElementById('textFontFamilyCustom').value || document.getElementById('textFontFamily').value,
        fontSize: document.getElementById('textFontSize').value,
        fontWeight: document.getElementById('textFontWeight').value,
        fontStyle: document.getElementById('textFontStyle').value,
        color: document.getElementById('textColor').value,
        align: document.getElementById('textAlign').value,
        letterSpacing: document.getElementById('textLetterSpacing').value,
        lineHeight: document.getElementById('textLineHeight').value,
        textTransform: document.getElementById('textTransform').value,
        shadow: document.getElementById('textShadow').value,
        strokeWidth: document.getElementById('textStrokeWidth').value,
        strokeColor: document.getElementById('textStrokeColor').value
    };
    
    saveTextCyclerConfigs();
    renderTextCyclerConfigs();
    log('Saved config: ' + config.name, 'success');
}

function deleteCurrentTextConfig() {
    if (currentTextConfigIndex < 0) return;
    if (!confirm('Delete this config?')) return;
    
    const config = textCyclerConfigs[currentTextConfigIndex];
    if (config.isRunning) stopConfigCycling(currentTextConfigIndex);
    
    textCyclerConfigs.splice(currentTextConfigIndex, 1);
    saveTextCyclerConfigs();
    renderTextCyclerConfigs();
    
    // Hide editor
    document.getElementById('textConfigEditor').style.display = 'none';
    document.getElementById('textLinesCard').style.display = 'none';
    document.getElementById('textAnimationCard').style.display = 'none';
    document.getElementById('textStyleCard').style.display = 'none';
    document.getElementById('textPreviewCard').style.display = 'none';
    document.getElementById('textControls').style.display = 'none';
    
    currentTextConfigIndex = -1;
    log('Config deleted', 'info');
}

function saveTextCyclerConfigs() {
    storage.set('textCyclerConfigs', textCyclerConfigs);
}

function exportTextConfigs() {
    if (textCyclerConfigs.length === 0) {
        log('No configs to export', 'error');
        return;
    }
    const json = JSON.stringify(textCyclerConfigs, null, 2);
    navigator.clipboard.writeText(json).then(() => {
        log('Configs copied to clipboard!', 'success');
    }).catch(() => {
        prompt('Copy this JSON:', json);
    });
}

function importTextConfigs() {
    const json = prompt('Paste config JSON:');
    if (!json) return;
    
    try {
        const imported = JSON.parse(json);
        if (!Array.isArray(imported)) throw new Error('Must be array');
        
        const merge = textCyclerConfigs.length > 0 && confirm('Merge with existing? (Cancel to replace)');
        if (merge) {
            textCyclerConfigs = [...textCyclerConfigs, ...imported];
        } else {
            textCyclerConfigs = imported;
        }
        
        saveTextCyclerConfigs();
        renderTextCyclerConfigs();
        log(`Imported ${imported.length} configs`, 'success');
    } catch (e) {
        log('Invalid JSON: ' + e.message, 'error');
    }
}

function updateTextCyclerMode() {
    const mode = document.getElementById('textCyclerMode').value;
    const modeInfo = document.getElementById('modeInfo');
    
    document.getElementById('browserModeSettings').style.display = mode === 'browser' ? 'block' : 'none';
    document.getElementById('legacyModeSettings').style.display = mode === 'legacy' ? 'block' : 'none';
    document.getElementById('textStyleCard').style.display = mode === 'browser' ? 'block' : 'none';
    
    if (mode === 'browser') {
        modeInfo.textContent = 'Uses a Browser Source in OBS with smooth CSS animations. Create a Browser Source pointing to text_cycler_display.html';
    } else {
        modeInfo.textContent = 'Updates an existing OBS text source directly. Limited to text scramble animations.';
    }
}

function updateConfigIdPreview() {
    const configId = document.getElementById('textConfigId').value || 'config1';
    document.getElementById('configIdPreview').textContent = configId;
}

// URL preview updated via oninput attribute on textConfigId field

// Color picker sync
document.getElementById('textColorPicker')?.addEventListener('input', (e) => {
    document.getElementById('textColor').value = e.target.value;
});
document.getElementById('textColor')?.addEventListener('input', (e) => {
    const picker = document.getElementById('textColorPicker');
    if (picker && /^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
        picker.value = e.target.value;
    }
});
document.getElementById('textStrokeColorPicker')?.addEventListener('input', (e) => {
    document.getElementById('textStrokeColor').value = e.target.value;
});
document.getElementById('textStrokeColor')?.addEventListener('input', (e) => {
    const picker = document.getElementById('textStrokeColorPicker');
    if (picker && /^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
        picker.value = e.target.value;
    }
});

function getBrowserSourceUrl(configId) {
    const currentPath = window.location.pathname;
    const displayPath = currentPath.replace('control_panel.html', 'text_cycler_display.html');
    return `file://${displayPath}?id=${configId || 'config1'}`;
}

function updateBrowserSourceUrlPreview() {
    const configId = document.getElementById('textConfigId').value || 'config1';
    const preview = document.getElementById('browserSourceUrlPreview');
    if (preview) {
        preview.textContent = getBrowserSourceUrl(configId);
    }
}

function copyBrowserSourceUrl() {
    const configId = document.getElementById('textConfigId').value || 'config1';
    const url = getBrowserSourceUrl(configId);
    
    navigator.clipboard.writeText(url).then(() => {
        log('URL copied! Add as Browser Source in OBS', 'success');
    }).catch(() => {
        prompt('Copy this URL:', url);
    });
}

function updateTransitionMode() {
    const val = document.getElementById('textTransition').value;
    const info = document.getElementById('transitionInfo');
    const descriptions = {
        'none': 'Instant text change',
        'fade': 'Smooth fade in/out',
        'obfuscate': 'Minecraft enchant table scramble, reveal left-to-right',
        'typewriter': 'Type out one character at a time',
        'glitch': 'Random glitch characters that settle',
        'scramble': 'Full scramble, then snap to final',
        'wave': 'Characters appear in a wave pattern',
        'slide_left': 'Slide out left, slide in from right',
        'slide_right': 'Slide out right, slide in from left',
        'slide_up': 'Slide up transition',
        'slide_down': 'Slide down transition',
        'pop': 'Pop in with scale bounce'
    };
    info.textContent = descriptions[val] || '';
}

function updateTextSourceDropdown() {
    const select = document.getElementById('textSource');
    if (!select) return;
    
    const savedState = storage.get('ui_state') || {};
    const current = select.value || savedState.textSource || '';
    
    textSources = sources.filter(s => 
        s.inputKind && (s.inputKind.includes('text') || s.inputKind === 'text_gdiplus_v2' || s.inputKind === 'text_ft2_source_v2')
    );
    
    select.innerHTML = '<option value="">-- Select Text Source --</option>' +
        textSources.map(s => `<option value="${s.sourceName}">${s.sourceName}</option>`).join('');
    
    if (current && textSources.find(s => s.sourceName === current)) {
        select.value = current;
    }
}

async function loadTextSource() {
    const name = document.getElementById('textSource').value;
    if (!name) {
        document.getElementById('textPreview').textContent = 'Select a source';
        return;
    }
    
    try {
        const data = await request('GetInputSettings', { inputName: name });
        const text = data.inputSettings.text || '';
        document.getElementById('textPreview').textContent = text || '(empty)';
    } catch (e) {
        log('Error loading text: ' + e, 'error');
    }
}

// ============ Text Cycler Engine ============

function getOrCreateChannel(configId) {
    if (!textChannels[configId]) {
        try {
            textChannels[configId] = new BroadcastChannel('text_cycler_' + configId);
        } catch (e) {
            console.warn('BroadcastChannel not supported');
        }
    }
    return textChannels[configId];
}

function sendToDisplay(configId, message) {
    // BroadcastChannel
    const channel = getOrCreateChannel(configId);
    if (channel) {
        channel.postMessage(message);
    }
    
    // LocalStorage fallback
    localStorage.setItem('text_cycler_msg_' + configId, JSON.stringify(message));
}

function startTextCycler() {
    saveCurrentTextConfig(); // Save first
    
    if (currentTextConfigIndex < 0) return;
    const config = textCyclerConfigs[currentTextConfigIndex];
    
    if (!config.textLines || config.textLines.length === 0) {
        log('Enter at least one text line', 'error');
        return;
    }
    
    if (config.mode === 'legacy' && !config.textSource) {
        log('Select a text source first', 'error');
        return;
    }
    
    if (config.mode === 'legacy' && !connected) {
        log('Connect to OBS first for legacy mode', 'error');
        showPage('setup');
        return;
    }
    
    startConfigCycling(currentTextConfigIndex);
}

function startConfigCycling(index) {
    const config = textCyclerConfigs[index];
    if (!config) return;
    
    // Stop if already running
    if (config.isRunning) {
        stopConfigCycling(index);
    }
    
    config.isRunning = true;
    config.cycleIndex = 0;
    
    // Send styles first (browser mode only)
    if (config.mode === 'browser' && config.styles) {
        sendToDisplay(config.configId, {
            type: 'style',
            styles: config.styles
        });
    }
    
    // Send initial text
    showConfigText(index, config.textLines[0]);
    
    // Start interval
    config.intervalId = setInterval(() => {
        config.cycleIndex = (config.cycleIndex + 1) % config.textLines.length;
        showConfigText(index, config.textLines[config.cycleIndex]);
    }, config.cycleDuration);
    
    saveTextCyclerConfigs();
    renderTextCyclerConfigs();
    
    // Update UI if this is current config
    if (index === currentTextConfigIndex) {
        document.getElementById('startCycleBtn').disabled = true;
        document.getElementById('stopCycleBtn').disabled = false;
    }
    
    log(`Started: ${config.name} (${config.textLines.length} lines)`, 'success');
}

function showConfigText(index, text) {
    const config = textCyclerConfigs[index];
    if (!config) return;
    
    if (config.mode === 'browser') {
        // Send to browser source
        sendToDisplay(config.configId, {
            type: 'show',
            text: text,
            transition: config.transition,
            duration: config.transDuration
        });
        
        // Only update preview if this is the currently selected config
        if (index === currentTextConfigIndex) {
            document.getElementById('textPreview').textContent = text;
        }
    } else {
        // Legacy: update OBS text source directly
        showTextWithTransitionLegacy(text, config, index);
    }
}

function showTextWithTransitionLegacy(targetText, config, configIndex) {
    const transition = config.transition;
    const transDuration = config.transDuration || 500;
    
    if (transitionInterval) {
        clearInterval(transitionInterval);
        transitionInterval = null;
    }
    
    if (transition === 'none') {
        setTextFast(targetText, config.textSource, configIndex);
        return;
    }
    
    const STEP_MS = 100;
    const totalSteps = Math.max(Math.floor(transDuration / STEP_MS), 1);
    let currentStep = 0;
    
    function doStep() {
        currentStep++;
        const progress = currentStep / totalSteps;
        
        let displayText = targetText;
        
        if (transition === 'typewriter') {
            const chars = Math.ceil(progress * targetText.length);
            displayText = targetText.substring(0, chars);
        } else if (transition === 'glitch' || transition === 'obfuscate') {
            if (progress < 0.6) {
                displayText = scrambleTextLegacy(targetText);
            } else {
                displayText = revealTextLegacy(targetText, (progress - 0.6) / 0.4);
            }
        } else if (transition === 'scramble') {
            if (progress < 0.9) {
                displayText = scrambleTextLegacy(targetText);
            }
        } else if (transition === 'wave') {
            displayText = waveTextLegacy(targetText, progress);
        }
        
        setTextFast(displayText, config.textSource, configIndex);
        
        if (currentStep >= totalSteps) {
            clearInterval(transitionInterval);
            transitionInterval = null;
            setTextFast(targetText, config.textSource, configIndex);
        }
    }
    
    doStep();
    if (totalSteps > 1) {
        transitionInterval = setInterval(doStep, STEP_MS);
    }
}

let lastTextSend = 0;
const MIN_TEXT_INTERVAL = 80;

function setTextFast(text, sourceName, configIndex) {
    if (!sourceName || !connected || !ws || ws.readyState !== WebSocket.OPEN) return;
    
    const now = Date.now();
    if (now - lastTextSend < MIN_TEXT_INTERVAL) {
        // Only update preview if this is the currently selected config
        if (configIndex === currentTextConfigIndex) {
            document.getElementById('textPreview').textContent = text;
        }
        return;
    }
    lastTextSend = now;
    
    ws.send(JSON.stringify({
        op: 6,
        d: {
            requestType: 'SetInputSettings',
            requestId: 'txt_' + (msgId++),
            requestData: {
                inputName: sourceName,
                inputSettings: { text: text }
            }
        }
    }));
    
    // Only update preview if this is the currently selected config
    if (configIndex === currentTextConfigIndex) {
        document.getElementById('textPreview').textContent = text;
    }
}

function scrambleTextLegacy(text) {
    const chars = '#$%&*@!?+=~<>[]{}';
    return text.split('').map(c => c === ' ' ? ' ' : chars[Math.floor(Math.random() * chars.length)]).join('');
}

function revealTextLegacy(target, progress) {
    const chars = '#$%&*@!?+=~<>[]{}';
    const revealed = Math.ceil(progress * target.length);
    return target.split('').map((c, i) => i < revealed ? c : (c === ' ' ? ' ' : chars[Math.floor(Math.random() * chars.length)])).join('');
}

function waveTextLegacy(target, progress) {
    const waveWidth = 3;
    const center = progress * (target.length + waveWidth);
    return target.split('').map((c, i) => {
        if (Math.abs(i - center) < waveWidth && c !== ' ') return CHARS_ENCHANT[Math.floor(Math.random() * CHARS_ENCHANT.length)];
        if (i < center - waveWidth) return c;
        return ' ';
    }).join('');
}

function stopTextCycler() {
    if (currentTextConfigIndex >= 0) {
        stopConfigCycling(currentTextConfigIndex);
    }
}

function stopConfigCycling(index) {
    const config = textCyclerConfigs[index];
    if (!config) return;
    
    if (config.intervalId) {
        clearInterval(config.intervalId);
        config.intervalId = null;
    }
    
    config.isRunning = false;
    saveTextCyclerConfigs();
    renderTextCyclerConfigs();
    
    if (index === currentTextConfigIndex) {
        document.getElementById('startCycleBtn').disabled = false;
        document.getElementById('stopCycleBtn').disabled = true;
    }
    
    log(`Stopped: ${config.name}`, 'info');
}

function quickStartConfig(index) {
    const config = textCyclerConfigs[index];
    if (!config) return;
    
    if (config.isRunning) {
        stopConfigCycling(index);
    } else {
        startConfigCycling(index);
    }
}

// Restore running configs on load
function restoreRunningTextCyclers() {
    textCyclerConfigs.forEach((config, index) => {
        if (config.isRunning) {
            // Reset running state and restart
            config.isRunning = false;
            startConfigCycling(index);
        }
    });
}


// ============ Twitch Clips Player (Multi-Config) ============
let clipsConfigs = []; // Loaded async from storage on init
let currentClipsConfigIndex = -1;

// Twitch Client ID for clips player (from teklynk)
const CLIPS_CLIENT_ID = 'cuql1zod4eeabjr3cnc6adjn9ezro4';

function renderClipsConfigs() {
    const container = document.getElementById('clipsConfigs');
    if (clipsConfigs.length === 0) {
        container.innerHTML = '<div class="empty-state">No clip player configs. Click "New Config" to create one.</div>';
        return;
    }
    
    container.innerHTML = clipsConfigs.map((c, i) => `
        <div class="source-item" style="cursor:pointer" onclick="loadClipsConfig(${i})">
            <div>
                <div class="name">${c.name || 'Unnamed'}</div>
                <div class="type">
                    ${c.showFollowing ? 'üë• Following' : `üì∫ ${(c.channels || '').split(',').length} channels`}
                    ‚Ä¢ ${c.limit || 20} clips
                    ${c.command ? `‚Ä¢ !${c.command}` : '‚Ä¢ Auto-play'}
                </div>
            </div>
            <div style="display:flex;gap:4px">
                <button onclick="event.stopPropagation(); testClipsConfigUrl(${i})" title="Test">‚ñ∂</button>
            </div>
        </div>
    `).join('');
}

function newClipsConfig() {
    const config = {
        id: 'clips_' + Date.now(),
        name: 'Clips Player ' + (clipsConfigs.length + 1),
        mainChannel: '',
        channels: '',
        showFollowing: false,
        exclude: '',
        limit: 20,
        dateRange: 0,
        preferFeatured: false,
        showText: true,
        customText: '',
        showDetails: true,
        detailsText: '{title}\nWhile streaming {game}\nClipped by {creator_name} {created_at}',
        theme: 2,
        command: '',
        accessToken: ''
    };
    
    clipsConfigs.push(config);
    saveClipsConfigs();
    renderClipsConfigs();
    loadClipsConfig(clipsConfigs.length - 1);
    log('Created new clips config', 'success');
}

function loadClipsConfig(index) {
    currentClipsConfigIndex = index;
    const config = clipsConfigs[index];
    if (!config) return;
    
    // Show all editor cards
    document.getElementById('clipsConfigEditor').style.display = 'block';
    document.getElementById('clipsSettingsCard').style.display = 'block';
    document.getElementById('clipsDisplayCard').style.display = 'block';
    document.getElementById('clipsChatCard').style.display = 'block';
    document.getElementById('clipsAuthCard').style.display = 'block';
    document.getElementById('clipsPreviewCard').style.display = 'block';
    document.getElementById('clipsControls').style.display = 'block';
    
    // Populate values
    document.getElementById('clipsConfigName').value = config.name || '';
    document.getElementById('clipsMainChannel').value = config.mainChannel || '';
    document.getElementById('clipsChannels').value = config.channels || '';
    document.getElementById('clipsShowFollowing').checked = config.showFollowing || false;
    document.getElementById('clipsExclude').value = config.exclude || '';
    document.getElementById('clipsLimit').value = config.limit || 20;
    document.getElementById('clipsDateRange').value = config.dateRange || 0;
    document.getElementById('clipsPreferFeatured').checked = config.preferFeatured || false;
    document.getElementById('clipsShowText').checked = config.showText !== false;
    document.getElementById('clipsCustomText').value = config.customText || '';
    document.getElementById('clipsShowDetails').checked = config.showDetails !== false;
    document.getElementById('clipsDetailsText').value = config.detailsText || '';
    document.getElementById('clipsTheme').value = config.theme || 2;
    document.getElementById('clipsCommand').value = config.command || '';
    document.getElementById('clipsAccessToken').value = config.accessToken || '';
    
    updateClipsRangeValues();
    updateClipsUIVisibility();
    generateClipsUrl();
    
    log('Loaded clips config: ' + config.name, 'info');
}

function updateClipsRangeValues() {
    const limit = document.getElementById('clipsLimit').value;
    const dateRange = document.getElementById('clipsDateRange').value;
    document.getElementById('clipsLimitValue').textContent = limit;
    document.getElementById('clipsDateRangeValue').textContent = dateRange == 0 ? '0 (all)' : dateRange;
}

function updateClipsUIVisibility() {
    const showFollowing = document.getElementById('clipsShowFollowing').checked;
    const showText = document.getElementById('clipsShowText').checked;
    const showDetails = document.getElementById('clipsShowDetails').checked;
    
    document.getElementById('clipsExcludeSection').style.display = showFollowing ? 'block' : 'none';
    document.getElementById('clipsCustomTextSection').style.display = showText ? 'block' : 'none';
    document.getElementById('clipsDetailsSection').style.display = showDetails ? 'block' : 'none';
    
    // Disable channels if showFollowing
    document.getElementById('clipsChannels').disabled = showFollowing;
}

// Event listeners for range sliders
document.getElementById('clipsLimit')?.addEventListener('input', updateClipsRangeValues);
document.getElementById('clipsDateRange')?.addEventListener('input', updateClipsRangeValues);
document.getElementById('clipsShowFollowing')?.addEventListener('change', updateClipsUIVisibility);
document.getElementById('clipsShowText')?.addEventListener('change', updateClipsUIVisibility);
document.getElementById('clipsShowDetails')?.addEventListener('change', updateClipsUIVisibility);

function saveCurrentClipsConfig() {
    if (currentClipsConfigIndex < 0) return;
    
    const config = clipsConfigs[currentClipsConfigIndex];
    config.name = document.getElementById('clipsConfigName').value || 'Unnamed';
    config.mainChannel = document.getElementById('clipsMainChannel').value.trim();
    config.channels = document.getElementById('clipsChannels').value.trim();
    config.showFollowing = document.getElementById('clipsShowFollowing').checked;
    config.exclude = document.getElementById('clipsExclude').value.trim();
    config.limit = parseInt(document.getElementById('clipsLimit').value) || 20;
    config.dateRange = parseInt(document.getElementById('clipsDateRange').value) || 0;
    config.preferFeatured = document.getElementById('clipsPreferFeatured').checked;
    config.showText = document.getElementById('clipsShowText').checked;
    config.customText = document.getElementById('clipsCustomText').value.trim();
    config.showDetails = document.getElementById('clipsShowDetails').checked;
    config.detailsText = document.getElementById('clipsDetailsText').value.trim();
    config.theme = document.getElementById('clipsTheme').value;
    config.command = document.getElementById('clipsCommand').value.trim().replace('!', '');
    config.accessToken = document.getElementById('clipsAccessToken').value.trim();
    
    saveClipsConfigs();
    renderClipsConfigs();
    generateClipsUrl();
    log('Saved clips config: ' + config.name, 'success');
}

function deleteCurrentClipsConfig() {
    if (currentClipsConfigIndex < 0) return;
    if (!confirm('Delete this clips config?')) return;
    
    clipsConfigs.splice(currentClipsConfigIndex, 1);
    saveClipsConfigs();
    renderClipsConfigs();
    
    // Hide editor
    document.getElementById('clipsConfigEditor').style.display = 'none';
    document.getElementById('clipsSettingsCard').style.display = 'none';
    document.getElementById('clipsDisplayCard').style.display = 'none';
    document.getElementById('clipsChatCard').style.display = 'none';
    document.getElementById('clipsAuthCard').style.display = 'none';
    document.getElementById('clipsPreviewCard').style.display = 'none';
    document.getElementById('clipsControls').style.display = 'none';
    
    currentClipsConfigIndex = -1;
    log('Clips config deleted', 'info');
}

function saveClipsConfigs() {
    storage.set('clipsConfigs', clipsConfigs);
}

function exportClipsConfigs() {
    if (clipsConfigs.length === 0) {
        log('No clips configs to export', 'error');
        return;
    }
    
    // Remove access tokens for security
    const exportData = clipsConfigs.map(c => ({...c, accessToken: ''}));
    const json = JSON.stringify(exportData, null, 2);
    
    navigator.clipboard.writeText(json).then(() => {
        log('Clips configs copied to clipboard (tokens excluded)', 'success');
    }).catch(() => {
        prompt('Copy this JSON:', json);
    });
}

function importClipsConfigs() {
    const json = prompt('Paste clips config JSON:');
    if (!json) return;
    
    try {
        const imported = JSON.parse(json);
        if (!Array.isArray(imported)) throw new Error('Must be array');
        
        const merge = clipsConfigs.length > 0 && confirm('Merge with existing? (Cancel to replace)');
        if (merge) {
            clipsConfigs = [...clipsConfigs, ...imported];
        } else {
            clipsConfigs = imported;
        }
        
        saveClipsConfigs();
        renderClipsConfigs();
        log(`Imported ${imported.length} clips configs`, 'success');
    } catch (e) {
        log('Invalid JSON: ' + e.message, 'error');
    }
}

function generateClipsUrl() {
    if (currentClipsConfigIndex < 0) return;
    
    const config = clipsConfigs[currentClipsConfigIndex];
    
    // Validation
    if (!config.mainChannel) {
        document.getElementById('clipsGeneratedUrl').value = 'Set Main Twitch Channel first';
        return;
    }
    
    if (!config.channels && !config.showFollowing) {
        document.getElementById('clipsGeneratedUrl').value = 'Set channels or enable Show Following';
        return;
    }
    
    // Build URL
    const basePath = window.location.pathname.replace('control_panel.html', 'twitch_clips_player/clips.html');
    const baseUrl = window.location.protocol + '//' + window.location.host + basePath;
    
    const params = new URLSearchParams();
    
    if (!config.showFollowing) {
        params.set('channel', config.channels.replace(/\s+/g, ''));
    }
    params.set('mainAccount', config.mainChannel);
    params.set('limit', config.limit || 20);
    params.set('dateRange', config.dateRange || 0);
    params.set('themeOption', config.theme || 0);
    params.set('preferFeatured', config.preferFeatured);
    params.set('showText', config.showText);
    params.set('showDetails', config.showDetails);
    params.set('showFollowing', config.showFollowing);
    
    if (config.customText) {
        params.set('customText', config.customText);
    }
    if (config.detailsText) {
        params.set('detailsText', config.detailsText);
    }
    if (config.command) {
        params.set('command', config.command);
    }
    if (config.exclude) {
        params.set('exclude', config.exclude.replace(/\s+/g, ''));
    }
    if (config.accessToken) {
        params.set('ref', btoa(config.accessToken));
        params.set('clientId', btoa(CLIPS_CLIENT_ID));
    }
    
    const fullUrl = baseUrl + '?' + params.toString();
    document.getElementById('clipsGeneratedUrl').value = fullUrl;
    
    return fullUrl;
}

function copyClipsUrl() {
    const url = document.getElementById('clipsGeneratedUrl').value;
    if (!url || url.includes('Set ')) {
        log('Generate a valid URL first', 'error');
        return;
    }
    
    navigator.clipboard.writeText(url).then(() => {
        log('URL copied! Add as Browser Source in OBS', 'success');
    }).catch(() => {
        prompt('Copy this URL:', url);
    });
}

// Detect if running in OBS dock (embedded CEF browser)
function isOBSDock() {
    // OBS docks have limited capabilities:
    // 1. window.open usually fails or returns null
    // 2. File downloads don't work properly
    // 3. Some APIs are restricted
    // We detect by checking the URL protocol and user agent hints
    const isFileProtocol = window.location.protocol === 'file:';
    const isEmbedded = !window.opener && window.parent === window;
    
    // If loaded via file:// and appears embedded, likely OBS dock
    return isFileProtocol && isEmbedded;
}

// Update UI based on dock context
function updateDockContextUI() {
    const isDock = isOBSDock();
    const downloadBtn = document.getElementById('downloadScriptBtn');
    const dockWarning = document.getElementById('dockDownloadWarning');
    const browserInstructions = document.getElementById('browserInstructions');
    const dockInstructions = document.getElementById('dockInstructions');
    
    if (downloadBtn) {
        if (isDock) {
            downloadBtn.classList.add('btn-warning');
            downloadBtn.classList.remove('btn-primary');
            downloadBtn.title = 'May not work in OBS dock - use Copy instead';
        } else {
            downloadBtn.classList.add('btn-primary');
            downloadBtn.classList.remove('btn-warning');
            downloadBtn.title = 'Download install script';
        }
    }
    
    if (dockWarning) dockWarning.style.display = isDock ? 'block' : 'none';
    if (browserInstructions) browserInstructions.style.display = isDock ? 'none' : 'block';
    if (dockInstructions) dockInstructions.style.display = isDock ? 'block' : 'none';
}

// Helper for opening URLs - handles OBS dock limitations
function openUrlOrCopy(url, description = 'URL') {
    // Try to open in new window/tab
    const win = window.open(url, '_blank');
    
    // If failed (OBS dock), copy to clipboard instead
    if (!win || win.closed || typeof win.closed === 'undefined') {
        navigator.clipboard.writeText(url).then(() => {
            log(description + ' copied to clipboard! OBS docks cannot open external windows.', 'info');
        }).catch(() => {
            prompt('Copy this URL:', url);
        });
        return false;
    }
    return true;
}

function testClipsPlayer() {
    const url = generateClipsUrl();
    if (!url || url.includes('Set ')) {
        log('Configure the settings first', 'error');
        return;
    }
    // For local file URLs, just copy - user should add as browser source
    navigator.clipboard.writeText(url).then(() => {
        log('Browser source URL copied! Add it as a Browser Source in OBS to test.', 'success');
    }).catch(() => {
        prompt('Copy this Browser Source URL:', url);
    });
}

function testClipsConfigUrl(index) {
    const config = clipsConfigs[index];
    if (!config) return;
    
    // Temporarily load this config to generate URL
    const savedIndex = currentClipsConfigIndex;
    currentClipsConfigIndex = index;
    const url = generateClipsUrl();
    currentClipsConfigIndex = savedIndex;
    
    if (url && !url.includes('Set ')) {
        navigator.clipboard.writeText(url).then(() => {
            log('Config URL copied! Add as Browser Source in OBS to test.', 'success');
        }).catch(() => {
            prompt('Copy this Browser Source URL:', url);
        });
    } else {
        log('Configure the clips config first', 'error');
    }
}

function toggleClipsTokenVisibility() {
    const input = document.getElementById('clipsAccessToken');
    input.type = input.type === 'password' ? 'text' : 'password';
}

// Twitch auth URL (OBS dock compatible)
const TWITCH_AUTH_URL = 'https://id.twitch.tv/oauth2/authorize?response_type=token&client_id=cuql1zod4eeabjr3cnc6adjn9ezro4&redirect_uri=https://twitch-clips-player.pages.dev&scope=chat:read+chat:edit+user:read:follows+moderator:read:followers&force_verify=true';

function openTwitchAuth() {
    // Try to open - this works in regular browsers but not OBS docks
    const win = window.open(TWITCH_AUTH_URL, '_blank');
    
    // If it failed or we're in OBS dock, copy to clipboard instead
    if (!win || win.closed || typeof win.closed === 'undefined') {
        copyTwitchAuthUrl();
    }
}

function copyTwitchAuthUrl() {
    navigator.clipboard.writeText(TWITCH_AUTH_URL).then(() => {
        // Show the hint about OBS dock limitation
        const hint = document.getElementById('twitchAuthHint');
        if (hint) {
            hint.style.display = 'block';
            // Auto-hide after 10 seconds
            setTimeout(() => { hint.style.display = 'none'; }, 10000);
        }
        log('Auth URL copied to clipboard! Paste in your browser.', 'success');
    }).catch(err => {
        log('Failed to copy: ' + err, 'error');
        // Fallback: show the URL in a prompt for manual copy
        prompt('Copy this URL and paste in your browser:', TWITCH_AUTH_URL);
    });
}

// Initialize on page load
function initClipsPlayer() {
    renderClipsConfigs();
}


// ============ Script Manager & Installer ============

// Script status tracking - which scripts are detected as installed
const scriptStatus = {
    initialized: false,
    connected: false,  // Whether we've successfully connected to OBS
    scripts: {},       // { scriptId: { installed: bool, version: string|null } }
    features: {        // Which features are available based on scripts
        sources: false,
        swap: false,
        text: false,
        animations: false
    }
};

// Map scripts to features they enable
const SCRIPT_FEATURE_MAP = {
    'source_animations': ['sources', 'animations'],
    'source_swap': ['swap'],
    'text_cycler': ['text'],
    'quick_controls': [],  // Utility script, no UI features
    'script_manager': []   // Meta script, no UI features
};

// Initialize script status from OBS connection
async function checkScriptStatus() {
    scriptStatus.initialized = true;
    
    // Use the global 'connected' variable which is the source of truth
    if (!connected) {
        scriptStatus.connected = false;
        updateFeatureAvailability();
        renderStartupBanner();
        return;
    }
    
    // We're connected!
    scriptStatus.connected = true;
    
    // Try to verify OBS version (optional - won't block if fails)
    try {
        const version = await sendRequest('GetVersion');
        if (version && version.obsVersion) {
            log('OBS ' + version.obsVersion + ' - All features enabled', 'success');
        }
    } catch (err) {
        // Non-critical - we're still connected
        console.warn('Version check failed:', err);
    }
    
    updateFeatureAvailability();
    renderStartupBanner();
}

// Try to detect which scripts are installed by checking OBS state
// Mark all scripts as available when connected
// (We can't reliably detect individual Lua scripts from WebSocket)
function markScriptsAsAvailable() {
    AVAILABLE_SCRIPTS.forEach(script => {
        scriptStatus.scripts[script.id] = { installed: true, version: script.version };
    });
}

// Update which features are available based on detected scripts
function updateFeatureAvailability() {
    // Simple logic: if connected, all features are available
    // We can't reliably detect individual Lua scripts from WebSocket
    const allEnabled = scriptStatus.connected;
    
    Object.keys(scriptStatus.features).forEach(f => {
        scriptStatus.features[f] = allEnabled;
    });
    
    // Also mark scripts as available when connected
    if (allEnabled) {
        markScriptsAsAvailable();
    }
    
    updateTabStates();
    updateDashboardStatus();
}

// Update tab visual states based on feature availability
function updateTabStates() {
    const tabs = document.querySelectorAll('.tab');
    const tabFeatures = {
        1: 'sources',   // Sources tab (index 1)
        2: 'text',      // Text tab (index 2)
        4: 'swap'       // Swaps tab (index 4)
    };
    
    tabs.forEach((tab, index) => {
        const feature = tabFeatures[index];
        if (feature && !scriptStatus.connected) {
            tab.classList.add('disabled');
            tab.title = 'Connect to OBS first';
        } else {
            tab.classList.remove('disabled');
        }
    });
    
    // Update dashboard status card
    updateDashboardStatus();
}

// Update the dashboard status card
function updateDashboardStatus() {
    const container = document.getElementById('dashboardScriptStatus');
    if (!container) return;
    
    if (scriptStatus.connected) {
        // Connected - show all features as available
        container.innerHTML = `
            <div class="script-status-grid">
                <div class="script-status-item installed">
                    <span class="script-status-item__icon">üîå</span>
                    <span class="script-status-item__name">OBS Connection</span>
                    <span class="script-status-item__badge">Online</span>
                </div>
                <div class="script-status-item installed">
                    <span class="script-status-item__icon">‚ú®</span>
                    <span class="script-status-item__name">Animations</span>
                    <span class="script-status-item__badge">Ready</span>
                </div>
                <div class="script-status-item installed">
                    <span class="script-status-item__icon">üîÑ</span>
                    <span class="script-status-item__name">Source Swap</span>
                    <span class="script-status-item__badge">Ready</span>
                </div>
                <div class="script-status-item installed">
                    <span class="script-status-item__icon">üìù</span>
                    <span class="script-status-item__name">Text Cycler</span>
                    <span class="script-status-item__badge">Ready</span>
                </div>
            </div>
            <p class="hint" style="margin-top:8px">
                ‚úÖ All features available! Use the tabs above to access each feature.
            </p>
        `;
    } else {
        // Not connected - show warning
        container.innerHTML = `
            <div class="script-status-grid">
                <div class="script-status-item missing">
                    <span class="script-status-item__icon">üîå</span>
                    <span class="script-status-item__name">OBS Connection</span>
                    <span class="script-status-item__badge">Offline</span>
                </div>
            </div>
            <p class="hint" style="margin-top:8px">
                <button onclick="showPage('setup')" class="btn-link">‚öôÔ∏è Go to Setup</button> to connect to OBS WebSocket
            </p>
            <p class="hint" style="margin-top:4px">
                <button onclick="showPage('install')" class="btn-link">üì• Install Scripts</button> if you haven't already
            </p>
        `;
    }
}

// Render startup banner based on current state
function renderStartupBanner() {
    // Remove existing banner
    const existingBanner = document.getElementById('startupBanner');
    if (existingBanner) existingBanner.remove();
    
    // Determine banner state
    let bannerHTML = '';
    
    if (!scriptStatus.connected) {
        bannerHTML = `
            <div id="startupBanner" class="startup-banner">
                <span class="startup-banner__icon">üîå</span>
                <div class="startup-banner__content">
                    <div class="startup-banner__title">Not Connected to OBS</div>
                    <div class="startup-banner__text">Connect to OBS WebSocket to enable all features. Some features require Lua scripts to be installed.</div>
                </div>
                <button class="startup-banner__action" onclick="showPage('setup')">‚öôÔ∏è Setup</button>
            </div>
        `;
    } else {
        // Connected - show success briefly then fade
        bannerHTML = `
            <div id="startupBanner" class="startup-banner success">
                <span class="startup-banner__icon">‚úÖ</span>
                <div class="startup-banner__content">
                    <div class="startup-banner__title">Connected to OBS</div>
                    <div class="startup-banner__text">All features are available. Scripts detected and ready.</div>
                </div>
            </div>
        `;
    }
    
    // Insert banner at top of content area
    const content = document.querySelector('.content');
    if (content && bannerHTML) {
        content.insertAdjacentHTML('afterbegin', bannerHTML);
        
        // Auto-hide success banner after 5 seconds
        if (scriptStatus.connected) {
            setTimeout(() => {
                const banner = document.getElementById('startupBanner');
                if (banner) {
                    banner.style.transition = 'opacity 0.3s, height 0.3s, margin 0.3s, padding 0.3s';
                    banner.style.opacity = '0';
                    banner.style.height = '0';
                    banner.style.margin = '0';
                    banner.style.padding = '0';
                    banner.style.overflow = 'hidden';
                    setTimeout(() => banner.remove(), 300);
                }
            }, 5000);
        }
    }
}

// Render feature notice for a specific page
function renderFeatureNotice(containerId, featureId, scriptName) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Remove existing notice
    const existing = container.querySelector('.feature-notice');
    if (existing) existing.remove();
    
    if (!scriptStatus.connected) {
        const notice = document.createElement('div');
        notice.className = 'feature-notice error';
        notice.innerHTML = `
            <div class="feature-notice__title">‚ö†Ô∏è Connection Required</div>
            <div class="feature-notice__text">
                Connect to OBS WebSocket to use this feature. 
                <button onclick="showPage('setup')" class="btn-link">Go to Setup ‚Üí</button>
            </div>
        `;
        container.insertBefore(notice, container.firstChild);
    } else if (!scriptStatus.features[featureId]) {
        const notice = document.createElement('div');
        notice.className = 'feature-notice';
        notice.innerHTML = `
            <div class="feature-notice__title">üìú Script Required: ${scriptName}</div>
            <div class="feature-notice__text">
                This feature requires the ${scriptName} Lua script. 
                <button onclick="showPage('install')" class="btn-link">Go to Installer ‚Üí</button>
            </div>
        `;
        container.insertBefore(notice, container.firstChild);
    }
}

// Script definitions
const AVAILABLE_SCRIPTS = [
    {
        id: 'source_animations',
        name: 'Source Animations',
        file: 'source_animations.lua',
        version: '2.7.0',
        icon: '‚ú®',
        description: 'Animates sources when visibility is toggled. Supports fade, slide, zoom, and pop animations with customizable easing.',
        features: ['Fade In/Out', 'Slide animations', 'Zoom effects', 'Pop animations', 'Per-source config', 'No flicker!']
    },
    {
        id: 'source_swap',
        name: 'Source Swap',
        file: 'source_swap.lua',
        version: '3.1.0',
        icon: 'üîÑ',
        description: 'Smoothly swap position and size of two sources with animation. Supports multiple swap configs with hotkeys.',
        features: ['Animated swaps', 'Multiple configs', 'Hotkey support', 'Aspect ratio control', 'Works with groups']
    },
    {
        id: 'text_cycler',
        name: 'Text Cycler',
        file: 'text_cycler.lua',
        version: '1.0.0',
        icon: 'üìù',
        description: 'Cycles through text strings with optional transition animations like obfuscate, typewriter, and glitch effects.',
        features: ['Text cycling', 'Obfuscate effect', 'Typewriter effect', 'Glitch effect', 'Hotkey support']
    },
    {
        id: 'quick_controls',
        name: 'Quick Controls',
        file: 'quick_controls.lua',
        version: '1.0.0',
        icon: '‚ö°',
        description: 'Hotkey to cycle aspect ratio override mode for source swaps.',
        features: ['Aspect cycle hotkey', 'Quick access']
    },
    {
        id: 'script_manager',
        name: 'Script Manager',
        file: 'script_manager.lua',
        version: '1.0.0',
        icon: 'üìã',
        description: 'Unified dashboard to manage and configure all animation scripts in OBS.',
        features: ['Script overview', 'Enable/disable scripts', 'Status at a glance']
    }
];

// Installer state
let installerState = {
    sourcePath: '',
    targetPath: '',
    selectedScripts: [],
    existingFiles: [],
    installAction: 'replace', // 'skip', 'backup', 'replace'
    generatedScript: ''
};

function initScriptsAndInstaller() {
    renderScriptsList();
    detectSourcePath();
    detectOBSPath();
    
    // Set initial dock context UI (for step 4 if user navigates there)
    updateDockContextUI();
}

function renderScriptsList() {
    const container = document.getElementById('scriptsList');
    if (!container) return;
    
    container.innerHTML = AVAILABLE_SCRIPTS.map(script => `
        <div class="script-card">
            <div class="script-header">
                <span class="script-icon">${script.icon}</span>
                <div>
                    <div class="script-name">${script.name}</div>
                    <div class="script-version">v${script.version}</div>
                </div>
            </div>
            <p class="script-desc">${script.description}</p>
            <div class="script-file">${script.file}</div>
        </div>
    `).join('');
}

function detectSourcePath() {
    // Get current page URL and extract folder path
    const url = window.location.href;
    let path = '';
    
    if (url.startsWith('file:///')) {
        path = url.replace('file:///', '').replace(/\//g, '\\');
        path = path.substring(0, path.lastIndexOf('\\'));
        path = decodeURIComponent(path);
    } else {
        path = '(Run from local file to detect)';
    }
    
    installerState.sourcePath = path;
    const input = document.getElementById('installSourcePath');
    if (input) input.value = path;
}

function detectOBSPath() {
    // Common OBS paths for different OS
    const suggestions = [];
    
    // Detect OS from user agent
    const ua = navigator.userAgent.toLowerCase();
    
    if (ua.includes('win')) {
        // Windows paths
        const username = installerState.sourcePath.match(/Users\\([^\\]+)/)?.[1] || 'USERNAME';
        suggestions.push(
            `C:\\Users\\${username}\\AppData\\Roaming\\obs-studio\\basic\\scripts`,
            `C:\\Program Files\\obs-studio\\data\\obs-plugins\\frontend-tools\\scripts`,
            `C:\\ProgramData\\obs-studio\\basic\\scripts`
        );
    } else if (ua.includes('mac')) {
        // macOS paths
        suggestions.push(
            '~/Library/Application Support/obs-studio/basic/scripts',
            '/Applications/OBS.app/Contents/Resources/data/obs-plugins/frontend-tools/scripts'
        );
    } else {
        // Linux paths
        suggestions.push(
            '~/.config/obs-studio/basic/scripts',
            '/usr/share/obs/obs-plugins/frontend-tools/scripts'
        );
    }
    
    // Render suggestions
    const container = document.getElementById('pathSuggestions');
    if (container) {
        container.innerHTML = suggestions.map(path => 
            `<span class="path-suggestion" onclick="setTargetPath('${path.replace(/\\/g, '\\\\')}')">${path}</span>`
        ).join('');
    }
    
    // Set first suggestion as default
    if (!installerState.targetPath && suggestions.length > 0) {
        setTargetPath(suggestions[0]);
    }
}

function setTargetPath(path) {
    installerState.targetPath = path;
    const input = document.getElementById('installTargetPath');
    if (input) input.value = path;
}

function browseTargetPath() {
    // Can't actually browse in browser, but show instructions
    const path = prompt('Enter the full path to your OBS scripts folder:', installerState.targetPath);
    if (path) {
        setTargetPath(path);
    }
}


function goToInstallStep(step) {
    // Hide all steps
    document.querySelectorAll('.install-step').forEach(s => s.classList.remove('active'));
    
    // Show target step
    const stepEl = document.getElementById('installStep' + step);
    if (stepEl) stepEl.classList.add('active');
    
    // Step-specific logic
    if (step === 2) {
        renderInstallScriptsList();
    } else if (step === 3) {
        renderInstallReview();
    } else if (step === 4) {
        // Update UI based on dock vs browser context
        updateDockContextUI();
    }
}

function renderInstallScriptsList() {
    const container = document.getElementById('installScriptsList');
    if (!container) return;
    
    // Check for existing files (simulated - in real scenario would need backend)
    // For now, we'll show all as "new" and let user indicate if they exist
    
    container.innerHTML = AVAILABLE_SCRIPTS.map(script => {
        const isSelected = installerState.selectedScripts.includes(script.id);
        const existsInTarget = installerState.existingFiles.includes(script.file);
        
        let statusTag = '<span class="script-status-tag new">New</span>';
        if (existsInTarget) {
            statusTag = '<span class="script-status-tag exists">Exists</span>';
        }
        
        return `
            <div class="install-script-item">
                <input type="checkbox" id="install_${script.id}" 
                       ${isSelected ? 'checked' : ''} 
                       onchange="toggleScriptSelection('${script.id}')">
                <div class="script-info">
                    <div class="script-name">${script.icon} ${script.name}</div>
                    <div style="font-size:0.8em;color:var(--muted)">${script.file} ‚Ä¢ v${script.version}</div>
                </div>
                ${statusTag}
            </div>
        `;
    }).join('');
    
    // Add "check existing" button
    container.innerHTML += `
        <div style="margin-top:8px">
            <button onclick="markExistingFiles()">üîç I have some scripts already installed</button>
        </div>
    `;
    
    // Select all by default if none selected
    if (installerState.selectedScripts.length === 0) {
        AVAILABLE_SCRIPTS.forEach(s => installerState.selectedScripts.push(s.id));
        renderInstallScriptsList();
    }
}

function toggleScriptSelection(scriptId) {
    const idx = installerState.selectedScripts.indexOf(scriptId);
    if (idx > -1) {
        installerState.selectedScripts.splice(idx, 1);
    } else {
        installerState.selectedScripts.push(scriptId);
    }
}

function markExistingFiles() {
    const existing = prompt(
        'Enter the filenames of scripts you already have installed (comma-separated):\n\n' +
        'Example: source_animations.lua, source_swap.lua\n\n' +
        'Leave empty if none installed.'
    );
    
    if (existing !== null) {
        installerState.existingFiles = existing
            .split(',')
            .map(f => f.trim())
            .filter(f => f.length > 0);
        
        if (installerState.existingFiles.length > 0) {
            document.getElementById('existingInstallCard').style.display = 'block';
            renderExistingInstallInfo();
        } else {
            document.getElementById('existingInstallCard').style.display = 'none';
        }
        
        renderInstallScriptsList();
    }
}

function renderExistingInstallInfo() {
    const container = document.getElementById('existingInstallInfo');
    if (!container) return;
    
    container.innerHTML = `
        <p>The following scripts appear to already exist in your target folder:</p>
        <ul style="margin:8px 0 0 16px">
            ${installerState.existingFiles.map(f => `<li>${f}</li>`).join('')}
        </ul>
        <p style="margin-top:8px;color:var(--muted);font-size:0.9em">
            Choose how to handle existing files:
        </p>
    `;
}

function handleExistingInstall(action) {
    installerState.installAction = action;
    
    const actionText = {
        'skip': 'Skipping existing files',
        'backup': 'Will backup existing files before replacing',
        'replace': 'Will replace all existing files'
    };
    
    log(actionText[action], 'info');
    document.getElementById('existingInstallCard').style.display = 'none';
}

function renderInstallReview() {
    const container = document.getElementById('installReview');
    if (!container) return;
    
    const selectedScripts = AVAILABLE_SCRIPTS.filter(s => 
        installerState.selectedScripts.includes(s.id)
    );
    
    if (selectedScripts.length === 0) {
        container.innerHTML = '<p style="color:var(--danger)">No scripts selected. Go back and select at least one script.</p>';
        return;
    }
    
    container.innerHTML = `
        <div class="install-review-item">
            <span><strong>Source:</strong></span>
            <span style="font-size:0.85em">${installerState.sourcePath || '(not set)'}</span>
        </div>
        <div class="install-review-item">
            <span><strong>Target:</strong></span>
            <span style="font-size:0.85em">${installerState.targetPath || '(not set)'}</span>
        </div>
        <div class="install-review-item">
            <span><strong>Scripts:</strong></span>
            <span>${selectedScripts.length} selected</span>
        </div>
        <div style="margin-top:8px">
            ${selectedScripts.map(s => `
                <div style="display:flex;justify-content:space-between;padding:2px 0;font-size:0.85em">
                    <span>${s.icon} ${s.name}</span>
                    <span style="color:var(--muted)">${s.file}</span>
                </div>
            `).join('')}
        </div>
        ${installerState.existingFiles.length > 0 ? `
            <div class="install-review-item" style="margin-top:8px;border-top:1px solid var(--bg);padding-top:8px">
                <span><strong>Existing files:</strong></span>
                <span>${installerState.installAction}</span>
            </div>
        ` : ''}
    `;
}

function generateInstallScript() {
    const method = document.getElementById('installMethod').value;
    const selectedScripts = AVAILABLE_SCRIPTS.filter(s => 
        installerState.selectedScripts.includes(s.id)
    );
    
    if (selectedScripts.length === 0) {
        log('No scripts selected', 'error');
        return;
    }
    
    const source = installerState.sourcePath;
    const target = installerState.targetPath;
    
    if (!source || !target || source.includes('(') || target.includes('(')) {
        log('Set valid source and target paths first', 'error');
        return;
    }
    
    let script = '';
    
    switch (method) {
        case 'powershell':
            script = generatePowerShellScript(selectedScripts, source, target);
            break;
        case 'batch':
            script = generateBatchScript(selectedScripts, source, target);
            break;
        case 'bash':
            script = generateBashScript(selectedScripts, source, target);
            break;
        case 'manual':
            script = generateManualInstructions(selectedScripts, source, target);
            break;
    }
    
    installerState.generatedScript = script;
    
    const output = document.getElementById('installOutput');
    if (output) output.textContent = script;
    
    goToInstallStep(4);
}

function generatePowerShellScript(scripts, source, target) {
    const backup = installerState.installAction === 'backup';
    const skip = installerState.installAction === 'skip';
    
    let ps = `# OBS Animation Suite Installer
# Generated: ${new Date().toISOString()}
# Run this script as Administrator

$source = "${source}"
$target = "${target}"

# Create target directory if it doesn't exist
if (!(Test-Path $target)) {
    New-Item -ItemType Directory -Path $target -Force
    Write-Host "Created directory: $target" -ForegroundColor Green
}

`;

    if (backup) {
        ps += `# Backup existing files
$backupDir = "$target\\backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
Write-Host "Backup directory: $backupDir" -ForegroundColor Cyan

`;
    }

    scripts.forEach(s => {
        const isExisting = installerState.existingFiles.includes(s.file);
        
        if (skip && isExisting) {
            ps += `# Skipping ${s.file} (already exists)\n`;
            ps += `Write-Host "Skipped: ${s.file} (exists)" -ForegroundColor Yellow\n\n`;
        } else {
            if (backup && isExisting) {
                ps += `# Backup ${s.file}
if (Test-Path "$target\\${s.file}") {
    Copy-Item "$target\\${s.file}" "$backupDir\\${s.file}"
    Write-Host "Backed up: ${s.file}" -ForegroundColor Cyan
}
`;
            }
            ps += `# Install ${s.name}
Copy-Item "$source\\${s.file}" "$target\\${s.file}" -Force
Write-Host "Installed: ${s.file}" -ForegroundColor Green

`;
        }
    });

    ps += `
Write-Host ""
Write-Host "Installation complete!" -ForegroundColor Green
Write-Host "Restart OBS and go to Tools > Scripts to add the scripts." -ForegroundColor White
Write-Host ""
Read-Host "Press Enter to exit"
`;

    return ps;
}

function generateBatchScript(scripts, source, target) {
    const backup = installerState.installAction === 'backup';
    const skip = installerState.installAction === 'skip';
    
    let bat = `@echo off
REM OBS Animation Suite Installer
REM Generated: ${new Date().toISOString()}
REM Run this script as Administrator

set "source=${source}"
set "target=${target}"

REM Create target directory if needed
if not exist "%target%" mkdir "%target%"

`;

    if (backup) {
        bat += `REM Create backup directory
set "backup=%target%\\backup_%date:~-4%%date:~-7,2%%date:~-10,2%"
mkdir "%backup%" 2>nul

`;
    }

    scripts.forEach(s => {
        const isExisting = installerState.existingFiles.includes(s.file);
        
        if (skip && isExisting) {
            bat += `REM Skipping ${s.file} (already exists)\necho Skipped: ${s.file}\n\n`;
        } else {
            if (backup && isExisting) {
                bat += `if exist "%target%\\${s.file}" copy "%target%\\${s.file}" "%backup%\\${s.file}"\n`;
            }
            bat += `copy /Y "%source%\\${s.file}" "%target%\\${s.file}"\necho Installed: ${s.file}\n\n`;
        }
    });

    bat += `
echo.
echo Installation complete!
echo Restart OBS and go to Tools ^> Scripts to add the scripts.
pause
`;

    return bat;
}

function generateBashScript(scripts, source, target) {
    const backup = installerState.installAction === 'backup';
    const skip = installerState.installAction === 'skip';
    
    let bash = `#!/bin/bash
# OBS Animation Suite Installer
# Generated: ${new Date().toISOString()}
# Run: chmod +x install.sh && ./install.sh

SOURCE="${source.replace(/\\/g, '/')}"
TARGET="${target.replace(/\\/g, '/')}"

# Create target directory
mkdir -p "$TARGET"

`;

    if (backup) {
        bash += `# Create backup
BACKUP="$TARGET/backup_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$BACKUP"

`;
    }

    scripts.forEach(s => {
        const isExisting = installerState.existingFiles.includes(s.file);
        
        if (skip && isExisting) {
            bash += `# Skipping ${s.file} (already exists)\necho "Skipped: ${s.file}"\n\n`;
        } else {
            if (backup && isExisting) {
                bash += `[ -f "$TARGET/${s.file}" ] && cp "$TARGET/${s.file}" "$BACKUP/${s.file}"\n`;
            }
            bash += `cp "$SOURCE/${s.file}" "$TARGET/${s.file}"\necho "Installed: ${s.file}"\n\n`;
        }
    });

    bash += `
echo ""
echo "Installation complete!"
echo "Restart OBS and go to Tools > Scripts to add the scripts."
`;

    return bash;
}

function generateManualInstructions(scripts, source, target) {
    let manual = `=== OBS Animation Suite - Manual Installation ===
Generated: ${new Date().toISOString()}

SOURCE FOLDER:
${source}

TARGET FOLDER:
${target}

STEPS:
1. Open File Explorer
2. Navigate to the SOURCE folder above
3. Copy the following files:

`;

    scripts.forEach((s, i) => {
        manual += `   ${i + 1}. ${s.file} (${s.name})\n`;
    });

    manual += `
4. Navigate to the TARGET folder above
   (Create it if it doesn't exist)

5. Paste the files

6. Open OBS Studio
7. Go to Tools > Scripts
8. Click the + button
9. Navigate to: ${target}
10. Select all the .lua files and click Open

11. Configure each script in the Scripts window

Done! Your scripts are now installed.
`;

    return manual;
}

function copyInstallScript() {
    if (!installerState.generatedScript) {
        log('Generate a script first', 'error');
        return;
    }
    
    navigator.clipboard.writeText(installerState.generatedScript).then(() => {
        log('Script copied to clipboard!', 'success');
    });
}

function downloadInstallScript() {
    if (!installerState.generatedScript) {
        log('Generate a script first', 'error');
        return;
    }
    
    const method = document.getElementById('installMethod').value;
    const extensions = {
        'powershell': 'ps1',
        'batch': 'bat',
        'bash': 'sh',
        'manual': 'txt'
    };
    
    const filename = `obs_animation_suite_install.${extensions[method]}`;
    const blob = new Blob([installerState.generatedScript], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // In OBS dock, download likely failed - offer clipboard fallback
    if (isOBSDock()) {
        // Give the download a moment to potentially work, then offer fallback
        setTimeout(() => {
            if (confirm(`Download may not work in OBS dock.\n\nCopy script to clipboard instead?\n\nSave as: ${filename}`)) {
                copyInstallScript();
            }
        }, 500);
    } else {
        log(`Downloaded ${filename}`, 'success');
    }
}


// ============ Keyboard Shortcuts ============
document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    // 1-9 triggers saved swap configs
    if (e.key >= '1' && e.key <= '9') {
        const idx = parseInt(e.key) - 1;
        if (idx < swapConfigs.length) loadSwapConfig(idx);
    }
    // Space toggles text cycler
    if (e.key === ' ') {
        e.preventDefault();
        cycleInterval ? stopTextCycle() : startTextCycle();
    }
});
</script>
</body>
</html>

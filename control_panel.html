<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBS Animation Suite</title>
    <style>
        :root {
            --bg: #0d1117;
            --card: #161b22;
            --border: #30363d;
            --accent: #58a6ff;
            --accent2: #a371f7;
            --success: #3fb950;
            --warning: #d29922;
            --danger: #f85149;
            --text: #e6edf3;
            --muted: #8b949e;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
        }
        
        /* Minimal scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--muted);
        }
        ::-webkit-scrollbar-corner {
            background: transparent;
        }
        /* Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }
        
        /* Layout */
        .app { display: flex; flex-direction: column; min-height: 100vh; }
        .header {
            background: var(--card);
            border-bottom: 1px solid var(--border);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .header h1 { font-size: 1.1em; display: flex; align-items: center; gap: 6px; }
        .title-text { white-space: nowrap; }
        .status-dot {
            width: 10px; height: 10px;
            border-radius: 50%;
            background: var(--danger);
        }
        .status-dot.connected { background: var(--success); }
        .status-dot.connecting { background: var(--warning); animation: pulse 1s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; } }
        
        .tabs {
            display: flex;
            background: var(--card);
            border-bottom: 1px solid var(--border);
            overflow-x: auto;
        }
        .tab {
            padding: 10px 16px;
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
            font-size: 1.1em;
            flex: 1;
            text-align: center;
        }
        .tab:hover { color: var(--text); }
        .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
        
        .content { flex: 1; padding: 20px; overflow-y: auto; }
        .page { display: none; }
        .page.active { display: block; }
        
        /* Components */
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .card h3 {
            font-size: 0.9em;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 14px;
            margin-bottom: 8px;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        textarea { resize: vertical; min-height: 100px; font-family: inherit; }
        
        label { display: block; font-size: 0.85em; color: var(--muted); margin-bottom: 4px; }
        
        button {
            padding: 8px 16px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--card);
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.15s;
        }
        button:hover { background: var(--border); }
        button:disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }
        .requires-connection { transition: opacity 0.2s; }
        .disconnected .requires-connection { opacity: 0.4; pointer-events: none; }
        .disconnected .requires-connection::after {
            content: 'üîå';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .btn-primary { background: var(--accent); border-color: var(--accent); color: #000; }
        .btn-primary:hover { background: #79b8ff; }
        .btn-success { background: var(--success); border-color: var(--success); color: #000; }
        .btn-danger { background: var(--danger); border-color: var(--danger); color: #fff; }
        .btn-lg { padding: 12px 24px; font-size: 16px; }
        .btn-block { width: 100%; }
        
        .row { display: flex; gap: 8px; margin-bottom: 8px; }
        .row > * { flex: 1; }
        
        .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; }
        
        .source-btn {
            padding: 16px;
            text-align: center;
            background: linear-gradient(135deg, var(--accent), var(--accent2));
            border: none;
            color: #fff;
            font-weight: 600;
        }
        .source-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        
        .log {
            background: #000;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        .log-entry { margin-bottom: 2px; }
        .log-entry.error { color: var(--danger); }
        .log-entry.success { color: var(--success); }
        .log-entry.info { color: var(--accent); }
        
        .source-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: var(--bg);
            border-radius: 6px;
            margin-bottom: 6px;
        }
        .source-item .name { font-weight: 500; }
        .source-item .type { font-size: 0.8em; color: var(--muted); }
        
        .toggle {
            width: 44px; height: 24px;
            background: var(--border);
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
        }
        .toggle.on { background: var(--success); }
        .toggle::after {
            content: '';
            position: absolute;
            width: 18px; height: 18px;
            background: #fff;
            border-radius: 50%;
            top: 3px; left: 3px;
            transition: transform 0.2s;
        }
        .toggle.on::after { transform: translateX(20px); }
        
        .url-box {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .url-box input { margin: 0; flex: 1; }
        
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            background: var(--border);
        }
        .badge-success { background: var(--success); color: #000; }
        
        .empty-state {
            text-align: center;
            padding: 12px 8px;
            color: var(--muted);
            font-size: 0.9em;
        }
        
        /* Text cycler specific */
        .text-preview {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            font-size: 1.5em;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Responsive - Tiny dock (<250px) */
        @media (max-width: 250px) {
            .header { padding: 6px 8px; }
            .header h1 { font-size: 0.85em; }
            .title-text { display: none; }
            .tab { padding: 8px 4px; font-size: 1em; }
            .content { padding: 8px; }
            .card { padding: 8px; margin-bottom: 8px; }
            .card h3 { font-size: 0.7em; margin-bottom: 6px; }
            .grid { grid-template-columns: 1fr; gap: 4px; }
            .source-btn { padding: 8px 4px; font-size: 0.75em; }
            .row { flex-direction: column; gap: 4px; }
            .empty-state { padding: 15px 8px; font-size: 0.85em; }
            button { padding: 5px 8px; font-size: 0.8em; }
            .btn-lg { padding: 8px 12px; font-size: 0.85em; }
            input, select, textarea { padding: 5px 8px; font-size: 0.85em; }
            .log { padding: 6px; font-size: 0.65em; max-height: 100px; }
            .text-preview { padding: 10px; font-size: 1em; min-height: 50px; }
            .source-item { padding: 6px; }
            .source-item .name { font-size: 0.8em; }
            .toggle { width: 32px; height: 18px; flex-shrink: 0; }
            .toggle::after { width: 12px; height: 12px; top: 3px; }
            .toggle.on::after { transform: translateX(14px); }
            .url-box { flex-direction: column; }
        }
        
        /* Responsive - Narrow dock (250-350px) */
        @media (max-width: 350px) and (min-width: 251px) {
            .header { padding: 8px 10px; }
            .header h1 { font-size: 0.9em; }
            .tab { padding: 8px 6px; font-size: 1em; }
            .content { padding: 10px; }
            .card { padding: 10px; margin-bottom: 10px; }
            .card h3 { font-size: 0.75em; margin-bottom: 8px; }
            .grid { grid-template-columns: 1fr 1fr; gap: 6px; }
            .source-btn { padding: 10px 6px; font-size: 0.8em; }
            .row { flex-direction: column; }
            .empty-state { padding: 20px 10px; font-size: 0.9em; }
            button { padding: 6px 10px; font-size: 0.85em; }
            input, select, textarea { padding: 6px 10px; font-size: 0.9em; }
            .log { padding: 8px; font-size: 0.7em; max-height: 120px; }
            .text-preview { padding: 12px; font-size: 1.1em; min-height: 60px; }
        }
        
        /* Responsive - Medium dock (350-500px) */
        @media (max-width: 500px) and (min-width: 351px) {
            .header { padding: 10px 12px; }
            .header h1 { font-size: 1em; }
            .tab { padding: 10px 8px; }
            .content { padding: 12px; }
            .card { padding: 12px; }
            .grid { grid-template-columns: 1fr 1fr; }
            .source-btn { padding: 12px 8px; font-size: 0.85em; }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <h1><span class="status-dot" id="statusDot"></span><span class="title-text">Animation Suite</span></h1>
            <div style="display:flex;gap:4px">
                <button onclick="location.reload()" title="Reload Panel">üîÑ</button>
                <button onclick="showPage('setup')" id="connectHeaderBtn">Connect</button>
            </div>
        </header>
        
        <nav class="tabs">
            <button class="tab active" onclick="showPage('dashboard')" title="Dashboard">üè†</button>
            <button class="tab" onclick="showPage('sources')" title="Sources">üì¶</button>
            <button class="tab" onclick="showPage('text')" title="Text Cycler">üìù</button>
            <button class="tab" onclick="showPage('swaps')" title="Swaps">üîÑ</button>
            <button class="tab" onclick="showPage('setup')" title="Setup">‚öôÔ∏è</button>
        </nav>
        
        <main class="content">
            <!-- Dashboard -->
            <div id="page-dashboard" class="page active">
                <div class="card">
                    <h3>Quick Actions</h3>
                    <div class="grid">
                        <button class="source-btn" onclick="cycleAspect()">üîÑ Cycle Aspect</button>
                        <button class="source-btn" onclick="refreshScenes()">üîÉ Refresh</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Current Scene</h3>
                    <div id="currentScene" class="empty-state">Connect to OBS first</div>
                </div>
                
                <div class="card">
                    <h3>Quick Swaps</h3>
                    <div class="grid" id="dashSwapGrid"></div>
                </div>
                
                <div class="card">
                    <h3>Activity Log</h3>
                    <div id="log" class="log"></div>
                </div>
            </div>
            
            <!-- Sources -->
            <div id="page-sources" class="page">
                <div class="card">
                    <h3>Scene Sources</h3>
                    <button onclick="refreshSources()" style="margin-bottom:12px">üîÉ Refresh Sources</button>
                    <div id="sourcesList"></div>
                </div>
            </div>
            
            <!-- Text Cycler -->
            <div id="page-text" class="page">
                <div class="card">
                    <h3>Text Source</h3>
                    <select id="textSource" onchange="loadTextSource()">
                        <option value="">-- Select Text Source --</option>
                    </select>
                    <div class="text-preview" id="textPreview" style="margin-top:8px">Select a source</div>
                </div>
                
                <div class="card">
                    <h3>Text Lines</h3>
                    <textarea id="textLines" placeholder="Enter text lines (one per line)&#10;Line 1&#10;Line 2&#10;Line 3" rows="5"></textarea>
                </div>
                
                <div class="card">
                    <h3>Settings</h3>
                    <label>Transition</label>
                    <select id="textTransition" onchange="updateTransitionMode()">
                        <option value="none">None (instant)</option>
                        <option value="glitch">Glitch ‚Üí Reveal</option>
                        <option value="typewriter">Typewriter</option>
                        <option value="scramble">Scramble ‚Üí Snap</option>
                    </select>
                    <p id="transitionInfo" style="font-size:0.75em;color:var(--muted);margin:4px 0 12px"></p>
                    <div class="row">
                        <div>
                            <label>Trans (ms)</label>
                            <input type="number" id="transDuration" value="500" min="100" max="2000" step="50">
                        </div>
                    </div>
                    <div class="row">
                        <div>
                            <label>Cycle (ms)</label>
                            <input type="number" id="textDuration" value="3000" min="500" step="100">
                        </div>
                    </div>
                </div>
                
                <div class="row">
                    <button class="btn-success btn-lg" id="startCycleBtn" onclick="startSimpleCycle()">‚ñ∂ Start</button>
                    <button class="btn-danger btn-lg" id="stopCycleBtn" onclick="stopSimpleCycle()" disabled>‚ñ† Stop</button>
                </div>
            </div>
            
            <!-- Swaps -->
            <div id="page-swaps" class="page">
                <div class="card">
                    <h3>Quick Swap</h3>
                    <p style="color:var(--muted);margin-bottom:12px;font-size:0.85em">Select two sources and swap their position/size</p>
                    <label>Source A</label>
                    <select id="swapSourceA"></select>
                    <label>Source B</label>
                    <select id="swapSourceB"></select>
                    <div class="row" style="margin-top:8px">
                        <button class="btn-primary btn-lg" onclick="executeSwap()">üîÑ Swap Now</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Animation</h3>
                    <label>Style</label>
                    <select id="swapStyle">
                        <option value="slide" selected>Slide (smooth move)</option>
                        <option value="teleport">Teleport (instant)</option>
                        <option value="crossfade">Crossfade (opacity)</option>
                        <option value="scale">Scale (shrink/grow)</option>
                        <option value="bounce">Bounce (overshoot)</option>
                        <option value="elastic">Elastic (springy)</option>
                        <option value="arc">Arc (curved path)</option>
                    </select>
                    <div class="row">
                        <div>
                            <label>Duration (ms)</label>
                            <input type="number" id="swapDuration" value="400" min="0" max="3000" step="50">
                        </div>
                        <div>
                            <label>Easing</label>
                            <select id="swapEasing">
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut">Ease Out</option>
                                <option value="ease" selected>Ease In-Out</option>
                                <option value="back">Back (overshoot)</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Saved Configs</h3>
                    <div id="savedSwaps"></div>
                    <div class="row" style="margin-top:8px">
                        <button onclick="saveCurrentSwap()">üíæ Save</button>
                        <button onclick="exportConfigs()">üì§ Export</button>
                        <button onclick="importConfigs()">üì• Import</button>
                    </div>
                </div>
            </div>
            
            <!-- Setup -->
            <div id="page-setup" class="page">
                <div class="card">
                    <h3>Connection</h3>
                    <div class="row">
                        <div>
                            <label>Host</label>
                            <input type="text" id="host" value="localhost">
                        </div>
                        <div>
                            <label>Port</label>
                            <input type="text" id="port" value="4455">
                        </div>
                    </div>
                    <label>Password</label>
                    <input type="password" id="password" placeholder="Leave empty if not set">
                    <div style="margin:8px 0">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                            <input type="checkbox" id="rememberCreds" style="width:auto;margin:0">
                            <span>Remember credentials</span>
                        </label>
                        <p style="font-size:0.75em;color:var(--warning);margin-top:4px" id="securityWarning"></p>
                    </div>
                    <button class="btn-primary btn-block" id="connectBtn" onclick="toggleConnection()">Connect</button>
                </div>
                
                <div class="card">
                    <h3>Add as OBS Dock</h3>
                    <p style="color:var(--muted);margin-bottom:12px;font-size:0.9em">
                        In OBS: <strong>View ‚Üí Docks ‚Üí Custom Browser Docks</strong><br>
                        Click + and paste this URL:
                    </p>
                    <div class="url-box">
                        <input type="text" id="dockUrl" readonly>
                        <button onclick="copyUrl()">üìã Copy</button>
                    </div>
                    <p style="color:var(--muted);margin-top:8px;font-size:0.85em" id="copyStatus"></p>
                </div>
                
                <div class="card">
                    <h3>OBS WebSocket Setup</h3>
                    <ol style="color:var(--muted);padding-left:20px;font-size:0.9em;line-height:2">
                        <li>In OBS: <strong>Tools ‚Üí WebSocket Server Settings</strong></li>
                        <li>Check "Enable WebSocket server"</li>
                        <li>Note the port (default: 4455)</li>
                        <li>Set password if desired</li>
                        <li>Click Apply, then connect here</li>
                    </ol>
                </div>
                
                <div class="card">
                    <h3>Keyboard Shortcuts</h3>
                    <p style="color:var(--muted);font-size:0.9em">When this panel is focused:</p>
                    <ul style="color:var(--muted);padding-left:20px;font-size:0.9em;line-height:2">
                        <li><strong>1-9</strong> - Trigger saved swap configs</li>
                        <li><strong>Space</strong> - Start/stop text cycler</li>
                    </ul>
                </div>
            </div>
        </main>
    </div>

<script>
// ============ State ============
let ws = null;
let connected = false;
let msgId = 1;
let pendingRequests = {};
let currentScene = '';
let sources = [];
let textSources = [];
let aspectMode = 0;
let reconnectAttempts = 0;
const MAX_RECONNECT = 3;


// ============ Secure Credential Storage (AES-GCM) ============
let encryptionKey = null; // Derived from PIN, kept in memory only

async function deriveKey(pin, salt) {
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
        'raw', encoder.encode(pin), 'PBKDF2', false, ['deriveKey']
    );
    return crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt: salt, iterations: 100000, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
    );
}

async function encryptPassword(password, pin) {
    const encoder = new TextEncoder();
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await deriveKey(pin, salt);
    
    const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encoder.encode(password)
    );
    
    // Combine salt + iv + encrypted data and encode as base64
    const combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
    combined.set(salt, 0);
    combined.set(iv, salt.length);
    combined.set(new Uint8Array(encrypted), salt.length + iv.length);
    
    return btoa(String.fromCharCode(...combined));
}

async function decryptPassword(encryptedData, pin) {
    try {
        const combined = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
        const salt = combined.slice(0, 16);
        const iv = combined.slice(16, 28);
        const data = combined.slice(28);
        
        const key = await deriveKey(pin, salt);
        const decrypted = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv: iv },
            key,
            data
        );
        
        return new TextDecoder().decode(decrypted);
    } catch (e) {
        return null; // Wrong PIN or corrupted data
    }
}

async function saveCredentials() {
    const remember = document.getElementById('rememberCreds').checked;
    const host = document.getElementById('host').value;
    const port = document.getElementById('port').value;
    const password = document.getElementById('password').value;
    
    if (remember) {
        localStorage.setItem('obs_host', host);
        localStorage.setItem('obs_port', port);
        
        if (password) {
            // Get or create PIN for encryption
            let pin = sessionStorage.getItem('obs_pin');
            if (!pin) {
                pin = prompt('Create a PIN to encrypt your password (4+ characters):');
                if (!pin || pin.length < 4) {
                    log('PIN must be 4+ characters. Password not saved.', 'error');
                    localStorage.removeItem('obs_pw');
                    return;
                }
                sessionStorage.setItem('obs_pin', pin); // Keep in session only
            }
            
            const encrypted = await encryptPassword(password, pin);
            localStorage.setItem('obs_pw', encrypted);
            localStorage.setItem('obs_pw_encrypted', 'true');
        } else {
            localStorage.removeItem('obs_pw');
            localStorage.removeItem('obs_pw_encrypted');
        }
        localStorage.setItem('obs_remember', 'true');
    } else {
        localStorage.removeItem('obs_host');
        localStorage.removeItem('obs_port');
        localStorage.removeItem('obs_pw');
        localStorage.removeItem('obs_pw_encrypted');
        localStorage.removeItem('obs_remember');
        sessionStorage.removeItem('obs_pin');
    }
}

async function loadCredentials() {
    const remembered = localStorage.getItem('obs_remember') === 'true';
    document.getElementById('rememberCreds').checked = remembered;
    
    if (remembered) {
        const host = localStorage.getItem('obs_host');
        const port = localStorage.getItem('obs_port');
        const encryptedPw = localStorage.getItem('obs_pw');
        const isEncrypted = localStorage.getItem('obs_pw_encrypted') === 'true';
        
        if (host) document.getElementById('host').value = host;
        if (port) document.getElementById('port').value = port;
        
        if (encryptedPw && isEncrypted) {
            // Need PIN to decrypt
            let pin = sessionStorage.getItem('obs_pin');
            if (!pin) {
                pin = prompt('Enter PIN to unlock saved password:');
                if (!pin) {
                    log('PIN required to use saved password', 'error');
                    updateSecurityWarning();
                    return false;
                }
            }
            
            const password = await decryptPassword(encryptedPw, pin);
            if (password) {
                document.getElementById('password').value = password;
                sessionStorage.setItem('obs_pin', pin); // Remember for session
                updateSecurityWarning();
                return true;
            } else {
                log('Wrong PIN or corrupted data', 'error');
                sessionStorage.removeItem('obs_pin');
                updateSecurityWarning();
                return false;
            }
        }
        
        updateSecurityWarning();
        return true; // Has host/port at least
    }
    return false;
}

function updateSecurityWarning() {
    const pw = document.getElementById('password').value;
    const remember = document.getElementById('rememberCreds').checked;
    const isEncrypted = localStorage.getItem('obs_pw_encrypted') === 'true';
    const warn = document.getElementById('securityWarning');
    
    if (remember && pw) {
        if (isEncrypted) {
            warn.textContent = 'üîê Password encrypted with AES-256-GCM';
            warn.style.color = 'var(--success)';
        } else {
            warn.textContent = 'üîí Password will be encrypted with your PIN';
            warn.style.color = 'var(--accent)';
        }
    } else {
        warn.textContent = '';
    }
}

// ============ Connection State UI ============
function updateConnectionState() {
    const app = document.querySelector('.app');
    if (connected) {
        app.classList.remove('disconnected');
    } else {
        app.classList.add('disconnected');
    }
    
    // Disable action buttons when disconnected
    document.querySelectorAll('.source-btn, #startCycleBtn').forEach(btn => {
        btn.disabled = !connected;
    });
}

// ============ UI State Persistence ============
const UI_FIELDS = [
    'swapStyle', 'swapDuration', 'swapEasing',
    'textSource', 'textLines', 'textDuration', 'textTransition', 'transDuration',
    'swapSourceA', 'swapSourceB'
];

function saveUIState() {
    const state = {};
    for (const id of UI_FIELDS) {
        const el = document.getElementById(id);
        if (el) state[id] = el.value;
    }
    localStorage.setItem('ui_state', JSON.stringify(state));
    console.log('UI state saved:', state);
}

function loadUIState() {
    try {
        const state = JSON.parse(localStorage.getItem('ui_state') || '{}');
        console.log('Loading UI state:', state);
        for (const id of UI_FIELDS) {
            const el = document.getElementById(id);
            if (el && state[id] !== undefined && state[id] !== '') {
                el.value = state[id];
            }
        }
    } catch (e) {
        console.error('Error loading UI state:', e);
    }
}

function setupUIStatePersistence() {
    // Save on any input change - multiple events for robustness
    for (const id of UI_FIELDS) {
        const el = document.getElementById(id);
        if (el) {
            el.addEventListener('change', saveUIState);
            el.addEventListener('input', saveUIState);
            el.addEventListener('blur', saveUIState); // Also save when leaving field
        }
    }
    
}

// ============ Initialization ============
document.addEventListener('DOMContentLoaded', async () => {
    // Set dock URL
    const url = window.location.href;
    document.getElementById('dockUrl').value = url;
    
    // Load saved configs and UI state
    renderSavedSwaps();
    loadUIState();
    restoreActiveTab();
    updateConnectionState();
    setupUIStatePersistence();
    updateTransitionMode();
    
    // Setup credential UI listeners
    document.getElementById('rememberCreds').addEventListener('change', updateSecurityWarning);
    document.getElementById('password').addEventListener('input', updateSecurityWarning);
    
    // Load saved credentials and auto-connect
    try {
        const hasCreds = await loadCredentials();
        if (hasCreds && document.getElementById('password').value) {
            log('Credentials unlocked. Auto-connecting...', 'info');
            setTimeout(connect, 500);
        } else if (hasCreds) {
            log('Host/port loaded. Enter password to connect.', 'info');
        } else {
            log('Ready. Connect to OBS to begin.', 'info');
        }
    } catch (e) {
        log('Ready. Connect to OBS to begin.', 'info');
    }
});

// ============ UI ============
function showPage(id, save = true) {
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.getElementById('page-' + id).classList.add('active');
    
    // Find and activate the corresponding tab
    const tabs = document.querySelectorAll('.tab');
    const tabIds = ['dashboard', 'sources', 'text', 'swaps', 'setup'];
    const tabIndex = tabIds.indexOf(id);
    if (tabIndex >= 0 && tabs[tabIndex]) {
        tabs[tabIndex].classList.add('active');
    }
    
    // Save active tab
    if (save) {
        localStorage.setItem('active_tab', id);
    }
}

function restoreActiveTab() {
    const savedTab = localStorage.getItem('active_tab');
    if (savedTab) {
        showPage(savedTab, false);
    }
}

function log(msg, type = '') {
    const el = document.getElementById('log');
    const entry = document.createElement('div');
    entry.className = 'log-entry ' + type;
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    el.insertBefore(entry, el.firstChild);
    if (el.children.length > 50) el.removeChild(el.lastChild);
}

function copyUrl() {
    const url = document.getElementById('dockUrl');
    url.select();
    document.execCommand('copy');
    document.getElementById('copyStatus').textContent = '‚úì Copied to clipboard!';
    setTimeout(() => document.getElementById('copyStatus').textContent = '', 2000);
}

function renderDashSwaps() {
    const grid = document.getElementById('dashSwapGrid');
    if (swapConfigs.length === 0) {
        grid.innerHTML = '<div class="empty-state" style="padding:10px;grid-column:1/-1">No saved swaps. Go to üîÑ tab to create one.</div>';
        return;
    }
    grid.innerHTML = swapConfigs.map((c, i) => 
        `<button class="source-btn" onclick="loadSwapConfig(${i})">${c.name}</button>`
    ).join('');
}

function updateConnectionUI() {
    const dot = document.getElementById('statusDot');
    const btn = document.getElementById('connectBtn');
    const headerBtn = document.getElementById('connectHeaderBtn');
    
    if (connected) {
        dot.className = 'status-dot connected';
        btn.textContent = 'Disconnect';
        btn.className = 'btn-danger btn-block';
        headerBtn.textContent = 'Connected';
        headerBtn.className = 'btn-success';
    } else {
        dot.className = 'status-dot';
        btn.textContent = 'Connect';
        btn.className = 'btn-primary btn-block';
        headerBtn.textContent = 'Connect';
        headerBtn.className = '';
    }
}

// ============ WebSocket ============
function toggleConnection() {
    connected ? disconnect() : connect();
}

function connect() {
    const host = document.getElementById('host').value || 'localhost';
    const port = document.getElementById('port').value || '4455';
    const password = document.getElementById('password').value;
    
    document.getElementById('statusDot').className = 'status-dot connecting';
    log('Connecting...', 'info');
    
    try {
        ws = new WebSocket(`ws://${host}:${port}`);
        ws.onopen = () => {
            log('Socket open, authenticating...');
            reconnectAttempts = 0;
        };
        ws.onmessage = e => handleMessage(JSON.parse(e.data), password);
        ws.onerror = () => { 
            log('Connection error', 'error');
        };
        ws.onclose = () => { 
            const wasConnected = connected;
            connected = false;
            updateConnectionUI();
            updateConnectionState();
            log('Disconnected');
            
            // Auto-reconnect if was connected and have saved creds
            if (wasConnected && localStorage.getItem('obs_remember') === 'true') {
                if (reconnectAttempts < MAX_RECONNECT) {
                    reconnectAttempts++;
                    log(`Reconnecting (${reconnectAttempts}/${MAX_RECONNECT})...`, 'info');
                    setTimeout(connect, 2000);
                }
            }
        };
    } catch (e) {
        log('Failed: ' + e.message, 'error');
        updateConnectionState();
    }
}

function disconnect() {
    reconnectAttempts = MAX_RECONNECT; // Prevent auto-reconnect
    if (ws) ws.close();
    connected = false;
    updateConnectionUI();
    updateConnectionState();
}

async function handleMessage(data, password) {
    if (data.op === 0) { // Hello
        const auth = data.d.authentication;
        if (auth && password) {
            const secret = await sha256(password + auth.salt);
            const authStr = await sha256(secret + auth.challenge);
            send({ op: 1, d: { rpcVersion: 1, authentication: authStr } });
        } else if (!auth) {
            send({ op: 1, d: { rpcVersion: 1 } });
        } else {
            log('Password required', 'error');
            disconnect();
        }
    } else if (data.op === 2) { // Identified
        connected = true;
        updateConnectionUI();
        updateConnectionState();
        saveCredentials(); // Save on successful connection
        log('Connected to OBS!', 'success');
        refreshScenes();
    } else if (data.op === 7) { // Response
        const req = pendingRequests[data.d.requestId];
        if (req) {
            if (data.d.requestStatus.result) {
                req.resolve(data.d.responseData);
            } else {
                req.reject(data.d.requestStatus.comment);
            }
            delete pendingRequests[data.d.requestId];
        }
    } else if (data.op === 5) { // Event
        handleEvent(data.d);
    }
}

function handleEvent(event) {
    if (event.eventType === 'CurrentProgramSceneChanged') {
        currentScene = event.eventData.sceneName;
        document.getElementById('currentScene').textContent = currentScene;
        refreshSources();
    }
}

function send(data) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(data));
    }
}

function request(type, data = {}) {
    return new Promise((resolve, reject) => {
        const id = 'req_' + (msgId++);
        pendingRequests[id] = { resolve, reject };
        send({ op: 6, d: { requestType: type, requestId: id, requestData: data } });
        setTimeout(() => {
            if (pendingRequests[id]) {
                delete pendingRequests[id];
                reject('Timeout');
            }
        }, 5000);
    });
}

async function sha256(msg) {
    const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(msg));
    return btoa(String.fromCharCode(...new Uint8Array(buf)));
}

// ============ OBS Actions ============
async function refreshScenes() {
    if (!connected) return;
    try {
        const data = await request('GetCurrentProgramScene');
        currentScene = data.currentProgramSceneName;
        document.getElementById('currentScene').innerHTML = `<strong>${currentScene}</strong>`;
        refreshSources();
        log('Refreshed scene: ' + currentScene);
    } catch (e) {
        log('Error: ' + e, 'error');
    }
}

async function refreshSources() {
    if (!connected || !currentScene) return;
    try {
        const data = await request('GetSceneItemList', { sceneName: currentScene });
        sources = data.sceneItems || [];
        renderSources();
        updateTextSourceDropdown();
        updateSwapDropdowns();
        log(`Found ${sources.length} sources`);
    } catch (e) {
        log('Error getting sources: ' + e, 'error');
    }
}

function renderSources() {
    const list = document.getElementById('sourcesList');
    if (sources.length === 0) {
        list.innerHTML = '<div class="empty-state">No sources in current scene</div>';
        return;
    }
    
    list.innerHTML = sources.map(s => `
        <div class="source-item">
            <div>
                <div class="name">${s.sourceName}</div>
                <div class="type">${s.inputKind || 'scene'}</div>
            </div>
            <div class="toggle ${s.sceneItemEnabled ? 'on' : ''}" 
                 onclick="toggleSource('${s.sourceName}', ${s.sceneItemId}, ${!s.sceneItemEnabled})"></div>
        </div>
    `).join('');
}

async function toggleSource(name, id, enabled) {
    try {
        await request('SetSceneItemEnabled', {
            sceneName: currentScene,
            sceneItemId: id,
            sceneItemEnabled: enabled
        });
        log(`${name}: ${enabled ? 'shown' : 'hidden'}`, 'success');
        refreshSources();
    } catch (e) {
        log('Error: ' + e, 'error');
    }
}

// ============ Source Swap (Direct via WebSocket) ============
let swapConfigs = JSON.parse(localStorage.getItem('swapConfigs') || '[]');
let isSwapping = false;

function updateSwapDropdowns() {
    const selA = document.getElementById('swapSourceA');
    const selB = document.getElementById('swapSourceB');
    
    // Preserve current selections or load from saved state
    const savedState = JSON.parse(localStorage.getItem('ui_state') || '{}');
    const currentA = selA.value || savedState.swapSourceA || '';
    const currentB = selB.value || savedState.swapSourceB || '';
    
    const opts = '<option value="">-- Select --</option>' + 
        sources.map(s => `<option value="${s.sourceName}">${s.sourceName}</option>`).join('');
    selA.innerHTML = opts;
    selB.innerHTML = opts;
    
    // Restore selections if sources still exist
    if (currentA && sources.find(s => s.sourceName === currentA)) selA.value = currentA;
    if (currentB && sources.find(s => s.sourceName === currentB)) selB.value = currentB;
}

async function getSceneItemId(sourceName) {
    const item = sources.find(s => s.sourceName === sourceName);
    return item ? item.sceneItemId : null;
}

async function getTransform(sceneItemId) {
    const data = await request('GetSceneItemTransform', {
        sceneName: currentScene,
        sceneItemId: sceneItemId
    });
    return data.sceneItemTransform;
}

async function setTransform(sceneItemId, transform) {
    await request('SetSceneItemTransform', {
        sceneName: currentScene,
        sceneItemId: sceneItemId,
        sceneItemTransform: transform
    });
}

// ============ Enhanced Easing Functions ============
function easeFunc(t, type) {
    switch(type) {
        case 'easeIn': return t * t * t;
        case 'easeOut': return 1 - Math.pow(1 - t, 3);
        case 'ease': return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
        case 'back': {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return t < 0.5
                ? (Math.pow(2*t, 2) * ((c3 + 1) * 2*t - c3)) / 2
                : (Math.pow(2*t - 2, 2) * ((c3 + 1) * (t*2 - 2) + c3) + 2) / 2;
        }
        case 'bounce': {
            const n1 = 7.5625, d1 = 2.75;
            let x = t;
            if (x < 1/d1) return n1 * x * x;
            if (x < 2/d1) return n1 * (x -= 1.5/d1) * x + 0.75;
            if (x < 2.5/d1) return n1 * (x -= 2.25/d1) * x + 0.9375;
            return n1 * (x -= 2.625/d1) * x + 0.984375;
        }
        case 'elastic': {
            const c4 = (2 * Math.PI) / 3;
            return t === 0 ? 0 : t === 1 ? 1 :
                t < 0.5
                    ? -(Math.pow(2, 20*t - 10) * Math.sin((20*t - 11.125) * c4)) / 2
                    : (Math.pow(2, -20*t + 10) * Math.sin((20*t - 11.125) * c4)) / 2 + 1;
        }
        default: return t; // linear
    }
}

function lerp(a, b, t) { return a + (b - a) * t; }

// ============ Animation Style Implementations ============
async function animateSlide(idA, idB, startA, startB, endA, endB, duration, easing, propsToSwap) {
    const startTime = performance.now();
    
    await new Promise(resolve => {
        function animate() {
            const elapsed = performance.now() - startTime;
            const rawT = Math.min(elapsed / duration, 1);
            const t = easeFunc(rawT, easing);
            
            const currentA = {}, currentB = {};
            for (const p of propsToSwap) {
                currentA[p] = lerp(startA[p], endA[p], t);
                currentB[p] = lerp(startB[p], endB[p], t);
            }
            
            Promise.all([
                setTransform(idA, currentA),
                setTransform(idB, currentB)
            ]).then(() => {
                if (rawT < 1) requestAnimationFrame(animate);
                else resolve();
            });
        }
        requestAnimationFrame(animate);
    });
}

async function animateArc(idA, idB, startA, startB, endA, endB, duration, easing) {
    const startTime = performance.now();
    const arcHeight = 100; // Pixels to arc upward
    
    await new Promise(resolve => {
        function animate() {
            const elapsed = performance.now() - startTime;
            const rawT = Math.min(elapsed / duration, 1);
            const t = easeFunc(rawT, easing);
            
            // Parabolic arc: peaks at t=0.5
            const arcOffset = -4 * arcHeight * rawT * (rawT - 1);
            
            const currentA = {
                positionX: lerp(startA.positionX, endA.positionX, t),
                positionY: lerp(startA.positionY, endA.positionY, t) - arcOffset,
                scaleX: lerp(startA.scaleX, endA.scaleX, t),
                scaleY: lerp(startA.scaleY, endA.scaleY, t)
            };
            const currentB = {
                positionX: lerp(startB.positionX, endB.positionX, t),
                positionY: lerp(startB.positionY, endB.positionY, t) - arcOffset,
                scaleX: lerp(startB.scaleX, endB.scaleX, t),
                scaleY: lerp(startB.scaleY, endB.scaleY, t)
            };
            
            Promise.all([
                setTransform(idA, currentA),
                setTransform(idB, currentB)
            ]).then(() => {
                if (rawT < 1) requestAnimationFrame(animate);
                else resolve();
            });
        }
        requestAnimationFrame(animate);
    });
}

async function animateScale(idA, idB, startA, startB, endA, endB, duration, easing) {
    const startTime = performance.now();
    
    await new Promise(resolve => {
        function animate() {
            const elapsed = performance.now() - startTime;
            const rawT = Math.min(elapsed / duration, 1);
            const t = easeFunc(rawT, easing);
            
            // Shrink in first half, grow in second half
            let scaleMod;
            if (rawT < 0.5) {
                scaleMod = 1 - (rawT * 2) * 0.3; // Shrink to 70%
            } else {
                scaleMod = 0.7 + ((rawT - 0.5) * 2) * 0.3; // Grow back to 100%
            }
            
            const currentA = {
                positionX: lerp(startA.positionX, endA.positionX, t),
                positionY: lerp(startA.positionY, endA.positionY, t),
                scaleX: lerp(startA.scaleX, endA.scaleX, t) * scaleMod,
                scaleY: lerp(startA.scaleY, endA.scaleY, t) * scaleMod
            };
            const currentB = {
                positionX: lerp(startB.positionX, endB.positionX, t),
                positionY: lerp(startB.positionY, endB.positionY, t),
                scaleX: lerp(startB.scaleX, endB.scaleX, t) * scaleMod,
                scaleY: lerp(startB.scaleY, endB.scaleY, t) * scaleMod
            };
            
            Promise.all([
                setTransform(idA, currentA),
                setTransform(idB, currentB)
            ]).then(() => {
                if (rawT < 1) requestAnimationFrame(animate);
                else resolve();
            });
        }
        requestAnimationFrame(animate);
    });
}

async function animateCrossfade(idA, idB, nameA, nameB, endA, endB, duration) {
    // Fade out both, swap positions, fade in both
    const halfDur = duration / 2;
    
    // Get source refs for opacity (requires filter manipulation via SetSourceFilterSettings)
    // Simplified: just do instant swap with a brief delay
    // For true crossfade, we'd need color correction filters
    
    // Quick version: scale down, swap, scale up
    const startTime = performance.now();
    
    await new Promise(resolve => {
        function animate() {
            const elapsed = performance.now() - startTime;
            const rawT = Math.min(elapsed / duration, 1);
            
            // Opacity simulation via scale (0.5 at midpoint)
            let opacityScale;
            if (rawT < 0.5) {
                opacityScale = 1 - rawT; // Fade out
            } else {
                opacityScale = rawT; // Fade in
            }
            
            // Position jumps at midpoint
            const posT = rawT < 0.5 ? 0 : 1;
            
            const idAVal = sources.find(s => s.sourceName === nameA)?.sceneItemId;
            const idBVal = sources.find(s => s.sourceName === nameB)?.sceneItemId;
            
            Promise.all([
                setTransform(idAVal, { scaleX: endA.scaleX * opacityScale, scaleY: endA.scaleY * opacityScale }),
                setTransform(idBVal, { scaleX: endB.scaleX * opacityScale, scaleY: endB.scaleY * opacityScale })
            ]).then(() => {
                if (rawT < 1) requestAnimationFrame(animate);
                else resolve();
            });
        }
        requestAnimationFrame(animate);
    });
}

async function executeSwap() {
    if (!connected) { 
        log('Connect to OBS first', 'error'); 
        showPage('setup');
        return; 
    }
    if (isSwapping) { log('Swap in progress', 'error'); return; }
    
    const nameA = document.getElementById('swapSourceA').value;
    const nameB = document.getElementById('swapSourceB').value;
    
    if (!nameA || !nameB) { log('Select both sources', 'error'); return; }
    if (nameA === nameB) { log('Select different sources', 'error'); return; }
    
    const idA = await getSceneItemId(nameA);
    const idB = await getSceneItemId(nameB);
    
    if (!idA || !idB) { log('Source not found', 'error'); return; }
    
    isSwapping = true;
    const style = document.getElementById('swapStyle').value;
    log(`Swapping ${nameA} ‚Üî ${nameB} (${style})...`, 'info');
    
    try {
        const tA = await getTransform(idA);
        const tB = await getTransform(idB);
        
        const duration = parseInt(document.getElementById('swapDuration').value) || 400;
        const easing = document.getElementById('swapEasing').value;
        
        // Properties to swap
        const propsToSwap = ['positionX', 'positionY', 'boundsWidth', 'boundsHeight', 'scaleX', 'scaleY'];
        
        const startA = {}, startB = {}, endA = {}, endB = {};
        for (const p of propsToSwap) {
            startA[p] = tA[p];
            startB[p] = tB[p];
            endA[p] = tB[p];
            endB[p] = tA[p];
        }
        
        if (style === 'teleport' || duration <= 0) {
            // Instant swap
            await setTransform(idA, endA);
            await setTransform(idB, endB);
        } else if (style === 'arc') {
            await animateArc(idA, idB, startA, startB, endA, endB, duration, easing);
            await setTransform(idA, endA);
            await setTransform(idB, endB);
        } else if (style === 'scale') {
            await animateScale(idA, idB, startA, startB, endA, endB, duration, easing);
            await setTransform(idA, endA);
            await setTransform(idB, endB);
        } else if (style === 'bounce') {
            await animateSlide(idA, idB, startA, startB, endA, endB, duration, 'bounce', propsToSwap);
        } else if (style === 'elastic') {
            await animateSlide(idA, idB, startA, startB, endA, endB, duration, 'elastic', propsToSwap);
        } else if (style === 'crossfade') {
            await animateScale(idA, idB, startA, startB, endA, endB, duration, easing);
            await setTransform(idA, endA);
            await setTransform(idB, endB);
        } else {
            // Default slide
            const startTime = performance.now();
            
            await new Promise(resolve => {
                function animate() {
                    const elapsed = performance.now() - startTime;
                    const rawT = Math.min(elapsed / duration, 1);
                    const t = easeFunc(rawT, easing);
                    
                    const currentA = {}, currentB = {};
                    for (const p of propsToSwap) {
                        currentA[p] = lerp(startA[p], endA[p], t);
                        currentB[p] = lerp(startB[p], endB[p], t);
                    }
                    
                    Promise.all([
                        setTransform(idA, currentA),
                        setTransform(idB, currentB)
                    ]).then(() => {
                        if (rawT < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    });
                }
                requestAnimationFrame(animate);
            });
        }
        
        log(`Swapped ${nameA} ‚Üî ${nameB}`, 'success');
    } catch (e) {
        log('Swap error: ' + e, 'error');
    }
    
    isSwapping = false;
}

function saveCurrentSwap() {
    const nameA = document.getElementById('swapSourceA').value;
    const nameB = document.getElementById('swapSourceB').value;
    if (!nameA || !nameB) { log('Select both sources first', 'error'); return; }
    
    const name = prompt('Config name:', `${nameA} ‚Üî ${nameB}`);
    if (!name) return;
    
    swapConfigs.push({ name, sourceA: nameA, sourceB: nameB });
    localStorage.setItem('swapConfigs', JSON.stringify(swapConfigs));
    renderSavedSwaps();
    log(`Saved config: ${name}`, 'success');
}

function renderSavedSwaps() {
    const container = document.getElementById('savedSwaps');
    if (swapConfigs.length === 0) {
        container.innerHTML = '<div class="empty-state" style="padding:15px">No saved configs</div>';
    } else {
        container.innerHTML = swapConfigs.map((c, i) => `
            <div class="source-item">
                <div>
                    <div class="name">${c.name}</div>
                    <div class="type">${c.sourceA} ‚Üî ${c.sourceB}</div>
                </div>
                <div style="display:flex;gap:4px">
                    <button onclick="loadSwapConfig(${i})">‚ñ∂</button>
                    <button onclick="deleteSwapConfig(${i})">‚úï</button>
                </div>
            </div>
        `).join('');
    }
    renderDashSwaps();
}

function loadSwapConfig(index) {
    const c = swapConfigs[index];
    document.getElementById('swapSourceA').value = c.sourceA;
    document.getElementById('swapSourceB').value = c.sourceB;
    executeSwap();
}

function deleteSwapConfig(index) {
    swapConfigs.splice(index, 1);
    localStorage.setItem('swapConfigs', JSON.stringify(swapConfigs));
    renderSavedSwaps();
}

function exportConfigs() {
    if (swapConfigs.length === 0) {
        log('No configs to export', 'error');
        return;
    }
    const json = JSON.stringify(swapConfigs, null, 2);
    navigator.clipboard.writeText(json).then(() => {
        log('Configs copied to clipboard!', 'success');
    }).catch(() => {
        // Fallback: show in prompt
        prompt('Copy this JSON:', json);
    });
}

function importConfigs() {
    const json = prompt('Paste config JSON:');
    if (!json) return;
    
    try {
        const imported = JSON.parse(json);
        if (!Array.isArray(imported)) throw new Error('Must be array');
        
        // Validate structure
        for (const c of imported) {
            if (!c.name || !c.sourceA || !c.sourceB) {
                throw new Error('Invalid config structure');
            }
        }
        
        // Merge or replace?
        const merge = swapConfigs.length > 0 && confirm('Merge with existing? (Cancel to replace)');
        if (merge) {
            swapConfigs = [...swapConfigs, ...imported];
        } else {
            swapConfigs = imported;
        }
        
        localStorage.setItem('swapConfigs', JSON.stringify(swapConfigs));
        renderSavedSwaps();
        log(`Imported ${imported.length} configs`, 'success');
    } catch (e) {
        log('Invalid JSON: ' + e.message, 'error');
    }
}

// ============ Text Cycler ============
let cycleInterval = null;
let cycleIndex = 0;

function updateTransitionMode() {
    const val = document.getElementById('textTransition').value;
    const info = document.getElementById('transitionInfo');
    const descriptions = {
        'none': 'Instant text change',
        'glitch': 'Scramble briefly, then reveal left-to-right',
        'typewriter': 'Type out one character at a time',
        'scramble': 'Random chars, then snap to final text'
    };
    info.textContent = descriptions[val] || '';
}

function updateTextSourceDropdown() {
    const select = document.getElementById('textSource');
    
    // Preserve current or load from saved state
    const savedState = JSON.parse(localStorage.getItem('ui_state') || '{}');
    const current = select.value || savedState.textSource || '';
    
    textSources = sources.filter(s => 
        s.inputKind && (s.inputKind.includes('text') || s.inputKind === 'text_gdiplus_v2' || s.inputKind === 'text_ft2_source_v2')
    );
    
    select.innerHTML = '<option value="">-- Select Text Source --</option>' +
        textSources.map(s => `<option value="${s.sourceName}">${s.sourceName}</option>`).join('');
    
    if (current && textSources.find(s => s.sourceName === current)) {
        select.value = current;
        loadTextSource();
    }
}

async function loadTextSource() {
    const name = document.getElementById('textSource').value;
    if (!name) {
        document.getElementById('textPreview').textContent = 'Select a source';
        return;
    }
    
    try {
        const data = await request('GetInputSettings', { inputName: name });
        const text = data.inputSettings.text || '';
        document.getElementById('textPreview').textContent = text || '(empty)';
    } catch (e) {
        log('Error loading text: ' + e, 'error');
    }
}

async function setText(text) {
    const name = document.getElementById('textSource').value;
    if (!name || !connected) return;
    
    try {
        await request('SetInputSettings', {
            inputName: name,
            inputSettings: { text: text }
        });
        document.getElementById('textPreview').textContent = text;
    } catch (e) {
        log('Error setting text: ' + e, 'error');
    }
}

function getTextLines() {
    return document.getElementById('textLines').value
        .split('\n')
        .map(l => l.trim())
        .filter(l => l.length > 0);
}

async function startSimpleCycle() {
    if (!connected) {
        log('Connect to OBS first', 'error');
        showPage('setup');
        return;
    }
    
    const lines = getTextLines();
    if (lines.length === 0) {
        log('Enter at least one text line', 'error');
        return;
    }
    if (!document.getElementById('textSource').value) {
        log('Select a text source first', 'error');
        return;
    }
    
    const duration = parseInt(document.getElementById('textDuration').value) || 3000;
    
    document.getElementById('startCycleBtn').disabled = true;
    document.getElementById('stopCycleBtn').disabled = false;
    
    cycleIndex = 0;
    showTextWithTransition(lines[0]); // Show first text with transition
    
    cycleInterval = setInterval(() => {
        cycleIndex = (cycleIndex + 1) % lines.length;
        showTextWithTransition(lines[cycleIndex]);
    }, duration);
    
    log('Text cycling started (' + lines.length + ' lines)', 'success');
}

// Animation state
let transitionInterval = null;

function showTextWithTransition(targetText) {
    const transition = document.getElementById('textTransition').value;
    const transDuration = parseInt(document.getElementById('transDuration').value) || 500;
    
    // Clear any existing transition
    if (transitionInterval) {
        clearInterval(transitionInterval);
        transitionInterval = null;
    }
    
    if (transition === 'none') {
        setTextFast(targetText);
        return;
    }
    
    const STEP_MS = 100; // Update every 100ms = max 10 calls/second
    const totalSteps = Math.max(Math.floor(transDuration / STEP_MS), 1);
    let currentStep = 0;
    
    function doStep() {
        currentStep++;
        const progress = currentStep / totalSteps;
        
        let displayText = targetText;
        
        if (transition === 'typewriter') {
            const chars = Math.ceil(progress * targetText.length);
            displayText = targetText.substring(0, chars);
        } else if (transition === 'glitch') {
            if (progress < 0.6) {
                displayText = scrambleText(targetText);
            } else {
                const revealProgress = (progress - 0.6) / 0.4;
                displayText = revealText(targetText, revealProgress);
            }
        } else if (transition === 'scramble') {
            if (progress < 0.9) {
                displayText = scrambleText(targetText);
            } else {
                displayText = targetText;
            }
        }
        
        setTextFast(displayText);
        
        if (currentStep >= totalSteps) {
            clearInterval(transitionInterval);
            transitionInterval = null;
            setTextFast(targetText); // Ensure final
        }
    }
    
    doStep(); // First step immediately
    if (totalSteps > 1) {
        transitionInterval = setInterval(doStep, STEP_MS);
    }
}

// Fire-and-forget text update (no await, no error handling that could block)
function setTextFast(text) {
    const name = document.getElementById('textSource').value;
    if (!name || !connected || !ws || ws.readyState !== WebSocket.OPEN) return;
    
    const id = 'txt_' + (msgId++);
    ws.send(JSON.stringify({
        op: 6,
        d: {
            requestType: 'SetInputSettings',
            requestId: id,
            requestData: {
                inputName: name,
                inputSettings: { text: text }
            }
        }
    }));
    document.getElementById('textPreview').textContent = text;
}

// Simple scramble - ASCII only to avoid encoding issues
function scrambleText(text) {
    const chars = '#$%&*@!?+=~<>[]{}';
    let result = '';
    for (let i = 0; i < text.length; i++) {
        if (text[i] === ' ') {
            result += ' ';
        } else {
            result += chars[Math.floor(Math.random() * chars.length)];
        }
    }
    return result;
}

// Reveal left to right
function revealText(target, progress) {
    const chars = '#$%&*@!?+=~<>[]{}';
    const revealed = Math.ceil(progress * target.length);
    let result = '';
    for (let i = 0; i < target.length; i++) {
        if (i < revealed) {
            result += target[i];
        } else if (target[i] === ' ') {
            result += ' ';
        } else {
            result += chars[Math.floor(Math.random() * chars.length)];
        }
    }
    return result;
}

function stopSimpleCycle() {
    if (cycleInterval) {
        clearInterval(cycleInterval);
        cycleInterval = null;
    }
    if (transitionInterval) {
        clearInterval(transitionInterval);
        transitionInterval = null;
    }
    
    document.getElementById('startCycleBtn').disabled = false;
    document.getElementById('stopCycleBtn').disabled = true;
    
    log('Text cycling stopped');
}


// ============ Keyboard Shortcuts ============
document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    // 1-9 triggers saved swap configs
    if (e.key >= '1' && e.key <= '9') {
        const idx = parseInt(e.key) - 1;
        if (idx < swapConfigs.length) loadSwapConfig(idx);
    }
    // Space toggles text cycler
    if (e.key === ' ') {
        e.preventDefault();
        cycleInterval ? stopTextCycle() : startTextCycle();
    }
});
</script>
</body>
</html>
